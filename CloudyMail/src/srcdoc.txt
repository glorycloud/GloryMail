package mobi.cloudymail.calendar;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.time.DateUtils;

import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Date;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.Parameter;
import net.fortuna.ical4j.model.Property;
import net.fortuna.ical4j.model.ValidationException;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.parameter.Value;
import net.fortuna.ical4j.model.property.CalScale;
import net.fortuna.ical4j.model.property.Location;
import net.fortuna.ical4j.model.property.Name;
import net.fortuna.ical4j.model.property.ProdId;
import net.fortuna.ical4j.model.property.RRule;
import net.fortuna.ical4j.model.property.TzName;
import net.fortuna.ical4j.model.property.Version;
import net.fortuna.ical4j.util.HostInfo;
import net.fortuna.ical4j.util.UidGenerator;

import mobi.cloudymail.mailclient.Composer;
import mobi.cloudymail.mailclient.R;

import android.app.Activity;
import android.app.ListActivity;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.Intent;
import android.database.Cursor;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;

import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

public class AllCalendarEvents extends ListActivity implements CompoundButton.OnCheckedChangeListener
{
	public static int year, month, day;
	
	private java.util.Calendar cal_begin = java.util.Calendar.getInstance();
	private java.util.Calendar cal_end = java.util.Calendar.getInstance();
	private java.util.Calendar helper_calendar = java.util.Calendar.getInstance();
	private MenuItem miNewRecord;
	private MenuItem miDeleteRecord; 
	private MenuItem miSendSelectedRecord;
		
    private Button miNewRecord1;
	private Button miDeleteRecord1; 
	private Button miSendSelectedRecord1;
	private LinearLayout layout;
	private static String calendarURIBase = "";
	private List< Map<String, String> > eventList;
	private  Set<Integer> _checkedEvents = new HashSet<Integer>();
	private EventlistAdapter eventAdapter;
	
	static {
		if (Integer.parseInt(Build.VERSION.SDK) >= 8) {
			calendarURIBase = "content://com.android.calendar";
		} else {
			calendarURIBase = "content://calendar";
		}
	}
	
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
		setContentView(R.layout.calendar_event_list);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.calendar_titlebar);
		miNewRecord1=(Button)findViewById(R.id.addEventBtn);
		miDeleteRecord1=(Button)findViewById(R.id.delEventBtn);
		miSendSelectedRecord1=(Button)findViewById(R.id.SendEventBtn);
		layout=(LinearLayout)findViewById(R.id.selectEventLayout);
		updateWindowTitle();
		Button bt = (Button)findViewById(R.id.add_event);
		bt.setOnClickListener(new OnClickListener() {
		
			@Override
			public void onClick(View v)
			{
				 NewRecord();
				
			}
		});
//		setTitle(sdf.format(helper_calendar.getTime()));
		miNewRecord1.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v)
			{
				 NewRecord();
				
			}
		});
		miDeleteRecord1.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v)
			{
				DelRecord();
			}
		});
		miSendSelectedRecord1.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v)
			{
				
				SendSelectRecord();
			}
		});
		if (eventList == null)
			eventList = new ArrayList<Map<String, String>>();
		else 
			eventList.clear();
		
		getEventList();
		ListView lv=getListView();
		if(eventList.size()==0)
		{
			lv.setBackgroundResource(R.drawable.noevent);
		}
		
		if(eventAdapter == null) 
				eventAdapter = new EventlistAdapter(eventList, this);

		setListAdapter(eventAdapter);
	}

	@Override
	protected void onRestart() {
		// TODO Auto-generated method stub
		super.onRestart();
		updateWindowTitle();
		eventList.clear();
		_checkedEvents.clear();
		getEventList();
		eventAdapter.setEvents(eventList);
	}

	
	private void updateWindowTitle()
	{
		year = getIntent().getExtras().getInt("year");
		month = getIntent().getExtras().getInt("month");
		day = getIntent().getExtras().getInt("day");
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy年M月d日");
		helper_calendar.set(year, month, day);
		TextView txtView=(TextView)findViewById(R.id.calendartitle);
		txtView.setText(sdf.format(helper_calendar.getTime()));
		
	}

	private void getEventList()
	{
		// first; find out which calendars exist	
		ContentResolver contentResolver = getContentResolver(); 
		/*
		 * Fetching all events, and particular event is done by specifying range
	     */
		Uri.Builder builder = Uri.parse(calendarURIBase + "/instances/when").buildUpon(); 
		cal_begin.set(year, month, day, 0, 0, 0);
		ContentUris.appendId(builder, cal_begin.getTimeInMillis()); //now - DateUtils.DAY_IN_MILLIS * 10000); 
		cal_end.set(year, month, day, 23, 59, 59);
		ContentUris.appendId(builder, cal_end.getTimeInMillis());//now + DateUtils.DAY_IN_MILLIS * 10000); 

		Cursor eventCursor = contentResolver.query(builder.build(), 
		                			               new String[] {"event_id", "title", "dtstart", "dtend", "allDay", "description", 
												   "eventLocation", "eventTimezone", "selfAttendeeStatus", "rrule"}, 
												   null, null, "startDay ASC, startMinute ASC");
		
/*		
		String names[];
		names = envetCursor1.getColumnNames();
*/		
		while (eventCursor.moveToNext())
		{
		//	String selfAS = eventCursor.getString(eventCursor.getColumnIndex("selfAttendeeStatus"));
		//	String eventStatus = eventCursor.getString(eventCursor.getColumnIndex("eventStatus"));			
			Long beginTime = Long.valueOf(eventCursor.getString(2));
			helper_calendar.setTimeInMillis(beginTime);
			int beginMonth = helper_calendar.get(Calendar.MONTH) + 1;
			int beginDay = helper_calendar.get(Calendar.DATE);
			int beginHour = helper_calendar.get(Calendar.HOUR_OF_DAY);
			int beginMin = helper_calendar.get(Calendar.MINUTE);
					
			Long endTime = Long.valueOf(eventCursor.getString(3));
			helper_calendar.setTimeInMillis(endTime);
			int endMonth = helper_calendar.get(Calendar.MONTH) + 1;
			int endDay = helper_calendar.get(Calendar.DATE);
			int endHour = helper_calendar.get(Calendar.HOUR_OF_DAY);
			int endMin = helper_calendar.get(Calendar.MINUTE);
					
			Map<String, String> map = new HashMap<String, String>();
			map.put("event_id", eventCursor.getString(0));
			map.put("title", eventCursor.getString(1));
			map.put("beginTime", eventCursor.getString(2));
			map.put("endTime", eventCursor.getString(3));
			map.put("allDay", eventCursor.getString(4));
			map.put("description", eventCursor.getString(5));
			map.put("location", eventCursor.getString(6));
			map.put("timezone", eventCursor.getString(7));
			map.put("selfAttendeeStatus", eventCursor.getString(8));
			map.put("rrule", eventCursor.getString(9));
			if(eventCursor.getString(4).equals("1")) 
			{
				if(endDay == day)
				{
					continue;
				}
				helper_calendar.setTimeInMillis(endTime - DateUtils.MILLIS_PER_DAY);
				endMonth = helper_calendar.get(Calendar.MONTH) + 1;
				endDay = helper_calendar.get(Calendar.DATE);
				endHour = helper_calendar.get(Calendar.HOUR_OF_DAY);
				endMin = helper_calendar.get(Calendar.MINUTE);
				map.put("content", eventCursor.getString(1) + "\r\n" + beginMonth + "月" + beginDay + "日" + " - " + endMonth + "月" + endDay + "日");
			}
			else
			{
				if((beginMonth==endMonth) && (beginDay== endDay))
				{
					map.put("content", eventCursor.getString(1) + "\r\n" + beginHour + ":" + beginMin + " - " + endHour + ":" + endMin);
				}
				else
				{
					map.put("content", eventCursor.getString(1) + "\r\n" + beginMonth + "月" + beginDay + "日" + " " + beginHour + ":" + beginMin + " - " 
				                                                         + endMonth + "月" + endDay + "日" + " " + endHour + ":" + endMin);		
				}
			}
			eventList.add(map);
		}
		eventCursor.close();
	}
	
	@Override
	protected void onListItemClick(ListView l, View v, int position, long id) {
		// TODO Auto-generated method stub
		super.onListItemClick(l, v, position, id);
		Intent intent = new Intent(Intent.ACTION_VIEW); 
		intent.setData(Uri.parse(calendarURIBase + "/events/" + eventList.get(position).get("event_id")));  
		
	    intent.putExtra("beginTime", Long.valueOf(eventList.get(position).get("beginTime")));
	    intent.putExtra("endTime", Long.valueOf(eventList.get(position).get("endTime")));
		startActivity(intent); 
	}
	
//	@Override
//	public boolean onCreateOptionsMenu(Menu menu)
//	{
//		miNewRecord = menu.add(0, 1, 1, "添加");
//		miDeleteRecord = menu.add(0, 2, 2, "删除");
//		miSendSelectedRecord = menu.add(0, 5, 5, "发送");
//		
//		miNewRecord.setOnMenuItemClickListener(new OnAddRecordMenuItemClick(this));
//		miDeleteRecord.setOnMenuItemClickListener(new OnDeleteRecordMenuItemClick(this));
//		miSendSelectedRecord.setOnMenuItemClickListener(new OnSendSelectedRecordMenuItemClick(this));
//		return true;
//	}
	
	class MenuItemClickParent
	{
		protected Activity activity;

		public MenuItemClickParent(Activity activity)
		{
			this.activity = activity;
		}
	}
	
	class OnAddRecordMenuItemClick extends MenuItemClickParent implements OnMenuItemClickListener
	{

		@Override
		public boolean onMenuItemClick(MenuItem item)
		{
			NewRecord();
			return true;
		}

		public OnAddRecordMenuItemClick(Activity activity)
		{
			super(activity);
		}
	}
	
	class LocalHostInfo implements HostInfo
	{

		@Override
		public String getHostName() {
			return "127.0.0.1";
		}
		
	}
	
	class OnSendSelectedRecordMenuItemClick extends MenuItemClickParent implements OnMenuItemClickListener
	{
		private Activity _activity;
		public OnSendSelectedRecordMenuItemClick(Activity activity)
		{
			super(activity);
			_activity = activity;

		}

		@Override
		public boolean onMenuItemClick(MenuItem item)
		{
			SendSelectRecord();
			
			return true;
		}
	}
	
	class OnDeleteRecordMenuItemClick extends MenuItemClickParent implements OnMenuItemClickListener
	{
		public OnDeleteRecordMenuItemClick(Activity activity)
		{
			super(activity);
			// TODO Auto-generated constructor stub
		}

		@Override
		public boolean onMenuItemClick(MenuItem item)
		{
			DelRecord();
			
			return true;
		}
		
	}
	
	@Override
	public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
		int position = (Integer) buttonView.getTag(); // <-- get the position
		if (isChecked)
			_checkedEvents.add(position);
		else
		{
			_checkedEvents.remove(position);
		}	
		layout.setVisibility(_checkedEvents.isEmpty()?View.GONE:View.VISIBLE);
		
	}
	
	private class EventlistAdapter extends BaseAdapter {
		private List< Map<String, String> > _eventList;
		private AllCalendarEvents _ace;
		
		public EventlistAdapter(List<Map<String, String>> eventList, AllCalendarEvents ace) {
			_ace = ace;
			_eventList = eventList;
		}
		
		public void setEvents(List< Map<String, String> >  eventList) {
			_eventList = eventList;
			notifyDataSetChanged();
		}
		
		@Override
		public int getCount() {
			return _eventList.size();
		}

		@Override
		public long getItemId(int position) {
			return position;
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			ViewHolder holder = null;
			if(convertView == null) {
				convertView = _ace.getLayoutInflater().inflate(R.layout.event_item, null);
				holder = new ViewHolder();
				holder.eventBox = (CheckBox) convertView.findViewById(R.id.calendarEventCtx);
				holder.eventBox.setOnCheckedChangeListener(_ace);
				holder.ctText = (TextView) convertView.findViewById(R.id.eventContent);	
				convertView.setTag(holder);
			}
			else
			{
				// Get the ViewHolder back to get fast access to the TextView
				// and the CheckBox.
				holder = (ViewHolder) convertView.getTag();
			}
			holder.eventBox.setTag(position);
			holder.ctText.setText(_eventList.get(position).get("content"));
			holder.eventBox
			.setChecked(_ace._checkedEvents.contains(position));
			return convertView;
		}

		@Override
		public Object getItem(int arg0) {
			// TODO Auto-generated method stub
			return null;
		}
		
	}
	
	private class ViewHolder {
		CheckBox eventBox;
		TextView ctText;
	}

    public void NewRecord(){
    	java.util.Calendar cal = java.util.Calendar.getInstance();
		int Hour = cal.get(Calendar.HOUR_OF_DAY);
		int Minute = cal.get(Calendar.MINUTE);
		cal_begin.set(year, month, day, Hour, Minute);
		cal_end.set(year, month, day, Hour + 1, Minute);
		Intent intent = new Intent(Intent.ACTION_EDIT); 
	    intent.setType("vnd.android.cursor.item/event"); 
	    intent.putExtra("beginTime", cal_begin.getTimeInMillis());
	    intent.putExtra("endTime", cal_end.getTimeInMillis());
	    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK 
	            | Intent.FLAG_ACTIVITY_SINGLE_TOP 
	            | Intent.FLAG_ACTIVITY_CLEAR_TOP 
	            | Intent.FLAG_ACTIVITY_NO_HISTORY 
	            | Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET); 
	    startActivity(intent); 
    }
    
    public void DelRecord()  {

    	if(_checkedEvents.isEmpty())
		{
    		return;
		}
		Iterator<Integer> itr = _checkedEvents.iterator();
		//	int checkedSize = _checkedEvents.size();
	
		while (itr.hasNext())
		{
			Map<String, String> eventItem = eventList.get(itr.next());
			int event_id = Integer.valueOf(eventItem.get("event_id"));	
			DeleteCalendarEntry(event_id);
		}
		onRestart();
    	if(eventList.isEmpty())
			layout.setVisibility(View.INVISIBLE);
    }
	
	private void DeleteCalendarEntry(int event_id) 
	{  
		Uri eventUri = Uri.parse(calendarURIBase + "/events/" + event_id);  
		getContentResolver().delete(eventUri, null, null);     
    } 
    
    public void SendSelectRecord(){


		net.fortuna.ical4j.model.Calendar ical = new net.fortuna.ical4j.model.Calendar();

		ical.getProperties().add(new ProdId("-//Ben Fortuna//iCal4j 1.0//EN"));
		ical.getProperties().add(Version.VERSION_2_0);
		ical.getProperties().add(CalScale.GREGORIAN);

		Iterator<Integer> itr = _checkedEvents.iterator();
		// int checkedSize = _checkedEvents.size();

		LocalHostInfo localInfo = new LocalHostInfo();
		UidGenerator ug = new UidGenerator(localInfo, "1");
		String[] icaFilePaths = new String[_checkedEvents.size()];
		int i = 0;
		String fileName = null;
		while (itr.hasNext())
			try
			{
				Map<String, String> eventItem = eventList.get(itr.next());

				String name = eventItem.get("title");
				String beginTime = eventItem.get("beginTime");
				String endTime = eventItem.get("endTime");
				String allDay = eventItem.get("allDay");
				String location = eventItem.get("location");
				String summary = eventItem.get("description");
				String timezone = eventItem.get("timezone");
				String rrule = eventItem.get("rrule");

				fileName = name;

				VEvent new_event = null;
				if (allDay.equals("1"))
				{
					new_event = new VEvent(new Date(new java.util.Date(Long
							.valueOf(beginTime))), new Date(new java.util.Date(Long
							.valueOf(endTime))), summary);
					// Parameter a =
					// new_event.getProperties().getProperty(Property.DTSTART).getParameter("VALUE");
				}
				else
				{
					new_event = new VEvent(new DateTime(Long.valueOf(beginTime)),
											new DateTime(Long.valueOf(endTime)), summary);
				}
				new_event.getProperties().add(ug.generateUid());
				new_event.getProperties().add(new Location(location));
				new_event.getProperties().add(new Name(name));
				new_event.getProperties().add(new TzName(timezone));
				try
				{
					if (rrule != null)
					{
						new_event.getProperties().add(new RRule(rrule));
					}
				}
				catch (ParseException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

				ical.getComponents().add(new_event);
				try
				{
					File file = new File(Environment.getExternalStorageDirectory(),
											fileName + ".ics");
					file.createNewFile();
					FileOutputStream fout = new FileOutputStream(file);

					CalendarOutputter outputter = new CalendarOutputter();
					outputter.output(ical, fout);
					fout.close();

					icaFilePaths[i++] = Environment.getExternalStorageDirectory() + "/"
										+ fileName + ".ics";

				}
				catch (FileNotFoundException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				catch (IOException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				catch (ValidationException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			catch (NumberFormatException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		Intent intent = new Intent(AllCalendarEvents.this, Composer.class);
		intent.putExtra("icaFilePaths", icaFilePaths);
		startActivity(intent);
		// if(fileName == null)
		// {
		// return;
		// }
		//
		
	
    }
}package mobi.cloudymail.calendar;

import mobi.cloudymail.mailclient.R;
import android.app.Activity;
import android.graphics.Canvas;
import android.view.View;
import android.widget.TextView;

public class Border extends CalendarParent
{

	public Border(Activity activity, View view)
	{
		super(activity, view);
		paint.setColor(activity.getResources().getColor(R.color.border_color));
	}

	@Override
	public void draw(Canvas canvas)
	{
		float left = borderMargin;
		float top = borderMargin;
		float right = view.getMeasuredWidth() - left;
		float bottom=borderMargin + weekNameSize+borderMargin*3+6*(dayTopOffset+daySize+gregorianDaySize+borderMargin/2);
		canvas.drawLine(left, top, right, top, paint);
		canvas.drawLine(right, top, right, bottom, paint);
		canvas.drawLine(right, bottom, left, bottom, paint);
		canvas.drawLine(left, bottom, left, top, paint);

	}

}
package mobi.cloudymail.calendar;

import java.util.ArrayList;
import mobi.cloudymail.calendar.interfaces.CalendarElement;
import android.app.Activity;
import android.graphics.Canvas; 
import android.view.View;

public class Calendar extends CalendarParent 
{
	private ArrayList<CalendarElement> elements = new ArrayList<CalendarElement>();
    public Grid grid;
	public Calendar(Activity activity, View view)
	{	
		super(activity,view);
//		elements.add(new Border(activity, view));
//		elements.add(new Week(activity, view));
		grid = new Grid(activity, view);
		elements.add(grid);
	}

	@Override
	public void draw(Canvas canvas)
	{
		for (CalendarElement ce : elements)
			ce.draw(canvas);
	}

}
package mobi.cloudymail.calendar;


import mobi.cloudymail.calendar.interfaces.CalendarElement;
import mobi.cloudymail.mailclient.R;
import android.app.Activity;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.view.View;

public class CalendarParent implements CalendarElement
{
	protected Activity activity;
	protected View view;
	protected Paint paint = new Paint();
	protected float borderMargin;		
	protected float weekNameMargin;
	protected float weekNameSize;
	protected float gregorianDaySize;
    protected float daySize;
	protected int sundaySaturdayColor;
	protected float dayTopOffset;

    public CalendarParent(Activity activity, View view)
    {    	
    	this.activity = activity;
    	this.view = view;
		borderMargin = activity.getResources().getDimension(
				R.dimen.calendar_border_margin);
        weekNameMargin = activity.getResources().getDimension(R.dimen.weekname_margin);
        weekNameSize=activity.getResources().getDimension(R.dimen.weekname_size);
        sundaySaturdayColor = activity.getResources().getColor(R.color.sunday_saturday_color);
        gregorianDaySize=activity.getResources().getDimension(R.dimen.gregorian_day_size);
        daySize=activity.getResources().getDimension(R.dimen.day_size);
        dayTopOffset=activity.getResources().getDimension(R.dimen.day_top_offset);
    }
	@Override
	public void draw(Canvas canvas)
	{		
		
	}

}
package mobi.cloudymail.calendar;

import mobi.cloudymail.mailclient.R;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
public class CalendarView extends View
{
	public Calendar ce;
	static Bitmap bitmap=null;
	static Rect initDst = new Rect();
	static Rect initSrc = new Rect();
	Paint paint = new Paint();
    Calendar_main _calActivity;
	@Override
	protected void onDraw(Canvas canvas)
	{
		if (bitmap == null) 
		{
			BitmapFactory.Options options = new BitmapFactory.Options();
			options.inDensity = 240;
			bitmap = BitmapFactory.decodeResource(_calActivity.getResources(),
					R.drawable.calendar1_02, options); // options must be added
			View v = _calActivity.getWindow().findViewById(
					Window.ID_ANDROID_CONTENT);// 获得根视图

			// the screen's density equals the picture's(using BitmapFactory method)
			int screenDensity = _calActivity.screenDensity;
			float viewHeightInch = (float) v.getHeight() / (float) screenDensity;
			float viewWidthInch = (float) v.getWidth() / (float) screenDensity;
			// get the picture's attributes then use inch express them
			int picDensity = bitmap.getDensity();
			int picWidth = bitmap.getWidth();
			int picHeight = bitmap.getHeight();
			float picHeightInch = (float) picHeight / (float) picDensity;
			float picWidthInch = (float) picWidth / (float) picDensity;

			// Bitmap bitmap2 = new
			// BitmapDrawable(getResources().openRawResource(R.drawable.calendar1_02)).getBitmap();
			
			initDst.left = picWidthInch >= viewWidthInch ? 0 : ((int) (picDensity
					* (viewWidthInch - picWidthInch) / 2));
			// dst.top
			// =picHeightInch>=viewHeightInch?0:((int)(picDensity*(viewHeightInch-picHeightInch)/2));
			initDst.top = 0;
			initDst.bottom = picHeightInch >= viewHeightInch ? v.getHeight()
					: (initDst.top + picHeight);
			initDst.right = picWidthInch >= viewWidthInch ? v.getWidth()
					: (initDst.left + picWidth);

			
			initSrc.left = picWidthInch >= viewWidthInch ? (int) (picDensity
					* (picWidthInch - viewWidthInch) / 2) : 0;
			initSrc.top = 0;
			initSrc.right = picWidthInch >= viewWidthInch ? (initSrc.left + (int) (viewWidthInch * picDensity))
					: picWidth;
			// bottom equals the smaller one of the viewHeightInch and the
			// picHeightInch
			initSrc.bottom = (int) ((picHeightInch >= viewHeightInch ? viewHeightInch
					: picHeightInch) * picDensity);			
//		    selectbitmap = Bitmap.createBitmap(bitmap, initSrc.left, initSrc.top,
//		    		initSrc.right, initSrc.bottom);// 按照指定区域创建位图
		}
		canvas.drawBitmap(bitmap, initSrc, initDst, paint);
        ce.draw(canvas);
		

	}
 
	public CalendarView(Calendar_main activity)
	{
		super(activity);
		_calActivity=activity;
		ce = new Calendar(activity, this);
	}

	@Override
	public boolean onTouchEvent(MotionEvent motion)
	{

		ce.grid.setCellX(motion.getX());
		ce.grid.setCellY(motion.getY());
		if (ce.grid.inBoundary())
		{
			this.invalidate(); //liupan
		}
		return super.onTouchEvent(motion);
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event)
	{

		switch (keyCode)
		{

			case KeyEvent.KEYCODE_DPAD_UP:
			{

				ce.grid.setCurrentRow(ce.grid.getCurrentRow() - 1);
				break;
			}
			case KeyEvent.KEYCODE_DPAD_DOWN:
			{
				ce.grid.setCurrentRow(ce.grid.getCurrentRow() + 1);
				break;
			}
			case KeyEvent.KEYCODE_DPAD_LEFT:
			{
				ce.grid.setCurrentCol(ce.grid.getCurrentCol() - 1);
				break;
			}
			case KeyEvent.KEYCODE_DPAD_RIGHT:
			{
				ce.grid.setCurrentCol(ce.grid.getCurrentCol() + 1);
				break;
			}
		
		}
		
		return true;
	}
}
package mobi.cloudymail.calendar;

import java.text.SimpleDateFormat;

import mobi.cloudymail.mailclient.R;
import android.R.integer;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.DialogInterface.OnClickListener;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Vibrator;
import android.util.DisplayMetrics;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.View;
import android.view.Window;
import android.widget.Button;
import android.widget.DatePicker;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.DatePicker.OnDateChangedListener;


public class Calendar_main extends Activity
{
	private java.util.Calendar cal_begin = java.util.Calendar.getInstance();
	private java.util.Calendar cal_end = java.util.Calendar.getInstance();
	
	public CalendarView calendarView;	
	private AlertDialog.Builder builder;
	private AlertDialog adMyDate;
	public static Activity activity;

	public static MediaPlayer mediaPlayer;
	public static Vibrator vibrator;
	public int screenDensity;



	public ScrollLayout root=null;
	
	public static final String FIRST_INTENT_TAG = "first";
	public static final String SECOND_INTENT_TAG = "second";
	public static final String THIRD_INTENT_TAG = "third";
	public static final int FIRST_VIEW = 0;
	public static final int SECOND_VIEW = 1;
	public static final int THIRD_VIEW = 2;
	public CalendarView mFirstView, mSecondView, mThirdView;
	
	    
	    public Handler mHandler = new Handler(){
	    	@Override
	    	public void handleMessage(Message msg) {
	    		
	    		super.handleMessage(msg);
	    		switch (msg.what) {
				case FIRST_VIEW:
					break;
				case SECOND_VIEW:
					break;
					
				case THIRD_VIEW:
					break;
				default:
					break;
				}
	    	}
	    };
	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		if (activity == null)
		{
			activity = this;
		}
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
//		RelativeLayout mainLayout = (RelativeLayout) getLayoutInflater().inflate(
//				R.layout.calendar_main, null);
//		
//		setContentView(mainLayout);
		setContentView(R.layout.calendar_main);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.calendar_titlebar);
//		calendarView = new CalendarView(this);
//		mainLayout.addView(calendarView);
      
		root =(ScrollLayout) findViewById(R.id.ScrollLayout);
		mFirstView=new CalendarView(this);
		mSecondView=new CalendarView(this);
		
		mThirdView=new CalendarView(this);
//		mFirstView.draw_which=ScrollLayout.DRAW_PRE;
//		mThirdView.draw_which=ScrollLayout.DRAW_NEXT;
		mFirstView.setTag(FIRST_INTENT_TAG);
		mSecondView.setTag(SECOND_INTENT_TAG);
		mThirdView.setTag(THIRD_INTENT_TAG);
		root.addView(mFirstView);
		root.addView(mSecondView);
		root.addView(mThirdView);
		
		CalendarView view=(CalendarView)root.getCurScreen();
		java.util.Calendar calendar = java.util.Calendar.getInstance();

		view.ce.grid.currentYear = calendar.get(java.util.Calendar.YEAR);
		view.ce.grid.currentMonth = calendar.get(java.util.Calendar.MONTH);
		view.ce.grid.currentDay = calendar.get(java.util.Calendar.DATE);
		
		root.reDrawChildView(view);
		calendarView.invalidate();
		Button bt = (Button)findViewById(R.id.add_event);
		bt.setOnClickListener(new OnAddRecordButtonClick());
		updateWindowTitle();

		//画背景图calendar1_02
		DisplayMetrics metrics = new DisplayMetrics();
		getWindowManager().getDefaultDisplay().getMetrics(metrics);
		screenDensity=metrics.densityDpi;
		                                                
				
	}
	@Override
	protected void onResume()
	{
		updateWindowTitle();
		CalendarView view=(CalendarView)root.getCurScreen();
		view.ce.grid.currentYear=calendarView.ce.grid.currentYear;
		view.ce.grid.currentMonth=calendarView.ce.grid.currentMonth;
		view.ce.grid.currentDay=calendarView.ce.grid.currentDay;
		root.reDrawChildView(view);
		calendarView.invalidate();
		super.onResume();
	}

	class MenuItemClickParent
	{
		protected Activity activity;

		public MenuItemClickParent(Activity activity)
		{
			this.activity = activity;
		}
	}

	class OnEventMenuItemClick extends MenuItemClickParent implements
			OnMenuItemClickListener
	{

		public OnEventMenuItemClick(Activity activity)
		{
			super(activity);

		}

		@Override
		public boolean onMenuItemClick(MenuItem item)
		{
			Intent intent = new Intent(activity, AllCalendarEvents.class);
			intent.putExtra("year", calendarView.ce.grid.currentYear);
			intent.putExtra("month", calendarView.ce.grid.currentMonth);
			intent.putExtra("day", calendarView.ce.grid.currentDay1);
			activity.startActivity(intent);
			return true;
		}

	}
	
	class OnAddRecordButtonClick implements android.view.View.OnClickListener
	{
		
		@Override
		public void onClick(View v) {
			// TODO Auto-generated method stub
			java.util.Calendar cal = java.util.Calendar.getInstance();
			int Hour = cal.get(java.util.Calendar.HOUR_OF_DAY);
			int Minute = cal.get(java.util.Calendar.MINUTE);
			cal_begin.set(calendarView.ce.grid.currentYear,
					      calendarView.ce.grid.currentMonth, 
					      calendarView.ce.grid.currentDay1,
					      Hour, Minute);
			cal_end.set(calendarView.ce.grid.currentYear,
						calendarView.ce.grid.currentMonth, 
						calendarView.ce.grid.currentDay, 
						Hour + 1, Minute);
			Intent intent = new Intent(Intent.ACTION_EDIT); 
		    intent.setType("vnd.android.cursor.item/event"); 
		    intent.putExtra("beginTime", cal_begin.getTimeInMillis());
		    intent.putExtra("endTime", cal_end.getTimeInMillis());
		    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK 
		            | Intent.FLAG_ACTIVITY_SINGLE_TOP 
		            | Intent.FLAG_ACTIVITY_CLEAR_TOP 
		            | Intent.FLAG_ACTIVITY_NO_HISTORY 
		            | Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET); 
		    startActivity(intent); 
		}
	}
	class OnTodayMenuItemClick extends MenuItemClickParent implements
			OnMenuItemClickListener
	{

		public OnTodayMenuItemClick(Activity activity)
		{
			super(activity);

		}

		@Override
		public boolean onMenuItemClick(MenuItem item)
		{
			CalendarView view=(CalendarView)root.getCurScreen();
			java.util.Calendar calendar = java.util.Calendar.getInstance();

			view.ce.grid.currentYear = calendar.get(java.util.Calendar.YEAR);
			view.ce.grid.currentMonth = calendar.get(java.util.Calendar.MONTH);
			view.ce.grid.currentDay = calendar.get(java.util.Calendar.DATE);
			
			root.reDrawChildView(view);
			calendarView.invalidate();

			return true;
		}

	}

	class OnMyDateMenuItemClick extends MenuItemClickParent implements
			OnMenuItemClickListener, OnClickListener, OnDateChangedListener
	{
		private DatePicker dpSelectDate;
		private LinearLayout myDateLayout;
		private TextView tvDate;
		private TextView tvLunarDate;

		public OnMyDateMenuItemClick(Activity activity)
		{
			super(activity);
			myDateLayout = (LinearLayout) getLayoutInflater().inflate(
					R.layout.mydate, null);
			dpSelectDate = (DatePicker) myDateLayout
					.findViewById(R.id.dpSelectDate);

		}

		@Override
		public void onDateChanged(DatePicker view, int year, int monthOfYear,
				int dayOfMonth)
		{

			SimpleDateFormat sdf = new SimpleDateFormat("yyyy年M月d日");
			java.util.Calendar calendar = java.util.Calendar.getInstance();
			calendar.set(year, monthOfYear, dayOfMonth);
			if (tvDate != null)
				tvDate.setText(sdf.format(calendar.getTime()));
			else
				adMyDate.setTitle(sdf.format(calendar.getTime()));

			java.util.Calendar calendar1 = java.util.Calendar.getInstance();
			if (calendar1.get(java.util.Calendar.YEAR) == year
					&& calendar1.get(java.util.Calendar.MONTH) == monthOfYear
					&& calendar1.get(java.util.Calendar.DATE) == dayOfMonth)
			{
				if (tvDate != null)
					tvDate.setText(tvDate.getText() + "(今天)");
				else
					adMyDate.setTitle(sdf.format(calendar.getTime()) + "(今天)");
			}

			if (tvLunarDate == null)
				return;
			
		}

		@Override
		public void onClick(DialogInterface dialog, int which)
		{
			CalendarView view=(CalendarView)root.getCurScreen();
			view.ce.grid.currentYear = dpSelectDate.getYear();
			view.ce.grid.currentMonth = dpSelectDate.getMonth();
			view.ce.grid.currentDay = dpSelectDate.getDayOfMonth();
			root.reDrawChildView(view);
			calendarView.invalidate();

		}

		@Override
		public boolean onMenuItemClick(MenuItem item)
		{
			// Create a builder
			builder = new AlertDialog.Builder(activity);
			builder.setTitle("指定日期");

			myDateLayout = (LinearLayout) getLayoutInflater().inflate(
					R.layout.mydate, null);
			dpSelectDate = (DatePicker) myDateLayout
					.findViewById(R.id.dpSelectDate);
			tvDate = (TextView) myDateLayout.findViewById(R.id.tvDate);
			tvLunarDate = (TextView) myDateLayout
					.findViewById(R.id.tvLunarDate);

			dpSelectDate.init(calendarView.ce.grid.currentYear,
					calendarView.ce.grid.currentMonth,
					calendarView.ce.grid.currentDay, this);

			builder.setView(myDateLayout);

			builder.setPositiveButton("确定", this);
			builder.setNegativeButton("取消", null);
			builder.setIcon(R.drawable.calendar_small);
			adMyDate = builder.create();
			onDateChanged(dpSelectDate, dpSelectDate.getYear(), dpSelectDate
					.getMonth(), dpSelectDate.getDayOfMonth());
			adMyDate.show();

			return true;
		}
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu)
	{
		
        
		MenuItem miToday = menu.add(0, 1, 0, R.string.today);
		MenuItem miMyDate = menu.add(0, 2, 0, R.string.assign_date);
		MenuItem miEvent = menu.add(0, 3, 0, R.string.check_event);	
		
		miToday.setIcon(R.drawable.clock);
		miToday.setOnMenuItemClickListener(new OnTodayMenuItemClick(this));
		miMyDate.setIcon(R.drawable.calendar_small);
		miMyDate.setOnMenuItemClickListener(new OnMyDateMenuItemClick(this));
		miEvent.setIcon(R.drawable.diary);
		miEvent.setOnMenuItemClickListener(new OnEventMenuItemClick(this));

		return super.onCreateOptionsMenu(menu);
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event)
	{
		calendarView.onKeyDown(keyCode, event);
		return super.onKeyDown(keyCode, event);
	}
	private void updateWindowTitle()
	{
		TextView txtView=(TextView)findViewById(R.id.calendartitle);
		txtView.setText(R.string.app_name);
	}
}package mobi.cloudymail.calendar;

import android.R.integer;

/**
 * ChineseCalendarGB.java Copyright (c) 1997-2002 by Dr. Herong Yang.
 * http://www.herongyang.com/ 中国农历算法 - 实用于公历 1901 年至 2100 年之间的 200 年
 */
public class ChineseCalendarGB
{
	private int gregorianYear;
	private int gregorianMonth;
	private int gregorianDate;
	private boolean isGregorianLeap;
	private int dayOfYear;
	private int dayOfWeek; // 周日一星期的第一天
	private int chineseYear;
	private int chineseMonth; // 负数表示闰月
	private int chineseDate;
	private int sectionalTerm;
	private int principleTerm;
	private static char[] daysInGregorianMonth = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
	private static String[] stemNames = { "甲", "乙", "丙", "丁", "戊", "己", "庚", "辛", "壬", "癸" };
	private static String[] branchNames = { "子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌",
											"亥" };
	private static String[] animalNames = { "鼠", "牛", "虎", "兔", "龙", "蛇", "马", "羊", "猴", "鸡", "狗",
											"猪" };
	/**
	 * @return the chineseYear
	 */
	public int getChineseYear()
	{
		return chineseYear;
	}

	/**
	 * @return the chineseMonth
	 */
	public int getChineseMonth()
	{
		return chineseMonth;
	}

	/**
	 * @return the chineseDate
	 */
	public int getChineseDate()
	{
		return chineseDate;
	}

//	public static void main(String[] arg)
//	{
//		ChineseCalendarGB c = new ChineseCalendarGB();
//		String cmd = "day";
//		int y = 2012;
//		int m = 7;
//		int d = 13;
//		if (arg.length > 0)
//			cmd = arg[0];
//		if (arg.length > 1)
//			y = Integer.parseInt(arg[1]);
//		if (arg.length > 2)
//			m = Integer.parseInt(arg[2]);
//		if (arg.length > 3)
//			d = Integer.parseInt(arg[3]);
//		c.setGregorian(y, m, d);
//		c.computeChineseFields();
//		c.computeSolarTerms();
//		if (cmd.equalsIgnoreCase("year"))
//		{
//			String[] t = c.getYearTable();
//			for (int i = 0; i < t.length; i++)
//				System.out.println(t[i]);
//		}
//		else if (cmd.equalsIgnoreCase("month"))
//		{
//			String[] t = c.getMonthTable();
//			for (int i = 0; i < t.length; i++)
//				System.out.println(t[i]);
//		}
//		else
//		{
//			System.out.println(c.toString());
//		}
//	}

	public ChineseCalendarGB()
	{
		setGregorian(1901, 1, 1);
	}

	public void setGregorian(int y, int m, int d)
	{
		gregorianYear = y;
		gregorianMonth = m;
		gregorianDate = d;
		isGregorianLeap = isGregorianLeapYear(y);
		dayOfYear = dayOfYear(y, m, d);
		dayOfWeek = dayOfWeek(y, m, d);
		chineseYear = 0;
		chineseMonth = 0;
		chineseDate = 0;
		sectionalTerm = 0;
		principleTerm = 0;
	}

	public static boolean isGregorianLeapYear(int year)
	{
		boolean isLeap = false;
		if (year % 4 == 0)
			isLeap = true;
		if (year % 100 == 0)
			isLeap = false;
		if (year % 400 == 0)
			isLeap = true;
		return isLeap;
	}

	public static int daysInGregorianMonth(int y, int m)
	{
		int d = daysInGregorianMonth[m - 1];
		if (m == 2 && isGregorianLeapYear(y))
			d++; // 公历闰年二月多一天
		return d;
	}

	public static int dayOfYear(int y, int m, int d)
	{
		int c = 0;
		for (int i = 1; i < m; i++)
		{
			c = c + daysInGregorianMonth(y, i);
		}
		c = c + d;
		return c;
	}

	public static int dayOfWeek(int y, int m, int d)
	{
		int w = 1; // 公历一年一月一日是星期一，所以起始值为星期日
		y = (y - 1) % 400 + 1; // 公历星期值分部 400 年循环一次
		int ly = (y - 1) / 4; // 闰年次数
		ly = ly - (y - 1) / 100;
		ly = ly + (y - 1) / 400;
		int ry = y - 1 - ly; // 常年次数
		w = w + ry; // 常年星期值增一
		w = w + 2 * ly; // 闰年星期值增二
		w = w + dayOfYear(y, m, d);
		w = (w - 1) % 7 + 1;
		return w;
	}

	private static char[] chineseMonths = {
											// 农历月份大小压缩表，两个字节表示一年。两个字节共十六个二进制位数，
											// 前四个位数表示闰月月份，后十二个位数表示十二个农历月份的大小。
											0x00, 0x04, 0xad, 0x08, 0x5a, 0x01, 0xd5, 0x54, 0xb4,
											0x09, 0x64, 0x05, 0x59, 0x45, 0x95, 0x0a, 0xa6, 0x04,
											0x55, 0x24, 0xad, 0x08, 0x5a, 0x62, 0xda, 0x04, 0xb4,
											0x05, 0xb4, 0x55, 0x52, 0x0d, 0x94, 0x0a, 0x4a, 0x2a,
											0x56, 0x02, 0x6d, 0x71, 0x6d, 0x01, 0xda, 0x02, 0xd2,
											0x52, 0xa9, 0x05, 0x49, 0x0d, 0x2a, 0x45, 0x2b, 0x09,
											0x56, 0x01, 0xb5, 0x20, 0x6d, 0x01, 0x59, 0x69, 0xd4,
											0x0a, 0xa8, 0x05, 0xa9, 0x56, 0xa5, 0x04, 0x2b, 0x09,
											0x9e, 0x38, 0xb6, 0x08, 0xec, 0x74, 0x6c, 0x05, 0xd4,
											0x0a, 0xe4, 0x6a, 0x52, 0x05, 0x95, 0x0a, 0x5a, 0x42,
											0x5b, 0x04, 0xb6, 0x04, 0xb4, 0x22, 0x6a, 0x05, 0x52,
											0x75, 0xc9, 0x0a, 0x52, 0x05, 0x35, 0x55, 0x4d, 0x0a,
											0x5a, 0x02, 0x5d, 0x31, 0xb5, 0x02, 0x6a, 0x8a, 0x68,
											0x05, 0xa9, 0x0a, 0x8a, 0x6a, 0x2a, 0x05, 0x2d, 0x09,
											0xaa, 0x48, 0x5a, 0x01, 0xb5, 0x09, 0xb0, 0x39, 0x64,
											0x05, 0x25, 0x75, 0x95, 0x0a, 0x96, 0x04, 0x4d, 0x54,
											0xad, 0x04, 0xda, 0x04, 0xd4, 0x44, 0xb4, 0x05, 0x54,
											0x85, 0x52, 0x0d, 0x92, 0x0a, 0x56, 0x6a, 0x56, 0x02,
											0x6d, 0x02, 0x6a, 0x41, 0xda, 0x02, 0xb2, 0xa1, 0xa9,
											0x05, 0x49, 0x0d, 0x0a, 0x6d, 0x2a, 0x09, 0x56, 0x01,
											0xad, 0x50, 0x6d, 0x01, 0xd9, 0x02, 0xd1, 0x3a, 0xa8,
											0x05, 0x29, 0x85, 0xa5, 0x0c, 0x2a, 0x09, 0x96, 0x54,
											0xb6, 0x08, 0x6c, 0x09, 0x64, 0x45, 0xd4, 0x0a, 0xa4,
											0x05, 0x51, 0x25, 0x95, 0x0a, 0x2a, 0x72, 0x5b, 0x04,
											0xb6, 0x04, 0xac, 0x52, 0x6a, 0x05, 0xd2, 0x0a, 0xa2,
											0x4a, 0x4a, 0x05, 0x55, 0x94, 0x2d, 0x0a, 0x5a, 0x02,
											0x75, 0x61, 0xb5, 0x02, 0x6a, 0x03, 0x61, 0x45, 0xa9,
											0x0a, 0x4a, 0x05, 0x25, 0x25, 0x2d, 0x09, 0x9a, 0x68,
											0xda, 0x08, 0xb4, 0x09, 0xa8, 0x59, 0x54, 0x03, 0xa5,
											0x0a, 0x91, 0x3a, 0x96, 0x04, 0xad, 0xb0, 0xad, 0x04,
											0xda, 0x04, 0xf4, 0x62, 0xb4, 0x05, 0x54, 0x0b, 0x44,
											0x5d, 0x52, 0x0a, 0x95, 0x04, 0x55, 0x22, 0x6d, 0x02,
											0x5a, 0x71, 0xda, 0x02, 0xaa, 0x05, 0xb2, 0x55, 0x49,
											0x0b, 0x4a, 0x0a, 0x2d, 0x39, 0x36, 0x01, 0x6d, 0x80,
											0x6d, 0x01, 0xd9, 0x02, 0xe9, 0x6a, 0xa8, 0x05, 0x29,
											0x0b, 0x9a, 0x4c, 0xaa, 0x08, 0xb6, 0x08, 0xb4, 0x38,
											0x6c, 0x09, 0x54, 0x75, 0xd4, 0x0a, 0xa4, 0x05, 0x45,
											0x55, 0x95, 0x0a, 0x9a, 0x04, 0x55, 0x44, 0xb5, 0x04,
											0x6a, 0x82, 0x6a, 0x05, 0xd2, 0x0a, 0x92, 0x6a, 0x4a,
											0x05, 0x55, 0x0a, 0x2a, 0x4a, 0x5a, 0x02, 0xb5, 0x02,
											0xb2, 0x31, 0x69, 0x03, 0x31, 0x73, 0xa9, 0x0a, 0x4a,
											0x05, 0x2d, 0x55, 0x2d, 0x09, 0x5a, 0x01, 0xd5, 0x48,
											0xb4, 0x09, 0x68, 0x89, 0x54, 0x0b, 0xa4, 0x0a, 0xa5,
											0x6a, 0x95, 0x04, 0xad, 0x08, 0x6a, 0x44, 0xda, 0x04,
											0x74, 0x05, 0xb0, 0x25, 0x54, 0x03 };
	// 初始日，公历农历对应日期：
	// 公历 1901 年 1 月 1 日，对应农历 4598 年 11 月 11 日
	private static int baseYear = 1901;
	private static int baseMonth = 1;
	private static int baseDate = 1;
	private static int baseIndex = 0;
	private static int baseChineseYear = 4598 - 1;
	private static int baseChineseMonth = 11;
	private static int baseChineseDate = 11;

	public int computeChineseFields()
	{
		if (gregorianYear < 1901 || gregorianYear > 2100)
			return 1;
		int startYear = baseYear;
		int startMonth = baseMonth;
		int startDate = baseDate;
		chineseYear = baseChineseYear;
		chineseMonth = baseChineseMonth;
		chineseDate = baseChineseDate;
		// 第二个对应日，用以提高计算效率
		// 公历 2000 年 1 月 1 日，对应农历 4697 年 11 月 25 日
		if (gregorianYear >= 2000)
		{
			startYear = baseYear + 99;
			startMonth = 1;
			startDate = 1;
			chineseYear = baseChineseYear + 99;
			chineseMonth = 11;
			chineseDate = 25;
		}
		int daysDiff = 0;
		for (int i = startYear; i < gregorianYear; i++)
		{
			daysDiff += 365;
			if (isGregorianLeapYear(i))
				daysDiff += 1; // leap year
		}
		for (int i = startMonth; i < gregorianMonth; i++)
		{
			daysDiff += daysInGregorianMonth(gregorianYear, i);
		}
		daysDiff += gregorianDate - startDate;

		chineseDate += daysDiff;
		int lastDate = daysInChineseMonth(chineseYear, chineseMonth);
		int nextMonth = nextChineseMonth(chineseYear, chineseMonth);
		while (chineseDate > lastDate)
		{
			if (Math.abs(nextMonth) < Math.abs(chineseMonth))
				chineseYear++;
			chineseMonth = nextMonth;
			chineseDate -= lastDate;
			lastDate = daysInChineseMonth(chineseYear, chineseMonth);
			nextMonth = nextChineseMonth(chineseYear, chineseMonth);
		}
		return 0;
	}

	private static int[] bigLeapMonthYears = {
												// 大闰月的闰年年份
												6, 14, 19, 25, 33, 36, 38, 41, 44, 52, 55, 79, 117,
												136, 147, 150, 155, 158, 185, 193 };

	public static int daysInChineseMonth(int y, int m)
	{
		// 注意：闰月 m < 0
		int index = y - baseChineseYear + baseIndex;
		int v = 0;
		int l = 0;
		int d = 30;
		if (1 <= m && m <= 8)
		{
			v = chineseMonths[2 * index];
			l = m - 1;
			if (((v >> l) & 0x01) == 1)
				d = 29;
		}
		else if (9 <= m && m <= 12)
		{
			v = chineseMonths[2 * index + 1];
			l = m - 9;
			if (((v >> l) & 0x01) == 1)
				d = 29;
		}
		else
		{
			v = chineseMonths[2 * index + 1];
			v = (v >> 4) & 0x0F;
			if (v != Math.abs(m))
			{
				d = 0;
			}
			else
			{
				d = 29;
				for (int i = 0; i < bigLeapMonthYears.length; i++)
				{
					if (bigLeapMonthYears[i] == index)
					{
						d = 30;
						break;
					}
				}
			}
		}
		return d;
	}

	public static int nextChineseMonth(int y, int m)
	{
		int n = Math.abs(m) + 1;
		if (m > 0)
		{
			int index = y - baseChineseYear + baseIndex;
			int v = chineseMonths[2 * index + 1];
			v = (v >> 4) & 0x0F;
			if (v == m)
				n = -m;
		}
		if (n == 13)
			n = 1;
		return n;
	}

	private static char[][] sectionalTermMap = {
												{ 7, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6,
													6, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5 },
												{ 5, 4, 5, 5, 5, 4, 4, 5, 5, 4, 4, 4, 4, 4, 4, 4,
													4, 3, 4, 4, 4, 3, 3, 4, 4, 3, 3, 3 },
												{ 6, 6, 6, 7, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6, 6,
													5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5, 5 },
												{ 5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5,
													4, 4, 5, 5, 4, 4, 4, 5, 4, 4, 4, 4, 5 },
												{ 6, 6, 6, 7, 6, 6, 6, 6, 5, 6, 6, 6, 5, 5, 6, 6,
													5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5, 5 },
												{ 6, 6, 7, 7, 6, 6, 6, 7, 6, 6, 6, 6, 5, 6, 6, 6,
													5, 5, 6, 6, 5, 5, 5, 6, 5, 5, 5, 5, 4, 5, 5, 5,
													5 },
												{ 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7,
													6, 7, 7, 7, 6, 6, 7, 7, 6, 6, 6, 7, 7 },
												{ 8, 8, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8,
													7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 6, 6, 7, 7,
													7 },
												{ 8, 8, 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8,
													7, 7, 7, 8, 7, 7, 7, 7, 6, 7, 7, 7, 7 },
												{ 9, 9, 9, 9, 8, 9, 9, 9, 8, 8, 9, 9, 8, 8, 8, 9,
													8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8, 8 },
												{ 8, 8, 8, 8, 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8,
													7, 7, 7, 7, 6, 7, 7, 7, 6, 6, 7, 7, 7 },
												{ 7, 8, 8, 8, 7, 7, 8, 8, 7, 7, 7, 8, 7, 7, 7, 7,
													6, 7, 7, 7, 6, 6, 7, 7, 6, 6, 6, 7, 7 } };
	private static char[][] sectionalTermYear = { { 13, 49, 85, 117, 149, 185, 201, 250, 250 },
													{ 13, 45, 81, 117, 149, 185, 201, 250, 250 },
													{ 13, 48, 84, 112, 148, 184, 200, 201, 250 },
													{ 13, 45, 76, 108, 140, 172, 200, 201, 250 },
													{ 13, 44, 72, 104, 132, 168, 200, 201, 250 },
													{ 5, 33, 68, 96, 124, 152, 188, 200, 201 },
													{ 29, 57, 85, 120, 148, 176, 200, 201, 250 },
													{ 13, 48, 76, 104, 132, 168, 196, 200, 201 },
													{ 25, 60, 88, 120, 148, 184, 200, 201, 250 },
													{ 16, 44, 76, 108, 144, 172, 200, 201, 250 },
													{ 28, 60, 92, 124, 160, 192, 200, 201, 250 },
													{ 17, 53, 85, 124, 156, 188, 200, 201, 250 } };
	private static char[][] principleTermMap = {
												{ 21, 21, 21, 21, 21, 20, 21, 21, 21, 20, 20, 21,
													21, 20, 20, 20, 20, 20, 20, 20, 20, 19, 20, 20,
													20, 19, 19, 20 },
												{ 20, 19, 19, 20, 20, 19, 19, 19, 19, 19, 19, 19,
													19, 18, 19, 19, 19, 18, 18, 19, 19, 18, 18, 18,
													18, 18, 18, 18 },
												{ 21, 21, 21, 22, 21, 21, 21, 21, 20, 21, 21, 21,
													20, 20, 21, 21, 20, 20, 20, 21, 20, 20, 20, 20,
													19, 20, 20, 20, 20 },
												{ 20, 21, 21, 21, 20, 20, 21, 21, 20, 20, 20, 21,
													20, 20, 20, 20, 19, 20, 20, 20, 19, 19, 20, 20,
													19, 19, 19, 20, 20 },
												{ 21, 22, 22, 22, 21, 21, 22, 22, 21, 21, 21, 22,
													21, 21, 21, 21, 20, 21, 21, 21, 20, 20, 21, 21,
													20, 20, 20, 21, 21 },
												{ 22, 22, 22, 22, 21, 22, 22, 22, 21, 21, 22, 22,
													21, 21, 21, 22, 21, 21, 21, 21, 20, 21, 21, 21,
													20, 20, 21, 21, 21 },
												{ 23, 23, 24, 24, 23, 23, 23, 24, 23, 23, 23, 23,
													22, 23, 23, 23, 22, 22, 23, 23, 22, 22, 22, 23,
													22, 22, 22, 22, 23 },
												{ 23, 24, 24, 24, 23, 23, 24, 24, 23, 23, 23, 24,
													23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23,
													22, 22, 22, 23, 23 },
												{ 23, 24, 24, 24, 23, 23, 24, 24, 23, 23, 23, 24,
													23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23,
													22, 22, 22, 23, 23 },
												{ 24, 24, 24, 24, 23, 24, 24, 24, 23, 23, 24, 24,
													23, 23, 23, 24, 23, 23, 23, 23, 22, 23, 23, 23,
													22, 22, 23, 23, 23 },
												{ 23, 23, 23, 23, 22, 23, 23, 23, 22, 22, 23, 23,
													22, 22, 22, 23, 22, 22, 22, 22, 21, 22, 22, 22,
													21, 21, 22, 22, 22 },
												{ 22, 22, 23, 23, 22, 22, 22, 23, 22, 22, 22, 22,
													21, 22, 22, 22, 21, 21, 22, 22, 21, 21, 21, 22,
													21, 21, 21, 21, 22 } };
	private static char[][] principleTermYear = { { 13, 45, 81, 113, 149, 185, 201 },
													{ 21, 57, 93, 125, 161, 193, 201 },
													{ 21, 56, 88, 120, 152, 188, 200, 201 },
													{ 21, 49, 81, 116, 144, 176, 200, 201 },
													{ 17, 49, 77, 112, 140, 168, 200, 201 },
													{ 28, 60, 88, 116, 148, 180, 200, 201 },
													{ 25, 53, 84, 112, 144, 172, 200, 201 },
													{ 29, 57, 89, 120, 148, 180, 200, 201 },
													{ 17, 45, 73, 108, 140, 168, 200, 201 },
													{ 28, 60, 92, 124, 160, 192, 200, 201 },
													{ 16, 44, 80, 112, 148, 180, 200, 201 },
													{ 17, 53, 88, 120, 156, 188, 200, 201 } };

	public int computeSolarTerms()
	{
		if (gregorianYear < 1901 || gregorianYear > 2100)
			return 1;
		sectionalTerm = sectionalTerm(gregorianYear, gregorianMonth);
		principleTerm = principleTerm(gregorianYear, gregorianMonth);
		return 0;
	}

	public static int sectionalTerm(int y, int m)
	{
		if (y < 1901 || y > 2100)
			return 0;
		int index = 0;
		int ry = y - baseYear + 1;
		while (ry >= sectionalTermYear[m - 1][index])
			index++;
		int term = sectionalTermMap[m - 1][4 * index + ry % 4];
		if ((ry == 121) && (m == 4))
			term = 5;
		if ((ry == 132) && (m == 4))
			term = 5;
		if ((ry == 194) && (m == 6))
			term = 6;
		return term;
	}

	public static int principleTerm(int y, int m)
	{
		if (y < 1901 || y > 2100)
			return 0;
		int index = 0;
		int ry = y - baseYear + 1;
		while (ry >= principleTermYear[m - 1][index])
			index++;
		int term = principleTermMap[m - 1][4 * index + ry % 4];
		if ((ry == 171) && (m == 3))
			term = 21;
		if ((ry == 181) && (m == 5))
			term = 21;
		return term;
	}

	public String toString()
	{
		StringBuffer buf = new StringBuffer();
		buf.append("Gregorian Year: " + gregorianYear + "\n");
		buf.append("Gregorian Month: " + gregorianMonth + "\n");
		buf.append("Gregorian Date: " + gregorianDate + "\n");
		buf.append("Is Leap Year: " + isGregorianLeap + "\n");
		buf.append("Day of Year: " + dayOfYear + "\n");
		buf.append("Day of Week: " + dayOfWeek + "\n");
		buf.append("Chinese Year: " + chineseYear + "\n");
		buf.append("Heavenly Stem: " + ((chineseYear - 1) % 10) + "\n");
		buf.append("Earthly Branch: " + ((chineseYear - 1) % 12) + "\n");
		buf.append("Chinese Month: " + chineseMonth + "\n");
		buf.append("Chinese Date: " + chineseDate + "\n");
		buf.append("Sectional Term: " + sectionalTerm + "\n");
		buf.append("Principle Term: " + principleTerm + "\n");
		return buf.toString();
	}

	public String[] getYearTable()
	{
		setGregorian(gregorianYear, 1, 1);
		computeChineseFields();
		computeSolarTerms();
		String[] table = new String[58]; // 6*9 + 4
		table[0] = getTextLine(27, "公历年历：" + gregorianYear);
		table[1] = getTextLine(27, "农历年历：" + (chineseYear + 1) + " ("
									+ stemNames[(chineseYear + 1 - 1) % 10]
									+ branchNames[(chineseYear + 1 - 1) % 12] + " - "
									+ animalNames[(chineseYear + 1 - 1) % 12] + "年)");
		int ln = 2;
		String blank = "                                         " + "  "
						+ "                                         ";
		String[] mLeft = null;
		String[] mRight = null;
		for (int i = 1; i <= 6; i++)
		{
			table[ln] = blank;
			ln++;
			mLeft = getMonthTable();
			mRight = getMonthTable();
			for (int j = 0; j < mLeft.length; j++)
			{
				String line = mLeft[j] + "  " + mRight[j];
				table[ln] = line;
				ln++;
			}
		}
		table[ln] = blank;
		ln++;
		table[ln] = getTextLine(0, "##/## - 公历日期/农历日期，(*)#月 - (闰)农历月第一天");
		ln++;
		return table;
	}

	public static String getTextLine(int s, String t)
	{
		String str = "                                         " + "  "
						+ "                                         ";
		if (t != null && s < str.length() && s + t.length() < str.length())
			str = str.substring(0, s) + t + str.substring(s + t.length());
		return str;
	}

	private static String[] monthNames = { "一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一",
											"十二" };

	public String[] getMonthTable()
	{
		setGregorian(gregorianYear, gregorianMonth, 1);
		computeChineseFields();
		computeSolarTerms();
		String[] table = new String[8];
		String title = null;
		if (gregorianMonth < 11)
			title = "                   ";
		else
			title = "                 ";
		title = title + monthNames[gregorianMonth - 1] + "月" + "                   ";
		String header = "   日    一    二    三    四    五    六 ";
		String blank = "                                          ";
		table[0] = title;
		table[1] = header;
		int wk = 2;
		String line = "";
		for (int i = 1; i < dayOfWeek; i++)
		{
			line += "     " + ' ';
		}
		int days = daysInGregorianMonth(gregorianYear, gregorianMonth);
		for (int i = gregorianDate; i <= days; i++)
		{
			line += getDateString() + ' ';
			rollUpOneDay();
			if (dayOfWeek == 1)
			{
				table[wk] = line;
				line = "";
				wk++;
			}
		}
		for (int i = dayOfWeek; i <= 7; i++)
		{
			line += "     " + ' ';
		}
		table[wk] = line;
		for (int i = wk + 1; i < table.length; i++)
		{
			table[i] = blank;
		}
		for (int i = 0; i < table.length; i++)
		{
			table[i] = table[i].substring(0, table[i].length() - 1);
		}

		return table;
	}

	private static String[] chineseMonthNames = { "正", "二", "三", "四", "五", "六", "七", "八", "九", "十",
													"冬", "腊" };
	private static String[] principleTermNames = { "雨水", "春分", "谷雨", "夏满", "夏至", "大暑", "处暑", "秋分",
													"霜降", "小雪", "冬至", "大寒" };
	private static String[] sectionalTermNames = { "立春", "惊蛰", "清明", "立夏", "芒种", "小暑", "立秋", "白露",
													"寒露", "立冬", "大雪", "小寒" };

	public String getDateString()
	{
		String str = "*  /  ";
		String gm = String.valueOf(gregorianMonth);
		if (gm.length() == 1)
			gm = ' ' + gm;
		String cm = String.valueOf(Math.abs(chineseMonth));
		if (cm.length() == 1)
			cm = ' ' + cm;
		String gd = String.valueOf(gregorianDate);
		if (gd.length() == 1)
			gd = ' ' + gd;
		String cd = String.valueOf(chineseDate);
		if (cd.length() == 1)
			cd = ' ' + cd;
		if (gregorianDate == sectionalTerm)
		{
			str = " " + sectionalTermNames[gregorianMonth - 1];
		}
		else if (gregorianDate == principleTerm)
		{
			str = " " + principleTermNames[gregorianMonth - 1];
		}
		else if (chineseDate == 1 && chineseMonth > 0)
		{
			str = " " + chineseMonthNames[chineseMonth - 1] + "月";
		}
		else if (chineseDate == 1 && chineseMonth < 0)
		{
			str = "*" + chineseMonthNames[-chineseMonth - 1] + "月";
		}
		else
		{
			str = gd + '/' + cd;
		}
		return str;
	}

	public int rollUpOneDay()
	{
		dayOfWeek = dayOfWeek % 7 + 1;
		dayOfYear++;
		gregorianDate++;
		int days = daysInGregorianMonth(gregorianYear, gregorianMonth);
		if (gregorianDate > days)
		{
			gregorianDate = 1;
			gregorianMonth++;
			if (gregorianMonth > 12)
			{
				gregorianMonth = 1;
				gregorianYear++;
				dayOfYear = 1;
				isGregorianLeap = isGregorianLeapYear(gregorianYear);
			}
			sectionalTerm = sectionalTerm(gregorianYear, gregorianMonth);
			principleTerm = principleTerm(gregorianYear, gregorianMonth);
		}
		chineseDate++;
		days = daysInChineseMonth(chineseYear, chineseMonth);
		if (chineseDate > days)
		{
			chineseDate = 1;
			chineseMonth = nextChineseMonth(chineseYear, chineseMonth);
			if (chineseMonth == 1)
				chineseYear++;
		}
		return 0;
	}
	public String getGregorianReturnData(String gregorian)
	{
		String[] s=gregorian.split(",");
		String month=s[0];
		String date=s[1];
		String gregorian_return="";
		switch (Integer.parseInt(date))
		{
		case 2:
			gregorian_return="初二";
			break;
		case 3:
			gregorian_return="初三";
			break;
		case 4:
			gregorian_return="初四";
			break;
		case 5:
			gregorian_return="初五";
			break;
		case 6:
			gregorian_return="初六";
			break;
		case 7:
			gregorian_return="初七";
			break;
		case 8:
			gregorian_return="初八";
			break;
		case 9:
			gregorian_return="初九";
			break;
		case 10:
			gregorian_return="初十";
			break;
		case 11:
			gregorian_return="十一";
			break;
		case 12:
			gregorian_return="十二";
			break;
		case 13:
			gregorian_return="十三";
			break;
		case 14:
			gregorian_return="十四";
			break;
		case 15:
			gregorian_return="十五";
			break;
		case 16:
			gregorian_return="十六";
			break;
		case 17:
			gregorian_return="十七";
			break;
		case 18:
			gregorian_return="十八";
			break;
		case 19:
			gregorian_return="十九";
			break;
		case 20:
			gregorian_return="二十";
			break;
		case 21:
			gregorian_return="廿一";
			break;
		case 22:
			gregorian_return="廿二";
			break;
		case 23:
			gregorian_return="廿三";
			break;
		case 24:
			gregorian_return="廿四";
			break;
		case 25:
			gregorian_return="廿五";
			break;
		case 26:
			gregorian_return="廿六";
			break;
		case 27:
			gregorian_return="廿七";
			break;
		case 28:
			gregorian_return="廿八";
			break;
		case 29:
			gregorian_return="廿九";
			break;
		case 30:
			gregorian_return="三十";
			break;
		case 1:
		{
			int m=Integer.parseInt(month);
			if(m<0)
				gregorian_return="闰";
			switch (Math.abs(m))
			{
			case 1:
				gregorian_return+="一月";
				break;
			case 2:
				gregorian_return+="二月";
				break;
			case 3:
				gregorian_return+="三月";
				break;
			case 4:
				gregorian_return+="四月";
				break;
			case 5:
				gregorian_return+="五月";
				break;
			case 6:
				gregorian_return+="六月";
				break;
			case 7:
				gregorian_return+="七月";
				break;
			case 8:
				gregorian_return+="八月";
				break;
			case 9:
				gregorian_return+="九月";
				break;
			case 10:
				gregorian_return+="十月";
				break;
			case 11:
				gregorian_return+="十一月";
				break;
			case 12:
				gregorian_return+="十二月";
				break;
			}
			break;
		}
			
		}
		return gregorian_return;
	}

}
package mobi.cloudymail.calendar.data;

import java.util.HashMap;
import java.util.Map;

public class Cities
{
	public static Map<String, String[]> cities = new HashMap<String, String[]>();
	public static Map<String, String> especialCities = new HashMap<String, String>();
	static
	{
		//////////////////////
		especialCities.put("朝阳", "/wap/54324/h24/");
		//////////////////////
		
		String[] hljCities = new String[]
		{ "哈尔滨", "齐齐哈尔", "鸡西", "鹤岗", "双鸭山", "大庆", "伊春", "佳木斯", "七台河", "牡丹江",
				"黑河", "绥化", "大兴安岭" };
		cities.put("黑龙江", hljCities);
		String[] jlCities = new String[]
		{ "长春", "吉林", "四平", "辽源", "通化", "白山", "松原", "白城", "延边" };
		cities.put("吉林", jlCities);

		String[] lnCities = new String[]
		{ "沈阳", "大连", "鞍山", "抚顺", "本溪", "丹东", "锦州", "营口", "阜新", "辽阳", "盘锦",
				"铁岭", "朝阳", "葫芦岛" };
		cities.put("辽宁", lnCities);

		String[] sdCities = new String[]
		{ "济南", "青岛", "淄博", "枣庄", "东营", "烟台", "潍坊", "济宁", "泰安", "威海", "日照",
				"莱芜", "临沂", "德州", "聊城", "滨州", "菏泽" };
		cities.put("山东", sdCities);

		String[] sxCities = new String[]
		{ "太原", "大同", "阳泉", "长治", "晋城", "朔州", "晋中", "运城", "忻州", "临汾", "吕梁" };
		cities.put("山西", sxCities);

		String[] sx1Cities = new String[]
		{ "西安", "铜川", "宝鸡", "咸阳", "渭南", "延安", "汉中", "榆林", "安康", "商洛" };
		cities.put("陕西", sx1Cities);

		String[] hbCities = new String[]
		{ "石家庄", "唐山", "秦皇岛", "邯郸", "邢台", "保定", "张家口", "承德", "沧州", "廊坊", "衡水" };
		cities.put("河北", hbCities);

		String[] hnCities = new String[]
		{ "郑州", "开封", "洛阳", "平顶山", "安阳", "鹤壁", "新乡", "焦作", "济源", "濮阳", "许昌",
				"漯河", "三门峡", "南阳", "商丘", "信阳", "周口", "驻马店" };
		cities.put("河南", hnCities);

		String[] hb1Cities = new String[]
		{ "武汉", "黄石", "十堰", "宜昌", "襄樊", "鄂州", "荆门", "孝感", "荆州", "黄冈", "咸宁",
				"随州", "恩施", "仙桃", "潜江", "天门", "神农架" };
		cities.put("湖北", hb1Cities);

		String[] hn1Cities = new String[]
		{ "长沙", "株洲", "湘潭", "衡阳", "邵阳", "岳阳", "常德", "张家界", "益阳", "郴州", "永州",
				"怀化", "娄底", "湘西" };
		cities.put("湖南", hn1Cities);
		String[] jsCities = new String[]
		{ "南京", "无锡", "徐州", "常州", "苏州", "南通", "连云港", "淮安", "盐城", "扬州", "镇江",
				"泰州", "宿迁" };
		cities.put("江苏", jsCities);

		String[] jxCities = new String[]
		{ "南昌", "景德镇", "萍乡", "九江", "新余", "鹰潭", "赣州", "吉安", "宜春", "抚州", "上饶" };
		cities.put("江西", jxCities);

		String[] gdCities = new String[]
		{ "广州", "韶关", "深圳", "珠海", "汕头", "佛山", "江门", "湛江", "茂名", "肇庆", "惠州",
				"梅州", "汕尾", "河源", "阳江", "清远", "东莞", "中山", "潮州", "揭阳", "云浮" };
		cities.put("广东", gdCities);

		String[] gxCities = new String[]
		{ "南宁", "柳州", "桂林", "梧州", "北海", "防城港", "钦州", "贵港", "玉林", "百色", "贺州",
				"河池", "来宾", "崇左" };
		cities.put("广西", gxCities);

		String[] ynCities = new String[]
		{ "昆明", "曲靖", "玉溪", "保山", "昭通", "丽江", "思茅", "临沧", "楚雄", "红河", "普洱",
				"文山", "大理", "德宏", "怒江" };
		cities.put("云南", ynCities);
		String[] gzCities = new String[]
		{ "贵阳", "六盘水", "遵义", "安顺", "铜仁", "毕节", "晴隆", "都匀", "凯里" };
		cities.put("贵州", gzCities);

		String[] scCities = new String[]
		{ "成都", "自贡", "攀枝花", "泸州", "德阳", "绵阳", "广元", "遂宁", "内江", "乐山", "南充",
				"宜宾", "广安", "达州", "巴中", "雅安", "眉山", "资阳", "阿坝", "甘孜", "凉山" };
		cities.put("四川", scCities);

		String[] nmgCities = new String[]
		{ "呼和浩特", "包头", "呼伦贝尔", "乌兰浩特", "通辽", "赤峰", "锡林浩特", "集宁", "鄂尔多斯", "临河",
				"乌海", "阿拉善左旗" };
		cities.put("内蒙古", nmgCities);

		String[] nxCities = new String[]
		{ "银川", "石嘴山", "中卫", "固原", "吴忠" };
		cities.put("宁夏", nxCities);

		String[] gsCities = new String[]
		{ "兰州", "金昌", "白银", "天水", "武威", "张掖", "酒泉", "平凉", "庆阳", "定西", "武都",
				"临夏", "临夏" };
		cities.put("甘肃", gsCities);

		String[] qhCities = new String[]
		{ "西宁", "海东", "海南", "海北", "海西", "黄南", "果洛", "玉树" };
		cities.put("青海", qhCities);

		String[] xzCities = new String[]
		{ "拉萨", "日喀则", "山南", "林芝", "昌都", "那曲", "阿里" };
		cities.put("西藏", xzCities);

		String[] xjCities = new String[]
		{ "乌鲁木齐", "克拉玛依", "吐鲁番", "哈密", "和田", "阿克苏", "喀什", "阿图什", "库尔勒", "昌吉",
				"博乐", "伊宁", "塔城", "阿勒泰", "石河子", "阿拉尔" };
		cities.put("新疆", xjCities);

		String[] ahCities = new String[]
		{ "合肥", "亳州", "淮北", "宿州", "阜阳", "蚌埠", "淮南", "滁州", "六安", "巢湖", "芜湖",
				"马鞍山", "安庆", "池州", "铜陵", "宣城", "黄山站" };
		cities.put("安徽", ahCities);

		String[] zjCities = new String[]
		{ "杭州", "宁波", "温州", "嘉兴", "湖州", "绍兴", "金华", "衢州", "舟山", "台州", "丽水" };
		cities.put("浙江", zjCities);

		String[] fjCities = new String[]
		{ "福州", "厦门", "莆田", "三明", "泉州", "漳州", "南平", "龙岩", "宁德" };
		cities.put("福建", fjCities);

	}
}
package mobi.cloudymail.calendar.data;

public class Provinces
{
	public static String[] provinces;
	static
	{

		provinces = new String[]
		{ "北京", "上海", "天津", "重庆", "黑龙江", "吉林", "辽宁", "山东", "山西", "陕西", "河北",
				"河南", "湖北", "湖南", "海南", "江苏", "江西", "广东", "广西", "云南", "贵州",
				"四川", "内蒙古", "宁夏", "甘肃", "青海", "西藏", "新疆", "安徽", "浙江", "福建",
				"香港"/*, "台湾"*/, "澳门" };
	}
}
package mobi.cloudymail.calendar;

import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.Calendar;

import org.apache.commons.lang3.time.DateUtils;

import mobi.cloudymail.mailclient.R;
import android.R.integer;
import android.app.Activity;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.Xfermode;
import android.net.Uri;
import android.os.Build;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.View;
import android.widget.TextView;
import mobi.cloudymail.util.MyApp;
import android.view.Display;

public class Grid extends CalendarParent implements Serializable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	private String[] days = new String[42];
	private String[] Chinesedays = new String[42];
	// true表示有记录，false表示没有记录
	private boolean[] recordDays = new boolean[42];
	private String[] monthNames = new String[12];
	private TextView tvMsg1;
//	private TextView tvMsg2;
//	private TextView tvMsg3;
	private int dayColor;
	private int innerGridColor;
	private int prevNextMonthDayColor;
	private int currentDayColor;
	private int todayColor;
	private int gregorianDayColor;
	private int todayBackgroundColor;
	private int sundaySaturdayPrevNextMonthDayColor;
	private int eventSymbolColor;
//	private float daySize;
//	private float dayTopOffset;
	private float currentDaySize;
	private float cellX = -1, cellY = -1;
	ChineseCalendarGB chineseCalendar=new ChineseCalendarGB();
	ChineseCalendarGB calendarGB=new ChineseCalendarGB();

	// 从0开始
	private int currentRow, currentCol;
	private boolean redrawForKeyDown = false;

	// 当前年和月
	public int currentYear, currentMonth;
	// 上月或下月选中的天
	public int currentDay = -1, currentDay1 = -1, currentDayIndex = -1;
	private java.util.Calendar calendar = java.util.Calendar.getInstance();

	private java.util.Calendar cal_begin = java.util.Calendar.getInstance();
	private java.util.Calendar cal_end = java.util.Calendar.getInstance();
	
	private static String calendarURIBase = "";
	
	static{
		if (Integer.parseInt(Build.VERSION.SDK) >= 8) {
			calendarURIBase = "content://com.android.calendar";
		} else {
			calendarURIBase = "content://calendar";
		}
	}
	
	public void setCurrentRow(int currentRow)
	{
		if (currentRow < 0)
		{
			currentMonth--;
			if (currentMonth == -1)
			{
				currentMonth = 11;
				currentYear--;
			}
			currentDay = getMonthDays(currentYear, currentMonth) + currentDay
					- 7;
			currentDay1 = currentDay;
			cellX = -1;
			cellX = -1;
			view.invalidate();
			return;

		}
		else if (currentRow > 5)
		{
			int n = 0;
			for (int i = 35; i < days.length; i++)
			{
				if (!days[i].startsWith("*"))
					n++;
				else
					break;
			}
			currentDay = 7 - n + currentCol + 1;
			currentDay1 = currentDay;
			currentMonth++;
			if (currentMonth == 12)
			{
				currentMonth = 0;
				currentYear++;
			}
			cellX = -1;
			cellX = -1;
			view.invalidate();
			return;
		}
		this.currentRow = currentRow;
		redrawForKeyDown = true;
		view.invalidate();
	}

	private void getRecordDays()
	{
		int beginDayIndex = 0;
		for (int i = 0; i < recordDays.length; i++)
			recordDays[i] = false;
		for (int i = 0; i < days.length; i++)
		{
			if (!days[i].startsWith("*"))
			{
		
				beginDayIndex = i;
				break;
			}
		}
		
		ContentResolver contentResolver = MyApp.instance().getContentResolver();
		Uri.Builder builderCurrent = Uri.parse(calendarURIBase + "/instances/when").buildUpon();
			
		cal_begin.set(currentYear, currentMonth, 1, 0, 0, 0);
		long begin = cal_begin.getTimeInMillis();
		ContentUris.appendId(builderCurrent, begin); // now -
														// DateUtils.DAY_IN_MILLIS
														// * 10000);

		cal_end.set(currentYear, currentMonth, getMonthDays(currentYear, currentMonth), 23, 59, 59);
		long end = cal_end.getTimeInMillis();
		ContentUris.appendId(builderCurrent, end);// now +
													// DateUtils.DAY_IN_MILLIS *
													// 10000);
		Cursor eventCursor = contentResolver
				.query(	builderCurrent.build(), new String[] { "event_id", "title", "dtstart",
																"dtend", "allDay", "duration" },
						null, null, "startDay ASC, startMinute ASC");

		java.util.Calendar temp = java.util.Calendar.getInstance();
		while (eventCursor.moveToNext())
		{
			Long beginTime = Long.valueOf(eventCursor.getString(2));
			temp.setTimeInMillis(beginTime);
			int begin_day = temp.get(Calendar.DAY_OF_MONTH);
			
			Long endTime = null;
			if (eventCursor.getString(3) == null)
			{
				String during = eventCursor.getString(5).substring(1, eventCursor.getString(5).length() - 2);
				endTime = Long.valueOf(during) * 1000 + beginTime;
			}
			else
			{
				endTime = Long.valueOf(eventCursor.getString(3));
			}
			if (eventCursor.getString(4).equals("1"))
			{
				endTime = endTime - DateUtils.MILLIS_PER_DAY;
			}
			temp.setTimeInMillis(endTime);
			int end_day = temp.get(Calendar.DAY_OF_MONTH);
			int end_hour = temp.get(Calendar.HOUR_OF_DAY);
			int end_min = temp.get(Calendar.MINUTE);
			if ((end_hour == 0) && (end_min == 0))
			{
				end_day--;
			}
			for (int day = begin_day; day <= end_day; day++)
			{
				recordDays[beginDayIndex + day - 1] = true;
			}
		}
		if (days[0].startsWith("*"))
		{
			int prevYear = currentYear, prevMonth = currentMonth - 1;
			if (prevMonth == -1)
			{
				prevMonth = 11;
				prevYear--;
			}
			int minDay = Integer.parseInt(days[0].substring(1));

			Uri.Builder builderPre = Uri.parse(calendarURIBase + "/instances/when").buildUpon();
			cal_begin.set(prevYear, prevMonth, minDay, 0, 0, 0);
			begin = cal_begin.getTimeInMillis();
			ContentUris.appendId(builderPre, begin); // now -
														// DateUtils.DAY_IN_MILLIS
														// * 10000);

			cal_end.set(prevYear, prevMonth, getMonthDays(prevYear, prevMonth), 23, 59, 59);
			end = cal_end.getTimeInMillis();
			ContentUris.appendId(builderPre, end);// now +
													// DateUtils.DAY_IN_MILLIS *
													// 10000);

			eventCursor = contentResolver.query(builderPre.build(), new String[] { "event_id",
																					"title",
																					"dtstart",
																					"dtend",
																					"allDay" },
												null, null, "startDay ASC, startMinute ASC");

			temp = java.util.Calendar.getInstance();
			while (eventCursor.moveToNext())
			{
				Long beginTime = Long.valueOf(eventCursor.getString(2));
				temp.setTimeInMillis(beginTime);
				int begin_day = temp.get(Calendar.DAY_OF_MONTH);

				Long endTime = Long.valueOf(eventCursor.getString(3));
				if (eventCursor.getString(4).equals("1"))
				{
					endTime = endTime - DateUtils.MILLIS_PER_DAY;
				}
				temp.setTimeInMillis(endTime);
				int end_day = temp.get(Calendar.DAY_OF_MONTH);

				for (int day = begin_day; day <= end_day; day++)
				{
					recordDays[day - minDay] = true;
				}
			}
			
		}
		
		if (days[days.length - 1].startsWith("*"))
		{
			int nextYear = currentYear, nextMonth = currentMonth + 1;
			if (nextMonth == 12)
			{
				nextMonth = 0;
				nextYear++;
			}
			
			int maxDay = Integer.parseInt(days[days.length - 1].substring(1));
		
			Uri.Builder builderNext = Uri.parse(calendarURIBase + "/instances/when").buildUpon();
			cal_begin.set(nextYear, nextMonth, 1, 0, 0, 0);
			begin = cal_begin.getTimeInMillis();
			ContentUris.appendId(builderNext, begin); // now -
														// DateUtils.DAY_IN_MILLIS
														// * 10000);

			cal_end.set(nextYear, nextMonth, maxDay, 23, 59, 59);
			end = cal_end.getTimeInMillis();
			ContentUris.appendId(builderNext, end);// now +
													// DateUtils.DAY_IN_MILLIS *
													// 10000);

			eventCursor = contentResolver.query(builderNext.build(), 
			                			               new String[] { "event_id", "title", "dtstart", "dtend", "allDay"}, null, 
			                			               null, "startDay ASC, startMinute ASC");  
		
			temp = java.util.Calendar.getInstance();
			while (eventCursor.moveToNext())
			{
				Long beginTime = Long.valueOf(eventCursor.getString(2));
				temp.setTimeInMillis(beginTime);
				int begin_day = temp.get(Calendar.DAY_OF_MONTH);
				
				Long endTime = Long.valueOf(eventCursor.getString(3));
				if (eventCursor.getString(4).equals("1"))
				{
					endTime = endTime - DateUtils.MILLIS_PER_DAY;
				}
				temp.setTimeInMillis(endTime);
				int end_day = temp.get(Calendar.DAY_OF_MONTH);

				for (int day = begin_day; day <= end_day; day++)
				{
					recordDays[days.length - (maxDay - day) - 1] = true;
				}
			}
		}
		eventCursor.close();
	}

	public void setCurrentCol(int currentCol)
	{
		if (currentCol < 0)
		{
			if (currentRow == 0)
			{

				currentMonth--;

				if (currentMonth == -1)
				{
					currentMonth = 11;
					currentYear--;
				}
				currentDay = getMonthDays(currentYear, currentMonth);
				currentDay1 = currentDay;
				cellX = -1;
				cellX = -1;
				view.invalidate();
				return;
			}

			else
			{
				currentCol = 6;
				setCurrentRow(--currentRow);

			}
		}
		else if (currentCol > 6)
		{
			currentCol = 0;
			setCurrentRow(++currentRow);

		}
		this.currentCol = currentCol;
		redrawForKeyDown = true;
		view.invalidate();
	}

	public int getCurrentRow()
	{
		return currentRow;
	}

	public int getCurrentCol()
	{
		return currentCol;
	}

	public void setCellX(float cellX)
	{

		this.cellX = cellX;
	}

	public void setCellY(float cellY)
	{

		this.cellY = cellY;
	}

	private int getMonthDays(int year, int month)
	{
		month++;
		switch (month)
		{
			case 1:
			case 3:
			case 5:
			case 7:
			case 8:
			case 10:
			case 12:
			{
				return 31;
			}
			case 4:
			case 6:
			case 9:
			case 11:
			{
				return 30;
			}
			case 2:
			{
				if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
					return 29;
				else
					return 28;
			}
		}
		return 0;
	}

	private void calculateDays()
	{
		calendar.set(currentYear, currentMonth, 1);

		int week = calendar.get(java.util.Calendar.DAY_OF_WEEK);
		int monthDays = 0;
		int prevMonthDays = 0;
		int year=0;
		int month=0;
		int year2=0;
		int month2=0;
		monthDays = getMonthDays(currentYear, currentMonth);
	
		if (currentMonth == 0)//一月
		{
			prevMonthDays = getMonthDays(currentYear - 1, 11);
			year=currentYear - 1;
			month=12;
		}
			
		else
		{
			prevMonthDays = getMonthDays(currentYear, currentMonth-1);
			year=currentYear;
			month=currentMonth;
		}
		if (currentMonth == 11)//12月
		{
//			nextMonthDays = getMonthDays(currentYear +1, 0);
			year2=currentYear + 1;
			month2=1;
		}
			
		else
		{
//			nextMonthDays = getMonthDays(currentYear, currentMonth);
			year2=currentYear;
			month2=currentMonth+2;
		}

		for (int i = week, day = prevMonthDays; i > 1; i--, day--)
		{
			days[i - 2] = "*" + String.valueOf(day);
			chineseCalendar.setGregorian(year, month, day);
		    chineseCalendar.computeChineseFields();
			Chinesedays[i-2]=chineseCalendar.getChineseMonth()+","+chineseCalendar.getChineseDate()+"";
		}
		for (int day = 1, i = week - 1; day <= monthDays; day++, i++)
		{
			days[i] = String.valueOf(day);
			chineseCalendar.setGregorian(currentYear, currentMonth+1, day);
		    chineseCalendar.computeChineseFields();
			Chinesedays[i]=chineseCalendar.getChineseMonth()+","+chineseCalendar.getChineseDate()+"";
			if (day == currentDay)
			{
				currentDayIndex = i;

			}
		}
		for (int i = week + monthDays - 1, day = 1; i < days.length; i++, day++)
		{
			days[i] = "*" + String.valueOf(day);
			
			chineseCalendar.setGregorian(year2, month2, day);
		    chineseCalendar.computeChineseFields();
			Chinesedays[i]=chineseCalendar.getChineseMonth()+","+chineseCalendar.getChineseDate()+"";
			
		}

	}

	public Grid(Activity activity, View view)
	{
		super(activity, view);

//		tvMsg1 = (TextView) activity.findViewById(R.id.tvMsg1);
//		tvMsg2 = (TextView) activity.findViewById(R.id.tvMsg2);
		dayColor = activity.getResources().getColor(R.color.day_color);
		todayColor = activity.getResources().getColor(R.color.today_color);
		gregorianDayColor=activity.getResources().getColor(R.color.gregorian_color);
		todayBackgroundColor = activity.getResources().getColor(
				R.color.today_background_color);
		innerGridColor = activity.getResources().getColor(
				R.color.inner_grid_color);
		prevNextMonthDayColor = activity.getResources().getColor(
				R.color.prev_next_month_day_color);
		currentDayColor = activity.getResources().getColor(
				R.color.current_day_color);
		sundaySaturdayPrevNextMonthDayColor = activity.getResources().getColor(
				R.color.sunday_saturday_prev_next_month_day_color);
		eventSymbolColor=activity.getResources().getColor(R.color.event_symbol_color);
	//	daySize = activity.getResources().getDimension(R.dimen.day_size);
	//	dayTopOffset = activity.getResources().getDimension(
	//			R.dimen.day_top_offset);
		currentDaySize = activity.getResources().getDimension(
				R.dimen.current_day_size);
		monthNames = activity.getResources().getStringArray(R.array.month_name);
		paint.setColor(activity.getResources().getColor(R.color.border_color));

		currentYear = calendar.get(java.util.Calendar.YEAR);
		currentMonth = calendar.get(java.util.Calendar.MONTH);
	}

	private boolean isCurrentDay(int dayIndex, int currentDayIndex,
			Rect cellRect)
	{
		boolean result = false;
		if (redrawForKeyDown == true)
		{
			result = dayIndex == (7 * ((currentRow > 0) ? currentRow : 0) + currentCol);
			if (result)
				redrawForKeyDown = false;

		}
		else if (cellX != -1 && cellY != -1)
		{
			if (cellX >= cellRect.left && cellX <= cellRect.right
					&& cellY >= cellRect.top && cellY <= cellRect.bottom)
			{
				result = true;
			}
			else
			{
				result = false;
			}
		}
		else
		{
			result = (dayIndex == currentDayIndex);

		}
		if (result)
		{
			if (currentRow > 0 && currentRow < 6)
			{
				currentDay1 = currentDay;

			}
			currentDayIndex = -1;
			cellX = -1;
			cellY = -1;

		}
		return result;
	}

	// 更新当前日期的信息
	private String updateMsg(boolean today)
	{
		String monthName = monthNames[currentMonth];
		String dateString = "";
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy年M月d日");
		java.util.Calendar calendar = java.util.Calendar.getInstance();
		calendar.set(currentYear, currentMonth, currentDay);

		dateString = sdf.format(calendar.getTime());
//		String lunarStr = "";


		monthName += "   本月第" + calendar.get(java.util.Calendar.WEEK_OF_MONTH)
				+ "周";
//		tvMsg1.setText(monthName);
		if (today)
			dateString += "(今天)";
		dateString += "   本年第" + calendar.get(java.util.Calendar.WEEK_OF_YEAR)
				+ "周";
//		tvMsg2.setText(dateString);
		return dateString;

	}

	public boolean inBoundary()
	{
		if (cellX < borderMargin
				|| cellX > (view.getMeasuredWidth() - borderMargin)
				|| cellY < top
				|| cellY > (view.getMeasuredHeight() - borderMargin))
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	float top, left;

	@Override
	public void draw(Canvas canvas)
	{
	    left = borderMargin*2;
//		top = borderMargin + weekNameSize+borderMargin*3;
	    top = borderMargin*(3/2)+dayTopOffset+daySize+gregorianDaySize+borderMargin*5;
		float calendarWidth = view.getMeasuredWidth() - left * 2;    
		float calendarHeight =6*(dayTopOffset+daySize+gregorianDaySize+borderMargin/2)+borderMargin/3;
		float cellWidth = calendarWidth / 7;   
		float cellHeight = calendarHeight / 6;   
		paint.setColor(innerGridColor);
		
		// 画日期
		calculateDays();
		
		java.util.Calendar calendar = java.util.Calendar.getInstance();
		int day = calendar.get(java.util.Calendar .DATE);
		int myYear = calendar.get(java.util.Calendar.YEAR);
		int myMonth = calendar.get(java.util.Calendar.MONTH);
		
		calendar.set(myYear,myMonth,1);
		int week = calendar.get(java.util.Calendar.DAY_OF_WEEK);
		int todayIndex = week + day - 2;
		boolean today = false;
		if (currentDayIndex == -1)
		{
			currentDayIndex = todayIndex;

		}
		boolean flag = false;
		try
		{
			getRecordDays();
		}
		catch (Exception e)
		{
			// TODO: handle exception
		}
		
		for (int i = 0; i < days.length; i++)
		{
			today = false;
			int row = i / 7;
			int col = i % 7;
			String text = String.valueOf(days[i]);
			if ((i % 7 == 0 || (i - 6) % 7 == 0) && text.startsWith("*"))
			{
				paint.setColor(sundaySaturdayPrevNextMonthDayColor);
			}
			else if (i % 7 == 0 || (i - 6) % 7 == 0)
			{
				paint.setColor(sundaySaturdayColor);
			}
			else if (text.startsWith("*"))
			{
				paint.setColor(prevNextMonthDayColor);
			}
			else
			{
				paint.setColor(dayColor);
			}
			text = text.startsWith("*") ? text.substring(1) : text;

			Rect dst = new Rect();
			dst.left = (int) (left + cellWidth * col);
			dst.top = (int) (top + cellHeight * row);
			dst.bottom = (int) (dst.top + cellHeight + 1);
			dst.right = (int) (dst.left + cellWidth + 1);
			String myText = text;
			
			paint.setTextSize(daySize);
			float textLeft = left + cellWidth * col
					+ (cellWidth - paint.measureText(myText)) / 2;
			float textTop = top + cellHeight * row
					+ (cellHeight - paint.getTextSize()) / 2 + dayTopOffset;
			if (myYear == currentYear && myMonth == currentMonth
					&& i == todayIndex)
			{
				today = true;
			}

			if (isCurrentDay(i, currentDayIndex, dst) && flag == false)
			{
				if (days[i].startsWith("*"))
				{
					// 下月
					if (i > 20)
					{
						currentMonth++;
						if (currentMonth == 12)
						{
							currentMonth = 0;
							currentYear++;
						}
						
						view.invalidate();

					}
					// 上月
					else
					{
						currentMonth--;
						if (currentMonth == -1)
						{
							currentMonth = 11;
							currentYear--;
						}
						view.invalidate();

					}
					currentDay = Integer.parseInt(text);
					currentDay1 = currentDay;
					cellX = -1;
					cellY = -1;
					break;

				}
				else
				{
					paint.setTextSize(currentDaySize);
					flag = true;
					Bitmap bitmap = BitmapFactory.decodeResource(activity
							.getResources(), R.drawable.day);
					Rect src = new Rect();
					src.left = 0;
					src.top = 0;
					src.right = bitmap.getWidth();
					src.bottom = bitmap.getHeight();
					canvas.drawBitmap(bitmap, src, dst, paint);
//					paint.setColor(currentDayColor);
					currentCol = col;
					currentRow = row;
					currentDay = Integer.parseInt(text);
					currentDay1 = currentDay;
			

				}
			}
//			paint.setTypeface(Typeface.SANS_SERIF);
			paint.setAntiAlias(true);
			canvas.drawText(myText, textLeft, textTop, paint);
			
		    paint.setColor(gregorianDayColor);
		    paint.setTextSize(gregorianDaySize);
		    String chineseDay=chineseCalendar.getGregorianReturnData(Chinesedays[i]);
		    float posX=left + cellWidth * col
					+ (cellWidth - paint.measureText(chineseDay)) / 2;
		   
			float posY = top+borderMargin*(3/2)+ cellHeight * row
					+ (cellHeight - paint.getTextSize()) / 2 + dayTopOffset;
			canvas.drawText(chineseDay,posX , posY, paint);
			if (recordDays[i])
			{
//				myText = "*" + myText;
		        Paint symbolPaint = new Paint();
		        symbolPaint.setColor(eventSymbolColor);
		        symbolPaint.setStyle(Paint.Style.FILL); 
		        Path path = new Path();
		        path.moveTo((float)(dst.left+cellWidth*4.0/5), (float)dst.top);
		        path.lineTo((float)dst.right-borderMargin/10,(float)(dst.top+(cellWidth*1.0/5)));
		        path.lineTo((float)dst.right-borderMargin/10,(float)dst.top);
		        path.close(); 
		        canvas.drawPath(path, symbolPaint); 
			}
			if(today)
			{
				Bitmap bitmap = BitmapFactory.decodeResource(activity
				                 							.getResources(), R.drawable.circule);
				Rect src = new Rect();
				src.left = 0;
				src.top = 0;
				src.right = bitmap.getWidth();
			    src.bottom = bitmap.getHeight();
				canvas.drawBitmap(bitmap, src, dst, paint);
//				Paint todayPaint=new Paint();
//				todayPaint.setTextSize(currentDaySize);
//				dst.left += 1;
//				dst.top += 1;
//				todayPaint.setColor(Color.RED);
//				todayPaint.setStyle(Paint.Style.STROKE); 
//				todayPaint.setAntiAlias(true);
//				todayPaint.setStrokeWidth(2.0f);
//				canvas.drawCircle(dst.left+cellWidth/2, dst.top+cellHeight/2, cellWidth/3, todayPaint);
			}
			

		}
		
				
		paint.reset();
		String tvMsgString=updateMsg(today);
		paint.setTextSize(daySize);
		paint.setAntiAlias(true);
		paint.setColor(activity.getResources().getColor(R.color.text_color));
		canvas.drawText(tvMsgString,(view.getMeasuredWidth()-paint.measureText(tvMsgString))/2, borderMargin*5, paint);
		
//		paint.setColor(activity.getResources().getColor(R.color.border_color));
//		canvas.drawLine(left, top, left + view.getMeasuredWidth()
//				- borderMargin * 2, top, paint);
//		// 画横线
//		for (int i = 1; i < 6; i++)
//		{
//			 canvas.drawLine(left, top + (cellHeight) * i, left +
//			 calendarWidth,
//			 top + (cellHeight) * i, paint);
//		   }
//			// 画竖线
//		    for (int i = 1; i < 7; i++)
//		   {
//			 canvas.drawLine(left + cellWidth * i, top, left + cellWidth * i,
//					 top+calendarHeight, paint);
//		   }
	}
	public String getNextYearMonth(int year,int month)
	{
			if (month == 11)
			{
				year=currentYear + 1;
				month=0;
			}
				
			else
			{
				month=month+1;
			}
		return year+","+month;
	}
	public String getPreYearMonth(int year,int month)
	{
		if (month == 0)
		{
			year=year - 1;
			month=11;
		}
			
		else
		{
			month=month-1;
		}
		return  year+","+month;
	}
}
package mobi.cloudymail.calendar.interfaces;

import android.graphics.Canvas;


public interface CalendarElement
{
    public void draw(Canvas canvas);
}
 package mobi.cloudymail.calendar;

import java.util.Date;

public class Remind
{
	public boolean shake = false;
	public boolean ring = false;
	public Date date;
	public String msg;
}
package mobi.cloudymail.calendar;

import android.R.integer;
import android.content.Context;
import android.content.Intent;
import android.graphics.Camera;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.os.Message;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.widget.Scroller;


/**
 * 
 * 仿Launcher中的WorkSapce，可以左右滑动切换屏幕的类
 * 
 * @author Yao.GUET
 * 
 *         blog: http://blog.csdn.net/Yao_GUET
 * 
 *         date: 2011-05-04
 */

public class ScrollLayout extends ViewGroup {
	// 当前的屏幕视图
	private int mCurScreen = 1;
	// 滑动的速度
	private static final int SNAP_VELOCITY = 600;

	private static final String TAG = "ScrollLayout";
	// 无事件的状态
	private static final int TOUCH_STATE_REST = 0;
	// 处于拖动的状态
	private static final int TOUCH_STATE_SCROLLING = 1;
	public static final String DRAW_PRE = "DRAW_PRE";
	public static final String DRAW_NEXT = "DRAW_NEXT";

	private Calendar_main mContext;

	private float mLastMotionX;
	// 用于滑动的类
	private Scroller mScroller;

	private int mTouchSlop;

	private int mTouchState = TOUCH_STATE_REST;
	// 用来跟踪触摸速度的类
	private VelocityTracker mVelocityTracker;

	private int mWidth;
	// 旋转的角度，可以进行修改来观察效果
//	private float angle = 90;

	public ScrollLayout(Context context, AttributeSet attrs) {

		this(context, attrs, 0);

	}

	// 在构造器中初始化
	public ScrollLayout(Context context, AttributeSet attrs, int defStyle) {

		super(context, attrs, defStyle);

		mContext = (Calendar_main)context;

		mScroller = new Scroller(context);

		mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();

	}

	@Override
	public void addView(View child) {

		super.addView(child);
	}

	@Override
	protected void attachViewToParent(View child, int index, LayoutParams params) {

		super.attachViewToParent(child, index, params);
	}

	@Override
	public void computeScroll() {

		if (mScroller.computeScrollOffset()) {
			scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
			postInvalidate();
		}

	}

	/*
	 * 当进行View滑动时，会导致当前的View无效，该函数的作用是对View进行重新绘制 调用drawScreen函数
	 */
	@Override
	protected void dispatchDraw(Canvas canvas) {
		// super.dispatchDraw(canvas);
		final long drawingTime = getDrawingTime();
		final int count = getChildCount();
		for (int i = 0; i < count; i++) {
			drawScreen(canvas, i, drawingTime);
		}
	}

	/*
	 * 处理循环 立体效果的实现函数 ,screen为哪一个子View
	 */
	public void drawScreen(Canvas canvas, int screen, long drawingTime) {
		// 得到当前子View的宽度
		final int width = getWidth();
		final int scrollWidth = screen * width;
		System.out.println("scrollWidth--->" + scrollWidth);
		final int scrollX = this.getScrollX();
		System.out.println("scrollX---->" + scrollX);
		// 偏移量不足的时候直接
		if (scrollWidth > scrollX + width || scrollWidth + width < scrollX) {
			return;
		}
		final View child = getChildAt(screen);
//		final int faceIndex = screen;
//		final float currentDegree = getScrollX() * (angle / getMeasuredWidth());
//		System.out.println("getMeasuredWidth---->" + getMeasuredWidth()
//				+ "getScrollX()----->" + getScrollX() + "currentDegree--->"
//				+ currentDegree);
//		final float faceDegree = currentDegree - faceIndex * angle;
//		System.out.println("faceDegree--->" + faceDegree);
//		if (faceDegree > 90 || faceDegree < -90) {
//			return;
//		}
		canvas.save();
		drawChild(canvas, child, drawingTime);
		canvas.restore();
	}

	/**
	 * @param screen
	 * 
	 */
	public void reDrawChildView(CalendarView view)
	{
		mContext.calendarView = (CalendarView)view;
		int curYear = mContext.calendarView.ce.grid.currentYear;
		int curMonth = mContext.calendarView.ce.grid.currentMonth;
		String nextYearMonth = mContext.calendarView.ce.grid.getNextYearMonth(curYear, curMonth);
		String preYearMonth = mContext.calendarView.ce.grid.getPreYearMonth(curYear, curMonth);
		String[] nYearMonth = nextYearMonth.split(",");
		String[] pYearMonth = preYearMonth.split(",");
		if (view == mContext.mFirstView)
		{
			mContext.mSecondView.ce.grid.currentYear = Integer.parseInt(nYearMonth[0]);
			mContext.mSecondView.ce.grid.currentMonth = Integer.parseInt(nYearMonth[1]);
			mContext.mSecondView.ce.grid.currentDay = 1;
			mContext.mThirdView.ce.grid.currentYear = Integer.parseInt(pYearMonth[0]);
			mContext.mThirdView.ce.grid.currentMonth = Integer.parseInt(pYearMonth[1]);
			mContext.mThirdView.ce.grid.currentDay = 1;
			mContext.mThirdView.postInvalidate();
			mContext.mSecondView.postInvalidate();

		}

		else if (view == mContext.mSecondView)
		{
			mContext.mThirdView.ce.grid.currentYear = Integer.parseInt(nYearMonth[0]);
			mContext.mThirdView.ce.grid.currentMonth = Integer.parseInt(nYearMonth[1]);
			mContext.mThirdView.ce.grid.currentDay = 1;
			mContext.mFirstView.ce.grid.currentYear = Integer.parseInt(pYearMonth[0]);
			mContext.mFirstView.ce.grid.currentMonth = Integer.parseInt(pYearMonth[1]);
			mContext.mFirstView.ce.grid.currentDay = 1;
			mContext.mFirstView.postInvalidate();
			mContext.mThirdView.postInvalidate();
		}

		else if (view == mContext.mThirdView)
		{
			mContext.mFirstView.ce.grid.currentYear = Integer.parseInt(nYearMonth[0]);
			mContext.mFirstView.ce.grid.currentMonth = Integer.parseInt(nYearMonth[1]);
			mContext.mFirstView.ce.grid.currentDay = 1;
			mContext.mSecondView.ce.grid.currentYear = Integer.parseInt(pYearMonth[0]);
			mContext.mSecondView.ce.grid.currentMonth = Integer.parseInt(pYearMonth[1]);
			mContext.mSecondView.ce.grid.currentDay = 1;
			mContext.mFirstView.postInvalidate();
			mContext.mSecondView.postInvalidate();
		}

	}

	@Override
	public void dispatchWindowFocusChanged(boolean hasFocus) {

		Log.d("Windows",
				"dispatchWindowFocusChanged -- >"
						+ getChildAt(mCurScreen).toString());
		super.dispatchWindowFocusChanged(hasFocus);
	}

	@Override
	public void dispatchWindowVisibilityChanged(int visibility) {
		Log.d("Windows",
				"dispatchWindowVisibilityChanged -- >"
						+ getChildAt(mCurScreen).toString());

		super.dispatchWindowVisibilityChanged(visibility);
	}

	public View getCurScreen() {

		return this.getChildAt(mCurScreen);

	}

	@Override
	protected void onAttachedToWindow() {

		Log.d("Windows", "onAttachedToWindow -- >"
				+ getChildAt(mCurScreen).toString());

		startCurrentView();
		super.onAttachedToWindow();
	}

	@Override
	protected void onDetachedFromWindow() {

		Log.d("Windows", "onDetachedFromWindow -- >"
				+ getChildAt(mCurScreen).toString());

		super.onDetachedFromWindow();
	}

	@Override
	public boolean onInterceptTouchEvent(MotionEvent ev) {

		Log.d(TAG, "onInterceptTouchEvent-slop:" + mTouchSlop);

		final int action = ev.getAction();
		if ((action == MotionEvent.ACTION_MOVE)
				&& (mTouchState != TOUCH_STATE_REST)) {
			return true;
		}
		final float x = ev.getX();
		switch (action) {
		case MotionEvent.ACTION_MOVE:
			final int xDiff = (int) Math.abs(mLastMotionX - x);
			if (xDiff > mTouchSlop) {
				mTouchState = TOUCH_STATE_SCROLLING;
			}
			break;

		case MotionEvent.ACTION_DOWN:
			mLastMotionX = x;
			mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST
					: TOUCH_STATE_SCROLLING;
			break;

		case MotionEvent.ACTION_CANCEL:

		case MotionEvent.ACTION_UP:
			mTouchState = TOUCH_STATE_REST;
			break;

		}

		return mTouchState != TOUCH_STATE_REST;

	}

	/*
	 * 
	 * 为子View指定位置
	 */
	@Override
	protected void onLayout(boolean changed, int l, int t, int r, int b) {

		int childLeft = 0;
		final int childCount = getChildCount();
		for (int i = 0; i < childCount; i++) {
			final View childView = getChildAt(i);
			if (childView.getVisibility() != View.GONE) {
				final int childWidth = childView.getMeasuredWidth();
				childView.layout(childLeft, 0, childLeft + childWidth,
						childView.getMeasuredHeight());
				childLeft += childWidth;
			}

		}
	}

	// 重写此方法用来计算高度和宽度
	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

		super.onMeasure(widthMeasureSpec, heightMeasureSpec);
		final int width = MeasureSpec.getSize(widthMeasureSpec);
		final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
		Log.e(TAG, "onMeasure width = " + width);
		// Exactly：width代表的是精确的尺寸
		// AT_MOST：width代表的是最大可获得的空间
		if (widthMode != MeasureSpec.EXACTLY) {
			throw new IllegalStateException(
					"ScrollLayout only canmCurScreen run at EXACTLY mode!");
		}

		final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
		if (heightMode != MeasureSpec.EXACTLY) {
			throw new IllegalStateException(
					"ScrollLayout only can run at EXACTLY mode!");
		}

		// The children are given the same width and height as the scrollLayout
		// 得到多少页(子View)并设置他们的宽和高
		final int count = getChildCount();
		for (int i = 0; i < count; i++) {
			getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);
		}

		// Log.e(TAG, "moving to screen "+mCurScreen);

		scrollTo(mCurScreen * width, 0);

	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {

		if (mVelocityTracker == null) {
			// 使用obtain方法得到VelocityTracker的一个对象
			mVelocityTracker = VelocityTracker.obtain();
		}
		// 将当前的触摸事件传递给VelocityTracker对象
		mVelocityTracker.addMovement(event);
		// 得到触摸事件的类型
		final int action = event.getAction();
		final float x = event.getX();

		switch (action) {
		case MotionEvent.ACTION_DOWN:
			Log.d(TAG, "event down!");
			if (!mScroller.isFinished()) {
				mScroller.abortAnimation();
			}
			mLastMotionX = x;
			break;

		case MotionEvent.ACTION_MOVE:

			int deltaX = (int) (mLastMotionX - x);

			mLastMotionX = x;

			scrollBy(deltaX, 0);

			break;

		case MotionEvent.ACTION_UP:

			// if (mTouchState == TOUCH_STATE_SCROLLING) {

			final VelocityTracker velocityTracker = mVelocityTracker;
			// 计算当前的速度
			velocityTracker.computeCurrentVelocity(1000);
			// 获得当前的速度
			int velocityX = (int) velocityTracker.getXVelocity();
			Log.d(TAG, "velocityX:" + velocityX + "; event : up");
			if (velocityX > SNAP_VELOCITY && mCurScreen > 0) {
				// Fling enough to move left
				Log.d(TAG, "snap left");
				snapToScreen(mCurScreen - 1);
			} else if (velocityX < -SNAP_VELOCITY
			&& mCurScreen < getChildCount() - 1) {
				// Fling enough to move right
				Log.d(TAG, "snap right");
				snapToScreen(mCurScreen + 1);
			} else {
				snapToDestination();
			}
			if (mVelocityTracker != null) {
				mVelocityTracker.recycle();
				mVelocityTracker = null;
			}
			mTouchState = TOUCH_STATE_REST;
			CalendarView view=(CalendarView)getCurScreen();
			reDrawChildView(view);
			break;
		case MotionEvent.ACTION_CANCEL:
			mTouchState = TOUCH_STATE_REST;
			
			break;
		}

		return true;

	}

	@Override
	public void onWindowFocusChanged(boolean hasWindowFocus) {

		Log.d("Windows", "onWindowFocusChanged -- >"
				+ getChildAt(mCurScreen).toString());

		super.onWindowFocusChanged(hasWindowFocus);
	}

	@Override
	protected void onWindowVisibilityChanged(int visibility) {

		Log.d("Windows",
				"onWindowVisibilityChanged -- >"
						+ getChildAt(mCurScreen).toString());

		super.onWindowVisibilityChanged(visibility);
	}

	@Override
	public void requestChildFocus(View child, View focused) {

		Log.d("requestChildFocus", "child = " + child);

		super.requestChildFocus(child, focused);
	}

	private void setMWidth() {
		if (mWidth == 0) {
			mWidth = getWidth();
		}
	}

	private void setNext() {
		int count = this.getChildCount();
		View view = getChildAt(count - 1);
		removeViewAt(count - 1);
		addView(view, 0);
	}

	private void setPre() {
		int count = this.getChildCount();
		View view = getChildAt(0);
		removeViewAt(0);
		addView(view, count - 1);
	}

	public void setToScreen(int whichScreen) {
		whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));
		scrollTo(whichScreen * mWidth, 0);
		if (whichScreen > mCurScreen) {
			setPre();
		} else if (whichScreen < mCurScreen) {
			setNext();
		}

	}

	/**
	 * 
	 * According to the position of current layout
	 * 
	 * scroll to the destination page.
	 */

	public void snapToDestination() {
		setMWidth();
		// 根据View的宽度以及滑动的值来判断是哪个View
		final int destScreen = (getScrollX() + mWidth / 2) / mWidth;
		snapToScreen(destScreen);

	}

	public void snapToScreen(int whichScreen) {
		// get the valid layout page
		whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));
		setMWidth();
		int scrollX = getScrollX();
		int startWidth = whichScreen * mWidth;

		if (scrollX != startWidth) {

			int delta = 0;
			int startX = 0;

			if (whichScreen > mCurScreen) {
				setPre();
				delta = startWidth - scrollX;
				startX = mWidth - startWidth + scrollX;

			} else if (whichScreen < mCurScreen) {
				setNext();
				delta = -scrollX;
				startX = scrollX + mWidth;
			} else {
				startX = scrollX;
				delta = startWidth - scrollX;

			}

			mScroller.startScroll(startX, 0, delta, 0, Math.abs(delta) * 2);

			invalidate(); // Redraw the layout

		}

		startCurrentView();

	}

	private void startCurrentView() {

		String viewTag = (String) getChildAt(mCurScreen).getTag();

		Message message = new Message();

		if (TextUtils.equals(viewTag, Calendar_main.FIRST_INTENT_TAG)) {
			message.what = Calendar_main.FIRST_VIEW;
		} else if (TextUtils.equals(viewTag, Calendar_main.SECOND_INTENT_TAG)) {
			message.what = Calendar_main.SECOND_VIEW;
		} else {
			message.what = Calendar_main.THIRD_VIEW;
		}

		mContext.mHandler.sendMessage(message);
	}

}
package mobi.cloudymail.calendar;

import mobi.cloudymail.mailclient.R;
import android.app.Activity;
import android.graphics.Canvas;
import android.view.View;

public class Week extends CalendarParent
{
	private String[] weekNames;
	private int weekNameColor;

	public Week(Activity activity, View view)
	{
		super(activity, view);
		weekNameColor = activity.getResources().getColor(R.color.weekname_color);
		weekNames = activity.getResources().getStringArray(R.array.week_name);
		paint.setTextSize(weekNameSize);
	}

	@Override
	public void draw(Canvas canvas)
	{

		float left = borderMargin;
		float top = borderMargin*3;
		float everyWeekWidth = (view.getMeasuredWidth() -  borderMargin * 2)/ 7;
	//	float everyWeekHeight = everyWeekWidth;
		
//		paint.setFakeBoldText(true);
		for (int i = 0; i < weekNames.length; i++)
		{
//			if(i == 0 || i == weekNames.length - 1)
//				paint.setColor(sundaySaturdayColor);
//			else
			paint.setColor(weekNameColor);

			left = borderMargin + everyWeekWidth * i
					+ (everyWeekWidth - paint.measureText(weekNames[i])) / 2;
			canvas.drawText(weekNames[i], left, top + paint.getTextSize()+weekNameMargin, paint);
		}

	}

}
/**
 * 
 */
package mobi.cloudymail.data;


/**
 * @author llm
 *
 */
public class FolderInfo
{
	public int accountId;
	public String folderName;
	public String displayName;
	public FolderInfo(int accountId, String folderName, String displayName)
	{
		super();
		this.accountId = accountId;
		this.folderName = folderName;
		this.displayName = displayName;
	}
	
	
}
package mobi.cloudymail.data;

import java.io.Serializable;

import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import android.database.Cursor;
public class InMailInfo extends MailInfo implements Serializable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 4941273778839405159L;

	public InMailInfo(Cursor cursor) //throws SQLException
	{
		super(cursor);
		setFrom(cursor.getString(cursor.getColumnIndex("from")));
		setUid(cursor.getString(cursor.getColumnIndex("uid")));
		setUidx(cursor.getInt(cursor.getColumnIndex("uidx")));
		setAttachmentFlag(cursor.getInt(cursor.getColumnIndex("hasAttach")));
	}
	
	public InMailInfo(int accountId, org.w3c.dom.Element xr) //throws SQLException
	{
		setSubject( xr.getAttribute("subject"));
		setTo( xr.getAttribute("to"));
		setCc( xr.getAttribute("cc"));
		try
		{
			String dateStr =  xr.getAttribute("date");
			setDate(Utils.netDateFormater.parse(dateStr));
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		setFolder( xr.getAttribute("foldername"));
		setAccountId(accountId);
		setState(Integer.parseInt( xr.getAttribute("state")));
		
		setFrom(xr.getAttribute("from"));
		setUid(xr.getAttribute("uid"));
		setUidx(Integer.parseInt(xr.getAttribute("uidx")));
		setAttachmentFlag(Integer.parseInt(xr.getAttribute("attachmentFlag")));
	}
	
	@Override
	public void addAttachInfo(AttachmentInfo attach) {
		int oldFlag = attachFlag;
		super.addAttachInfo(attach);
		if(oldFlag != attachFlag)
			NewDbHelper.getInstance().setMailAttachment(getUid(),getFolder(),attachFlag);
	}

	
	@Override
	public void setHasAttachment(boolean hasAttach,boolean updateDb)
	{
		if(hasAttach&&!hasAttachment())
		{
			_attachments.clear();
			attachFlag |= ATF_NORMAL_ATTACH;
//			_attachments.add(new AttachmentInfo(AttachmentInfo.ALL_REFATTACH_INDEX));
		}
		else if(!hasAttach){
			attachFlag &= ~ATF_NORMAL_ATTACH;
		}
		if (hasAttach == true && hasAttachment() == false)
		{
//			_attachments.clear();
//			_hasAttachment = true;
//			_attachments.add(new AttachmentInfo(AttachmentInfo.ALL_REFATTACH_INDEX));
			if(updateDb)
				NewDbHelper.getInstance().setMailAttachment(getUid(),getFolder(),attachFlag);
		}
		else if(hasAttach == false && hasAttachment() == true)
		{
			_attachments.clear();
//			_hasAttachment = false;
			if(updateDb)
				NewDbHelper.getInstance().setMailAttachment(getUid(),getFolder(),attachFlag);
		}
	}
}
package mobi.cloudymail.data;

import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import android.content.Context;
import android.database.Cursor;



	public class MailInfo implements Serializable
	{
		@Override
		public int hashCode()
		{
			final int prime = 31;
			int result = 1;
			result = prime * result + ((_folder == null) ? 0 : _folder.hashCode());
			result = prime * result + accountId;
			result = prime * result + ((uid == null) ? 0 : uid.hashCode());
			return result;
		}

		@Override
		public boolean equals(Object obj)
		{
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			MailInfo other = (MailInfo) obj;
			if (_folder == null)
			{
				if (other._folder != null)
					return false;
			}
			else if (!_folder.equals(other._folder))
				return false;
			if (accountId != other.accountId)
				return false;
			if (uid == null)
			{
				if (other.uid != null)
					return false;
			}
			else if (!uid.equals(other.uid))
				return false;
			return true;
		}

		private static final long serialVersionUID = 4941273778839405189L;
		private String subject="";
		private String from="";//------------------
		private String to="";
		private String cc="";
		private String uid="";//in OutMailInfo, it's the refId.
		private Date date;
		private int accountId;//belonged account's id.
		private String dateString; //date in string format
		private int state = MailStatus.MAIL_NEW;
		private int asterisk=0;
		protected int attachFlag = 0;
//		protected boolean _hasAttachment = false;
//		protected boolean _hasNormalAttachment = false;
//		protected boolean _hasCalendarAttachment = false;
		protected List<AttachmentInfo> _attachments = new ArrayList<AttachmentInfo>();
		private String _folder="";
		private int uidx=-1;
		private String body="";
		private int groupId=0;
		
//		private String suffix="";
		public static final int ATF_NO_ATTACH = 0;
		public static final int ATF_NORMAL_ATTACH = 1;
		public static final int ATF_CALENDAR_ATTACH = ATF_NORMAL_ATTACH << 1;

		public static final int REPLY=ATF_CALENDAR_ATTACH<<1;
		public static final int FORWARD=REPLY<<1;
		public MailInfo()
		{
			
		}
		
		public MailInfo(Cursor cursor) //throws SQLException
		{
			setSubject(cursor.getString(cursor.getColumnIndex("subject")));
//			setFrom(cursor.getString(cursor.getColumnIndex("from")));
			setTo(cursor.getString(cursor.getColumnIndex("to")));
			setCc(cursor.getString(cursor.getColumnIndex("cc")));
			setBody(cursor.getString(cursor.getColumnIndex("body")));
			setAsterisk(cursor.getInt(cursor.getColumnIndex("asterisk")));
			try
			{
				String dateStr = cursor.getString(cursor.getColumnIndex("date"));
				setDate(Utils.netDateFormater.parse(dateStr));
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
			setFolder(cursor.getString(cursor.getColumnIndex("folder")));
			setAccountId(cursor.getInt(cursor.getColumnIndex("accountId")));
			setState(cursor.getInt(cursor.getColumnIndex("state")));
		}

		public boolean hasNormalAttachment()
		{
			//return _hasNormalAttachment;
			return (attachFlag&ATF_NORMAL_ATTACH)>0;
		}
		
		public int getGroupId() {
			return groupId;
		}
		public boolean hasCalendarAttachment()
		{
			return (attachFlag&ATF_CALENDAR_ATTACH)>0;
		}

//		public String getSuffix() {
//			return suffix;
//		}

//		public void setSuffix(String suffix) {
//			this.suffix = suffix;
//		}

		public void setGroupId(int groupId) {
			this.groupId = groupId;
		}
		public boolean hasAttachment()
		{
			return hasNormalAttachment() || hasCalendarAttachment();
		}
		
		public int getAttachmentFlag()
		{
			return this.attachFlag;
		}
		
		public void setAttachmentFlag(int attachmentFlag)
		{
			this.attachFlag = attachmentFlag;
		}
		
		public void setHasAttachment(boolean hasAttach, boolean useDb)
		{
				this.attachFlag |= ATF_NORMAL_ATTACH;
			
		}
		
		public AttachmentInfo getAttachment(int index)
		{
			if(index < 0 || !hasAttachment() || _attachments.isEmpty() || index >= _attachments.size())
				return null;
			return _attachments.get(index);
		}

		public List<AttachmentInfo> getAttachments()
		{
			return _attachments;
		}
		
		public void setAttachments(List<AttachmentInfo> attaches)
		{
			_attachments = new ArrayList<AttachmentInfo>(attaches);
//			setHasAttachment( !attaches.isEmpty(), true);
		}
		


		//this property simply return attachments raw information, the difference with property attachments
		//is, if has not download attachments from server, and this mail has attachment, a special
		//AttachmentInfo will included in returned list, this special AttachmentInfo object has index -2
		public List<AttachmentInfo> getRawAttachments()
		{
			
			return _attachments;
			
		}

		public void setSubject(String subject)
		{
			this.subject = subject;
		}

		public String getSubject()
		{
			return subject;
		}

		public void setFrom(String from)
		{
			this.from = from;
		}

		public String getFrom()
		{
			return from;
		}

		public void setTo(String to)
		{
			this.to = to;
		}

		public String getTo()
		{
			return to;
		}

		public void setCc(String cc)
		{
			this.cc = cc;
		}

		public String getCc()
		{
			return cc;
		}

		public void setUid(String uid)
		{
			this.uid = uid;
		}

		public String getUid()
		{
			return uid;
		}
        
		public int getAsterisk()
		{
			return asterisk;
		}

		public void setAsterisk(int asterisk)
		{
			this.asterisk = asterisk;
		}

		public void setDate(Date date)
		{
			this.date = date;
		}

		public Date getDate()
		{
			return date;
		}

		public void setAccountId(int accountId)
		{
			this.accountId = accountId;
		}

		public int getAccountId()
		{
			return accountId;
		}

		public void setState(int state)
		{
			this.state = state;
		}

		public int getState()
		{
			return state;
		}

//		public void setDateString(String dateString)
//		{
//			this.dateString = dateString;
//		}

		public String getDateString()
		{
			if(dateString == null && date != null)
			{
				Date now = new Date();
			
				if (date.getYear() != now.getYear())
				{
					dateString = Utils.earlierFormat.format(date);
				}
				else
				{
					dateString = Utils.nearFormat.format(date);
				}
			}
			return dateString;
		}

		public void setFolder(String folder)
		{
			this._folder = folder;
		}

		public String getFolder()
		{
			return _folder;
		}

		public void setUidx(int uidx)
		{
			this.uidx = uidx;
		}

		public int getUidx()
		{
			return uidx;
		}
		
		public void setBody(String body)
		{
			this.body = body;
		}

		public String getBody()
		{
			return body;
		}

		public void addAttachInfo(AttachmentInfo attach) {
			_attachments.add(attach);
			if(attach.fileName.endsWith(".ics"))
				this.attachFlag |= ATF_CALENDAR_ATTACH;
			else {
				this.attachFlag |= ATF_NORMAL_ATTACH;
			}
		}


		public boolean hasReply()
		{
			// TODO Auto-generated method stub
			return (attachFlag & REPLY)!=0;
		}

		public boolean hasForward()
		{
			// TODO Auto-generated method stub
			return (attachFlag & FORWARD)!=0;
		}
        
	}
package mobi.cloudymail.data;

public interface MailStatus
{
	public static final int MAIL_NEW = 1;
	public static final int MAIL_READED = 2;
	public static final int MAIL_DELETED = 3;
	public static final int MAIL_DELETE_FOREVER = 4;
	public static final int MAIL_LOCAL_DELETED = 5;
	public static final int MAIL_INVALID_STATE = -1;
	public static final int FLAG_HAS_MORE_PLACEHOLD = 0x8000;
}
package mobi.cloudymail.data;

import java.io.File;
import java.io.Serializable;

import mobi.cloudymail.mailclient.AccountManager;
import mobi.cloudymail.mailclient.AttachmentViewer;
import mobi.cloudymail.mailclient.Composer;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.util.Utils;
import android.R.integer;
import android.database.Cursor;

public class OutMailInfo extends MailInfo implements Serializable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = 8385446331316177045L;
	public static final int REFMAIL_NO=0;
	public static final int REFMAIL_YES=1;
	public static final int REFMAIL_RESPOND_INLINE=2;
	private String bc="";
	private int mailType=Composer.COMPOSER_NEWMAIL;//new, reply, reply all, or forward.
	private int refBodyFlag=REFMAIL_NO;
	private String refFolder="";
	/**
	 * @return the refFolder
	 */
	public String getRefFolder()
	{
		return refFolder;
	}
	/**
	 * @param refFolder the refFolder to set
	 */
	public void setRefFolder(String refFolder)
	{
		this.refFolder = refFolder;
	}
	public OutMailInfo()
	{
		
	}
	//uidx is the column id, uid is the column refUid.
	public OutMailInfo(Cursor cursor)// throws SQLException
	{
		super(cursor);
		// TODO Auto-generated constructor stub
		Account a = AccountManager.getAccount(getAccountId());
		if(a != null)
			setFrom(a.name);
		setBc(cursor.getString(cursor.getColumnIndex("bc")));
		setUidx(cursor.getInt(cursor.getColumnIndex("ID")));
		setUid(cursor.getString(cursor.getColumnIndex("refUid")));
		setMailType(cursor.getInt(cursor.getColumnIndex("mailType")));
		setRefBodyFlag(cursor.getInt(cursor.getColumnIndex("refBody")));
		
		
		String attachFiles = cursor.getString(cursor.getColumnIndex("attachments"));
		if(attachFiles == null || attachFiles.equals(""))
		{
//			_hasAttachment = false;
//			_hasNormalAttachment = false;
//			_hasCalendarAttachment = false;
			_attachments.clear();
		}
		else
		{
			//The attachments in column attachments are saved as:
			//index:fileName:size for referenced mail's attachment index.
			//index:fullFilePath for local attachment.
			//each attachment is seperated by ";", attach:attach:attach
			String[] attStrList = attachFiles.split(";");
			for(String attaStr:attStrList)
			{
				String[] tmpList = attaStr.split(":");
				int attaIdx = Integer.parseInt(tmpList[0]);
				AttachmentInfo attaInfo;
				if(attaIdx < 0 )//local attachment
				{//index,fullFilePath
					if(tmpList.length < 2)
						continue;
					String fullFilePath = tmpList[1];
					File attFile = new File(fullFilePath);
					if (!attFile.exists())
						continue;
					attaInfo = new AttachmentInfo(this);
					attaInfo.fileName = attFile.getName();
					// Log.d(fileName,
					// "File.length()="+attFile.length()+"; FileInputStream.available():"+fi.available());
					attaInfo.size = Utils.getReadableSize(attFile.length());// fi.available());
					attaInfo.fullFilePath = fullFilePath;
					_attachments.add(attaInfo);
				}
				else //ref mail's attachment.
				{//index,fileName,size
					if(tmpList.length < 3)
						continue;
					attaInfo = new AttachmentInfo(this,attaIdx);
					attaInfo.fileName = tmpList[1];
					attaInfo.size = tmpList[2];
					_attachments.add(attaInfo);
				}		
				
				if(!hasNormalAttachment() || !hasCalendarAttachment()) 
				{
					boolean is_calendar_attach = attaInfo.fileName.endsWith(".ics");
					if(is_calendar_attach) 
					{
						attachFlag |=ATF_CALENDAR_ATTACH;
					} 
					else
					{
						attachFlag |= ATF_NORMAL_ATTACH;
					}
				}
				
			}
			
		}
	}

	public void setAttachmentFlag(int attachFlag)
	{
		this.attachFlag=attachFlag;
	}
	
	public void setBc(String bc)
	{
		this.bc = bc;
	}

	public String getBc()
	{
		return bc;
	}

	public void setMailType(int mailType)
	{
		this.mailType = mailType;
	}

	public int getMailType()
	{
		return mailType;
	}

	public void setRefBodyFlag(int refBodyFlag)
	{
		this.refBodyFlag = refBodyFlag;
	}

	public int getRefBodyFlag()
	{
		return refBodyFlag;
	}

}
package mobi.cloudymail.data;

import java.io.Serializable;

import mobi.cloudymail.mailclient.R;
import mobi.cloudymail.util.MyApp;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Resources;

public class UserSetting implements Serializable
{
	/**
	 * 
	 */
	private boolean loadFlag = false;
	private static final long serialVersionUID = 6622949657960384526L;
	public int currentAccountId = -1;
	
	public boolean showMultipage = false;
	public int countPerReception = 10;
	private String _signature;
	public String _serverAddText="cloudymail.mobi";
    public boolean muteEnabled=true;
    public String muteTimeValue="22:30-7:30-true";
    
	public String getMuteTimeValue()
	{
		return muteTimeValue;
	}
	public void setMuteTimeValue(String muteTimeValue)
	{
		this.muteTimeValue = muteTimeValue;
	}
	public String getSignature()
	{
		return _signature;
	}
	public void setSignatrue(String signatureStr)
	{
		_signature = signatureStr;
	}
	//settings for push mail.
	//frequency, the unit is minute, 0 for receive mail in real time,
	//-1 for disable push mail.
	private int _pushFrequency = 30;
	public void setPushFrequency(int minute)
	{
		_pushFrequency = minute; 
	}
	public int getPushFrequency()
	{
		return _pushFrequency;
	}
	public boolean _ledFlag = true;
	public boolean _vibrateFlag = false;
	public String _ringtone = "";
	
	
	
	public void loadSetting(Context ctx)
	{
		if(loadFlag)
			return;
		Resources res = ctx.getResources();
		_signature= "\n" + "\n" + "\n" + "-------------------->"
		+ "\n"
		+ res.getString(R.string.automatic_signature);
		MyApp.userSetting.setSignatrue(_signature);
		SharedPreferences pref = ctx.getSharedPreferences(MyApp.SHARED_SETTING, Context.MODE_WORLD_READABLE);
		
		if(pref != null)
		{
			
			_ledFlag = pref.getBoolean(res.getString(R.string.key_new_mail_led), _ledFlag);
			_vibrateFlag = pref.getBoolean(res.getString(R.string.key_new_mail_vibrate), _vibrateFlag);
//			showMultipage = pref.getBoolean(res.getString(R.string.key_multipage_mail), showMultipage);
			_ringtone = pref.getString(res.getString(R.string.key_new_mail_ringtone), _ringtone);
			_pushFrequency = Integer.parseInt(pref.getString(res.getString(R.string.key_sync_frequency), ""+_pushFrequency));
			_signature = pref.getString(res.getString(R.string.key_mail_signature), _signature);
			countPerReception = Integer.parseInt(pref.getString(res.getString(R.string.key_mail_number),""+countPerReception));
			_serverAddText = pref.getString(res.getString(R.string.key_server_address), _serverAddText);
			loadFlag = true;
			String storedString = pref.getString(res.getString(R.string.key_mute_time), muteTimeValue);
			String[] muteValue = storedString.split("-");
			muteEnabled=Boolean.parseBoolean(muteValue[2]);
			muteTimeValue = storedString;
		}
	}
}
package mobi.cloudymail.mailclient;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;

import android.app.Activity;
import android.content.Intent;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;

import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.util.DialogResult;
import mobi.cloudymail.util.DialogUtils;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.SimpleCrypto;
import mobi.cloudymail.util.Utils;

public class AccountManager 
{
	public final static String FirstAccount = "firstAccount";
	
	static interface AccountChangeListener
	{
		public void accountChanged();
	}
	
	private static final List<Account> accounts = new ArrayList<Account>();
	static {
		loadAccount();
	}
//	public ArrayList<AccountChangeListener> accountChangeListeners = new ArrayList<AccountChangeListener>(2);
	
	public static Account getAccount(String name)
	{
		for (Account a : accounts) 
		{
			if(a.name.equals(name))
				return a;
		}
		return null;
	}
    public static int getAccountIndex(Account a)
    {
    	int selectedIdx = accounts.indexOf(a);
		return selectedIdx;
    }
	
	
	public static Account getAccount(int accountId)
	{
		for (Account a : accounts) 
		{
			if(a.id == accountId)
				return a;
		}
		return null;
	}
	
	public static Account getByIndex(int index)
	{
		return accounts.get(index);
	}
	
	public static int getCount()
	{
		return accounts.size();
	}
    public AccountManager()
    {
    }    
 
    public static boolean isEmpty()
    {
    	return accounts.isEmpty();
    }
	private static String loadAccount()
	{
		SQLiteDatabase db = NewDbHelper.getInstance().getReadableDatabase();
		Cursor cursor = db.rawQuery("select * from account", null);
		accounts.clear();
		if (cursor == null)
			return "Cursor is null";
		if (cursor.moveToFirst())
		{
			do
			{
				Account a = new Account();

				int cIdx = cursor.getColumnIndex("ID");
				a.id = cursor.getInt(cIdx);

				cIdx = cursor.getColumnIndex("name");
				a.name = cursor.getString(cIdx);

				cIdx = cursor.getColumnIndex("loginName");
				a.loginName = cursor.getString(cIdx);

				cIdx = cursor.getColumnIndex("mailPort");
				a.setMailPort(cursor.getInt(cIdx));

				cIdx = cursor.getColumnIndex("mailServer");
				a.mailServer = cursor.getString(cIdx);

				cIdx = cursor.getColumnIndex("serverType");
				a.serverType = cursor.getString(cIdx);

				cIdx = cursor.getColumnIndex("smtpPort");
				a.smtpPort = cursor.getInt(cIdx);

				cIdx = cursor.getColumnIndex("smtpServer");
				a.smtpServer = cursor.getString(cIdx);

				cIdx = cursor.getColumnIndex("useSSL");
				a.useSSL = (cursor.getInt(cIdx) == 0 ? false : true);

			
				cIdx = cursor.getColumnIndex("password");
				//decryption
				String decryptPassword=null;
				try
				{
					decryptPassword = cursor.getString(cIdx);
					if(!Utils.isEmpty(decryptPassword))
						decryptPassword = SimpleCrypto.decrypt("&cloudyServices@cloudymail.mobi&",decryptPassword);
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
				a.password =decryptPassword;

				accounts.add(a);
			} while (cursor.moveToNext());
		}
		cursor.close();
		return "";
	}
	public static Account deleteAccount(int index)
	{
		Account toDel = AccountManager.accounts.remove(index);
		MyApp.removeAgent(toDel);
		NewDbHelper.getInstance().deleteAccount(toDel);
		return toDel;	}
	
	public static void addAccount(Account a)
	{
		NewDbHelper.getInstance().addAccount(a);
		AccountManager.accounts.add(a);
		PushManager.getInstance().restart();

		
	}
	public static void updateAccount(Account oldAccount, Account newAccount)
	{
		MyApp.removeAgent(oldAccount);
		NewDbHelper.getInstance().updateAccount(newAccount, oldAccount.name);
		AccountManager.accounts.set(accounts.indexOf(oldAccount), newAccount);
		MyApp.getAgent(newAccount).clearSessionId();  //检测到SessionId为空是重新登录，更新设置到服务器
		PushManager.getInstance().restart();
		
	}
	
	public static boolean checkAccountAndCreate(Activity cureentUI)
	{
		if (MyApp.currentAccount == null)
		{
			if (DialogUtils
					.showModalMsgBox(	cureentUI,
					                 	MyApp.instance().getString(R.string.no_account_and_ask_to_create),
					                 	MyApp.instance().getString(R.string.whether_setup_account),
										EnumSet.of(	DialogUtils.ButtonFlags.Yes,
													DialogUtils.ButtonFlags.No)) == DialogResult.YES)
			{
				Intent intent = new Intent(MyApp.getCurrentActivity(), mobi.cloudymail.mailclient.FolderActivity.class);
				intent.putExtra(AccountManager.FirstAccount, true);

				cureentUI.startActivityForResult(intent, R.layout.account_manager);
			}
			
			return false;
		}
		return true;
	}
	
	public static List<Account> getAccounts()
	{
		return accounts;
	}
}

package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.util.EnumSet;

import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.Result;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.util.DialogResult;
import mobi.cloudymail.util.DialogUtils;
import mobi.cloudymail.util.MessageBox;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import mobi.cloudymail.util.DialogUtils.ButtonFlags;

import org.apache.commons.lang.ArrayUtils;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.PasswordTransformationMethod;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.Spinner;
import android.widget.TabHost.OnTabChangeListener;
import android.widget.TextView;
import android.widget.Toast;
import com.umeng.analytics.MobclickAgent;
public class AccountWizard extends BaseActivity implements OnClickListener, OnTabChangeListener 
{
	public static final int ACTRST_CHECKNEWMAIL = RESULT_FIRST_USER;
	public static final int ACTRST_NORMAL = RESULT_OK;
	
	//awk   '{print "{\"" $1 "\",\t\"" $2  "\",\t\"" $3  "\",\t\"" $4  "\",\t\"" $5 "\",\t\"" $6  "\",\t\"" $7   "\",\t\"" $8 "\"}," }'  /d/work/workspace/MailProxy/knownServer.csv
	static final String[][] knownHostsString = new String[][]
	     //name,	loginName,	mailServer,	smtpServer,	serverType,	smtpPort,useSSL,	mailPort
	    { 
		//{"domainName",  "loginName",    "mailServer",   "smtpServer",   "serverType",   "smtpPort",     "useSSL",       "mailPort" ,"promptForPOPIMAP"},
		{"126.com",     "$USER",        "imap.126.com", "smtp.126.com", "imap", "465",   "true",        "993" ,"false"},
		{"139.com",     "$USER",        "pop.139.com",  "smtp.139.com", "pop3", "25",   "false",        "110" ,"false"},
		//{"139.com",     "$USER",        "imap.139.com",  "smtp.139.com", "imap", "25",   "false",        "143"},
		{"163.com",     "$USER",        "imap.163.com",  "smtp.163.com", "imap", "465",   "true",        "993" ,"false"},
		{"yeah.net",     "$USER",        "imap.yeah.net",  "smtp.yeah.net", "imap", "465",   "true",        "993","false"},
		{"188.com",     "$USER",        "pop.188.com",  "smtp.188.com", "pop3", "25",   "false",        "110","false"},
		{"21cn.com",    "$USER",        "pop.21cn.com", "smtp.21cn.com",        "pop3", "25",   "false",       "110","false"},
		{"21cn.net",    "$USER",        "pop.21cn.net", "smtp.21cn.net",        "pop3", "25",   "false",       "110","false"},
		{"263.net",     "$USER",        "263.net",      "smtp.263.net", "pop3", "25",   "false",        "110","false"},
		{"263.net.cn",  "$USER",        "263.net.cn",   "263.net.cn",   "pop3", "25",   "false",        "110","false"},
		{"263xmail.com", "$USER",        "pop.263xmail.com",     "smtp.263xmail.com",    "pop3", "25",  "false", "110","false"},
		{"agatelogic.com",      "$USER@agatelogic.com", "imap.gmail.com",       "smtp.gmail.com",       "imap","465",   "true", "993","false"},
		{"cloudymail.mobi",      "$USER@cloudymail.mobi", "imap.gmail.com",       "smtp.gmail.com",       "imap","465",   "true", "993","false"},
		{"china.com",   "$USER@china.com",      "pop.china.com",        "smtp.china.com",       "pop3", "25",  "false", "110","false"},
		{"ee.buaa.edu.cn",      "$USER@ee.buaa.edu.cn", "pop3.buaa.edu.cn",     "smtp.buaa.edu.cn",     "pop3","25",    "false",        "110","false"},
		{"eyou.com",    "$USER@eyou.com",       "pop3.eyou.com",        "mx.eyou.com",  "pop3", "25",   "false","110","false"},
		{"foxmail.com", "$USER@foxmail.com",    "imap.qq.com",   "smtp.qq.com",  "imap", "465",   "true",       "993","true"},
		{"gmail.com",   "$USER@gmail.com",      "imap.gmail.com",       "smtp.gmail.com",       "imap", "465", "true",  "993","false"},
		{"hotmail.com", "$USER@hotmail.com",    "pop3.live.com",        "smtp.live.com",        "pop3", "587", "true",  "995","false"},
		{"msn.com", "$USER@msn.com",    "pop3.live.com",        "smtp.live.com",        "pop3", "587", "true",  "995","false"},
		{"netease.com", "$USER",        "pop.netease.com",      "smtp.netease.com",     "pop3", "25",   "false","110","false"},


		{"qq.com",      "$USER",        "imap.qq.com",   "smtp.qq.com",  "imap", "465",   "true",        "993","true"}, //IMAP with SSL, works well
		{"vip.qq.com",  "$USER@vip.qq.com",        "imap.qq.com",   "smtp.qq.com",  "imap", "465",   "true",        "993","true"}, //IMAP with SSL, works well
		{"sina.cn",     "$USER",        "pop.sina.com", "smtp.sina.com",        "pop3", "25",   "false",       "110","true"},
		{"sina.com",    "$USER",        "pop.sina.com", "smtp.sina.com",        "pop3", "25",   "false",       "110","true"},
		{"sohu.com",    "$USER",        "pop3.sohu.com",        "smtp.sohu.com",        "pop3", "25",   "false","110","false"},
		{"tom.com",     "$USER",        "pop.tom.com",  		"smtp.tom.com", "pop3", "25",   "false",        "110","false"},
		{"vip.163.com", "$USER",        "imap.vip.163.com",		"smtp.vip.163.com",     "imap", "465",   "true","993","false"},
		{"vip.126.com", "$USER",        "imap.vip.126.com", 	"smtp.vip.126.com",     "imap", "465",   "true","993","false"},
		{"188.com", 	"$USER",        "imap.188.com",     	"smtp.188.com",     "imap", "465",   "true","993","false"},
    	{"vip.sina.cn", "$USER",        "pop3.vip.sina.com",    "smtp.vip.sina.com",    "pop3", "25",   "false","110","true"},
		{"vip.sohu.com",        "$USER",        "pop3.vip.sohu.com",    "smtp.vip.sohu.com",    "pop3", "25",  "false", "110","false"},
		{"x263.net",    "$USER",        "pop.x263.net", "smtp.x263.net",        "pop3", "25",   "false",       "110","false"},
		{"yahoo.cn",    "$USER@yahoo.cn",       "imap.mail.yahoo.cn",    "smtp.mail.yahoo.cn",   "imap", "465", "true",  "993","true"},
		{"yahoo.com",   "$USER@yahoo.com",      "imap.mail.yahoo.com",  "smtp.mail.yahoo.com",  "imap", "465", "true",  "993","true"},
		{"yahoo.com.cn",        "$USER@yahoo.com.cn",   "imap.mail.yahoo.com.cn",        "smtp.mail.yahoo.cn",  "imap",  "465",  "true", "993","true"},
		{"yeah.net",    "$USER",        "pop.yeah.net", "smtp.yeah.net",        "pop3", "25",   "false",       "110","false"},
		{"cloudymail.mobi",      "$USER@cloudymail.mobi", "imap.gmail.com",       "smtp.gmail.com",       "imap","465",   "true", "993","false"},
		{"wo.com.cn",     "$USER",        "pop.wo.com.cn",      "smtp.wo.com.cn", "pop3", "25",   "false",        "110","false"},
		{"189.cn",     "$USER",        "pop.189.cn",  "smtp.189.cn", "pop3", "25",   "false",        "110","false"},
		{"hichina.com",    "$USER@hichina.com",        "pop3.hichina.com",        "smtp.hichina.com",        "pop3", "25",   "false","110","false"},

	     };
	static final Account[] knownHosts =new Account[knownHostsString.length];
	
	static {
		for(int i=0; i<knownHostsString.length; i++)
		{
			Account a = new Account();
			a.name = knownHostsString[i][0];
			a.loginName = knownHostsString[i][1];
			a.mailServer = knownHostsString[i][2];
			a.smtpServer = knownHostsString[i][3];
			a.serverType = knownHostsString[i][4];
			a.smtpPort = Integer.parseInt(knownHostsString[i][5]);
			a.useSSL = Boolean.parseBoolean(knownHostsString[i][6]);
			a.setMailPort(Integer.parseInt(knownHostsString[i][7]));
		}
	}
	
	private Account account = null;
	private boolean isNew = true;
	private Spinner serverTypeCmb = null;
	//private EditText accountNameTxt = null;
	private EditText mailboxTxt = null;
	private EditText passwordTxt = null;
	private EditText loginNameTxt = null;
	private EditText mailPortTxt = null;
	private TextView mailPortLabel = null;
	private EditText smtpPortTxt = null;
	private EditText mailServerTxt = null;
	private TextView mailServerLabel = null;
	private EditText smtpServerTxt = null;
	private CheckBox useSSLChk = null;
	private Button finishBtn = null;
	private String serverType="";
	private LinearLayout advanceLayout=null;
	private LinearLayout settingLayout=null;
    
	@Override
	protected void onResume ()
	{
		super.onResume();
		MyApp.setCurrentActivity(this);
		MobclickAgent.onResume(this);
	}
	
	
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		Window win = getWindow();
		win.requestFeature(Window.FEATURE_LEFT_ICON);
		setContentView(R.layout.account_wizard);
		win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
	
		findViewById(R.id.finishBtn).setOnClickListener(this);
		findViewById(R.id.cancelBtn).setOnClickListener(this);
		findViewById(R.id.advancedBtn).setOnClickListener(this);
		findViewById(R.id.lastBtn).setOnClickListener(this);
		findViewById(R.id.nextBtn).setOnClickListener(this);
		
		Intent intent = getIntent();
		account = (Account) intent.getSerializableExtra("account");
		isNew = intent.getBooleanExtra("isNew", true);
		serverTypeCmb = (Spinner) findViewById(R.id.serverTypeCmb);
		//accountNameTxt = (EditText) findViewById(R.id.accountNameTxt);
		passwordTxt = (EditText) findViewById(R.id.passwordTxt);
		passwordTxt.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View arg0)
			{
				arg0.requestFocus();
				
			}
		});
		mailboxTxt = (EditText) findViewById(R.id.mailboxTxt);
		loginNameTxt = (EditText) findViewById(R.id.loginNameTxt);
		mailPortTxt = (EditText) findViewById(R.id.mailPortTxt);
		smtpPortTxt = (EditText) findViewById(R.id.smtpPortTxt);
		mailServerTxt = (EditText) findViewById(R.id.mailServerTxt);
		smtpServerTxt = (EditText) findViewById(R.id.smtpServerTxt);
		mailServerTxt.addTextChangedListener(new  TextWatcher() {
			
			

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count)
			{
			}
			
			@Override
			public void beforeTextChanged(CharSequence s, int start, int count,int after)
			{
				// TODO Auto-generated method stub
			}
			
			@Override
			public void afterTextChanged(Editable s)
			{
				// TODO Auto-generated method stub
				String str = s.toString();
				if(str.endsWith("."))
				{
					String server = str.substring(0,str.indexOf('.'));
					Log.d(LOGTAG, server);
					if("pop3".equalsIgnoreCase(server))
						serverTypeCmb.setSelection(0);
					else if("imap".equalsIgnoreCase(server))
						serverTypeCmb.setSelection(1);
				}
			}
		});
		useSSLChk = (CheckBox) findViewById(R.id.useSSLChk);
		finishBtn = (Button) findViewById(R.id.finishBtn);
		mailPortLabel = (TextView) findViewById(R.id.mailPortLbl);
		mailServerLabel = (TextView) findViewById(R.id.mailServerLbl);
	    
		serverTypeCmb.setOnItemSelectedListener(new ServerTypeSelectedListener());
		
		advanceLayout = (LinearLayout)findViewById(R.id.advancedSettingLayout);
		settingLayout = (LinearLayout)findViewById(R.id.accountSettingLayout);
		
		
		initWidgetFromAccount();

		findViewById(R.id.showPasswordChk).setOnClickListener(new android.view.View.OnClickListener() 
		{
			@Override
			public void onClick(View paramView)
			{
				if(((CheckBox)paramView).isChecked())
				{
					passwordTxt.setTransformationMethod(null);
				}
				else
					passwordTxt.setTransformationMethod(PasswordTransformationMethod.getInstance());
			}
		});
	    
	}
	
	private void initWidgetFromAccount()
	{
		if(account == null)
		{
			account=MyApp.currentAccount;
			return;
		}
	    serverTypeCmb.setSelection(ArrayUtils.indexOf(getResources().getStringArray(R.array.serverType), account.serverType));
	 
	    if(account.isValid())
	    {
	    	advanceLayout.setVisibility(View.VISIBLE);
			settingLayout.setVisibility(View.GONE);
	    }
	    else
	    {
	    	advanceLayout.setVisibility(View.GONE);
	    	settingLayout.setVisibility(View.VISIBLE);
	    	account.setDefault();
	    }
	    mailboxTxt.setText(account.name);
	    passwordTxt.setText(account.password);
	    loginNameTxt.setText(account.loginName);
	    mailPortTxt.setText(account.getMailPort()+"");
	    smtpPortTxt.setText(account.smtpPort+"");
	    mailServerTxt.setText(account.mailServer);
	    smtpServerTxt.setText(account.smtpServer);
	    useSSLChk.setChecked(account.useSSL);
	    serverType = account.serverType;   
	}
	
	private void setAccountFromWidget()
	{
		account.name = mailboxTxt.getText().toString();
		account.password = passwordTxt.getText().toString();
		account.loginName = loginNameTxt.getText().toString();
		account.setMailPort(Integer.valueOf(mailPortTxt.getText().toString()));
		account.serverType = serverType;
		account.smtpPort = Integer.valueOf(smtpPortTxt.getText().toString());
		account.smtpServer = smtpServerTxt.getText().toString();
		account.mailServer = mailServerTxt.getText().toString();
		account.useSSL = useSSLChk.isChecked();
	}
	
	private Account isKnownServer(String name,String password)
	{
		int atPos = name.indexOf('@');
		String host = name.substring(atPos + 1).toLowerCase();
		String loginName = name.substring(0,atPos);
		for(int i=0; i<knownHostsString.length; i++)
		{
			if (knownHostsString[i][0].equals(host))
			{
				Account a = new Account();
				a.name = name;
				a.loginName = knownHostsString[i][1];
				a.loginName = a.loginName.replace("$USER", loginName);
				a.mailServer = knownHostsString[i][2];
				a.smtpServer = knownHostsString[i][3];
				a.serverType = knownHostsString[i][4];
				a.smtpPort = Integer.parseInt(knownHostsString[i][5]);
				a.useSSL = Boolean.parseBoolean(knownHostsString[i][6]);
				a.setMailPort(Integer.parseInt(knownHostsString[i][7]));
				a.promptForPOPIMAP=Boolean.parseBoolean(knownHostsString[i][8]);
				return a;
			}
		}
		Result result = null;
		try
		{
			result = ServerAgent.doHttpPost( ServerAgent.getLoginUrlBase()
					                          + "/GetMailConfig",
					                         java.net.URLEncoder.encode(name),java.net.URLEncoder.encode(password), 
					                          this,getResources().getString(R.string.search_mail_config));
			if (result != null && result.isSuccessed())
			{
				Element e = null;
				Element contents = result.xmlReader;
				NodeList nl = contents.getElementsByTagName("account");
				
				e = (Element)nl.item(0);//返回content只有一个的情况
				Account a = new Account();
				a.name = name;
				a.loginName = e.getAttribute("loginName");
				a.loginName = a.loginName.replace("$USER", loginName);
				a.mailServer = e.getAttribute("mailServer");
				a.smtpServer = e.getAttribute("smtpServer");
				a.serverType = e.getAttribute("serverType");
				a.smtpPort = Integer.parseInt(e.getAttribute("smtpPort"));
				a.setMailPort(Integer.parseInt(e.getAttribute("mailPort")));
				a.useSSL = Boolean.parseBoolean(e.getAttribute("useSSL"));
				
				return a;	
			}
			else
			{
				Toast.makeText(this,getResources().getString(R.string.fail_to_get_mail_config),Toast.LENGTH_LONG).show();
			}
			return null;
		}
		catch (Exception ex)
		{			
			ex.printStackTrace();
			return null;
		}
		finally
		{
			Log.v(LOGTAG, "something is wrong");
		}
	}
	
	public void onClick(View v)
	{
		View pageView1 = findViewById(R.id.pageView1);
		View pageView2 = findViewById(R.id.pageView2);
		if(v.getId() == R.id.cancelBtn)
		{
			try
			{
				setResult(RESULT_CANCELED);
		        finish();
			}
			catch (Exception e)
			{
				this.finish();
			}
		}
		else if(v.getId() == R.id.nextBtn)  //next button is pressed
		{
			
			String addressStr = mailboxTxt.getText().toString();
			String password = passwordTxt.getText().toString();
			Resources res = this.getResources();
			if (isMailAddressValid(addressStr, this)) {
				if (password.equals("")) {
					DialogUtils.showMsgBox(this,res.getString(R.string.err_emptyPassword),res.getString(R.string.error));
					passwordTxt.requestFocus();
					return;
				}
				// if the account name changed, then should check whether the
				// host changed.
				int atPos = addressStr.indexOf('@');
				String host = addressStr.substring(atPos + 1).toLowerCase();
				if (!host.equals(account.getHostName()))
				{
					Account tmpAccount = isKnownServer(addressStr, password);
					if (tmpAccount != null)
					{
						account = tmpAccount;
						account.password = passwordTxt.getText().toString();
					} else
					{
						// update account
						account.clear();
						account.name = mailboxTxt.getText().toString();
						account.password = passwordTxt.getText().toString();
					}
					initWidgetFromAccount();
				} else if (!addressStr.equals(account.name))
				{
					String userName = addressStr.substring(0, atPos);

					if (!Utils.isEmpty(account.loginName))
                       {
						int atIndex = account.loginName.indexOf('@');
						if (atIndex < 0) {
							account.loginName = userName;
						} else {
							/* Replace @ the string before */
							account.loginName = userName
									+ account.loginName.substring(atIndex);
						}
						account.name = mailboxTxt.getText().toString();
						loginNameTxt.setText(account.loginName);
					}
				}
				
				pageView1.setVisibility(View.GONE);
				pageView2.setVisibility(View.VISIBLE);
			}
		}
			
			else if (v.getId() == R.id.advancedBtn) // 高级
			{
				advanceLayout.setVisibility(View.GONE);
				settingLayout.setVisibility(View.VISIBLE);
			}
			else if (v.getId() == R.id.lastBtn)
			  {
				pageView1.setVisibility(View.VISIBLE);
				pageView2.setVisibility(View.GONE);
			  }
			else if (v.getId() == R.id.finishBtn)
			   {
				if (isAccountSettingValid()) {
					if (serverType != null&& !serverType.equals(account.serverType))
					{
						EnumSet<ButtonFlags> buttons = EnumSet.noneOf(ButtonFlags.class);
						buttons.add(ButtonFlags.Yes);
						buttons.add(ButtonFlags.No);
						int checkFlag = DialogUtils.showModalMsgBox(this,getResources().getString(R.string.accountWizard_Warn),getResources().getString(R.string.warning),buttons);
						if (checkFlag == DialogResult.NO)
						{
							return;
						} else 
						{
							NewDbHelper.getInstance().deleteAccountInfo(account);
						}
					}

					setAccountFromWidget();

					if (account.isPromptForPOPIMAP())
					{
						MessageBox.show(this, getString(R.string.PromptForPOPIMAP), getString(R.string.PromptAccountSetting));
					}
					/**/
					getIntent().putExtra("account", account);
					if(isNew && DialogUtils.showModalMsgBox(this,
										                 	getResources().getString(R.string.whether_syncup_mail_immediately),
										                 	getResources().getString(R.string.whether_syncup_mail_immediately_title),
															EnumSet.of(	DialogUtils.ButtonFlags.Yes, DialogUtils.ButtonFlags.No)) == DialogResult.YES)
					{
						setResult(ACTRST_CHECKNEWMAIL, getIntent());
					} else
						setResult(ACTRST_NORMAL, getIntent());
					finish();
				}
			}
		}
	

	@Override
	public void onTabChanged(String tabId)
	{
		if(tabId.equals("page1"))
		{
			finishBtn.setText(R.string.next);
		}
		else if(tabId.equals("page2"))
		{
			//if(!isMailAddressValid(accountNameTxt.getText().toString(),this))
			if(!isMailAddressValid(mailboxTxt.getText().toString(),this))
			{
//				getTabHost().setCurrentTab(0);
				return;
			}
			finishBtn.setText(R.string.finish);
		}
	}
	
	static public boolean isMailAddressValid(String name, Context ctx)
	{
		Resources res = ctx.getResources();
		String errMsg="";
		if(name.equals(""))
			errMsg = res.getString(R.string.err_emptyAddress);
		else
		{
			int flagIdx = name.indexOf("@");
			if(flagIdx == -1)
				errMsg = res.getString(R.string.err_invalidAddress);
		}
		if(!errMsg.equals(""))
		{
			DialogUtils.showMsgBox(ctx,errMsg, res.getString(R.string.error));
			return false;
		}
		else
			return true;
	}
	
	private boolean isAccountSettingValid()
	{
		Resources res = getResources();
		String err = res.getString(R.string.error);
		String loginName = this.loginNameTxt.getText().toString();
		if(loginName.equals(""))
		{
			DialogUtils.showMsgBox(this, res.getString(R.string.err_invalidLoginName), err);
			return false;
		}
		String serverAddress = this.mailServerTxt.getText().toString();
		if(serverAddress.equals(""))
		{
			DialogUtils.showMsgBox(this,res.getString(R.string.err_invalidServerAddress),err);
			return false;
		}
		boolean succeedFlag = true;
		try
		{
			int serverPort = Integer.valueOf(this.mailPortTxt.getText().toString());
			succeedFlag = Account.isPortValid(serverPort);
		}catch(NumberFormatException except)
		{
			succeedFlag = false;
		}finally
		{
			if(!succeedFlag)
			{
				DialogUtils.showMsgBox(this, res.getString(R.string.err_invalidServerPort), err);
				return false;
			}
		}
		String smtpServer = this.smtpServerTxt.getText().toString();
		if(smtpServer.equals(""))
		{
			DialogUtils.showMsgBox(this, res.getString(R.string.err_invalidSmtpServer), err);
			return false;
		}
		try
		{
			int smtpPort = Integer.valueOf(this.smtpPortTxt.getText().toString());
			succeedFlag = Account.isPortValid(smtpPort);
		}catch(NumberFormatException except)
		{
			succeedFlag = false;
		}finally
		{
			if(!succeedFlag)
			{
				DialogUtils.showMsgBox(this, res.getString(R.string.err_invalidSmtpPort), err);
				return false;
			}
		}
		return true;
	}
	
	
	 class ServerTypeSelectedListener implements OnItemSelectedListener
	 {  
		 @Override
	        public void onItemSelected(AdapterView<?> parent, View view, int position, long id)
	        {  
			 	Resources res = getResources();
	        	serverType = res.getStringArray(R.array.serverType)[position];
	        	if(serverType.equals(res.getString(R.string.pop3)))
	    	    {
	    	    	mailServerLabel.setText(res.getString(R.string.pop3Server));
	    	    	mailPortLabel.setText(res.getString(R.string.pop3Port));
	    	    }
	    	    else
	    	    {
	    	    	mailServerLabel.setText(res.getString(R.string.imapServer));
	    	    	mailPortLabel.setText(res.getString(R.string.imapPort));
	    	    }
	        	
	        } 
		 
		 @Override
		 public void onNothingSelected(AdapterView<?> parent)
		 {
			 
		 }
	 }
	
	 
}


package mobi.cloudymail.mailclient;

import java.util.ArrayList;
import java.util.regex.Pattern;

import mobi.cloudymail.util.DialogUtils;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import android.R.integer;
import android.app.Dialog;
import android.content.ContentResolver;
import android.provider.ContactsContract;
import android.provider.ContactsContract.CommonDataKinds;
import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Color;
import android.net.Uri;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.TextView;


interface OnEmailAddressDialogListner
{
	public abstract void onDialogReturned(EmailAddress oldAddress, EmailAddress newAddress);
}

public class AddressBook extends BaseActivity implements OnClickListener,OnEmailAddressDialogListner
{
	private ListView _addressListView;
	public static ArrayList<EmailAddress> addressArry = new ArrayList<EmailAddress>();
//	public static ArrayList<EmailAddress> addressFromPhone = new ArrayList<EmailAddress>();
	private int selectIdx = -1;
	private Button _addButton = null;
	private Button _editButton = null;
	private Button _delButton = null;
	
	private EmailAddressDialog _dialog = null;
	
	final static String[] PHONENUMBER_PREFIX = { "130", "131", "132", "145", "155", "156", "185",
												"186", "134", "135", "136", "137", "138",

												"139", "147", "150", "151", "152", "157", "158",
												"159", "182", "183", "187", "188", "133", "153",
												"189", "180" };

/**
	 * 匹配手机号码
	 * <p>
	 * 新联通</br>
	 * （中国联通+中国网通）手机号码开头数字 130,131,132,145,155,156,185,186</br>
	 * 新移动</br>
	  * 　（中国移动+中国铁通）手机号码开头数字</br>
	 * 134,135,136,137,138,139,147,150,151,152,157,158,159,182,183,187,188</br>
	 * 新电信</br>
	  * 　（中国电信+中国卫通）手机号码开头数字 133,153,189,180</br>
	 * </p>
	 * @param 手机号码
	 * @return 参数为null和不合法时返回false，否则返回true
*/

	public static boolean patternPhoneNumber(String number)
	{
		int len = PHONENUMBER_PREFIX.length;
		if (number != null)
		{
			for (int i = 0; i < len; i++)
			{
				Pattern p = Pattern.compile(PHONENUMBER_PREFIX[i] + "\\d{8}");
				if (p.matcher(number).matches())
				{
					return true;
				}
			}
		}

		return false;
	}

	public static ArrayList<EmailAddress> getEmailAddresses()
	{
		if(addressArry.isEmpty())
		{
			NewDbHelper.getInstance().loadAddressBook();
			Thread t = new Thread(
				new Runnable()
				{
					public void run()
					{
						addressArry.addAll(getAddressFromPhone());
					}
				}
			);
			t.start();

			
		}
		return addressArry;
	}
	public static  ArrayList<EmailAddress> getAddressFromPhone()
	{
		ArrayList<EmailAddress> phoneAddress = new ArrayList<EmailAddress>();
//		ContentResolver resolver=MyApp.instance().getContentResolver();
//		String[] contractMsg=new String[]{ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,ContactsContract.CommonDataKinds.Email.DISPLAY_NAME,ContactsContract.CommonDataKinds.Phone.NUMBER};
//		Cursor cursor=resolver.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, contractMsg, null, null, null);
//		while(cursor.moveToNext())
//		{
//			EmailAddress address=null;
//			String contractName=cursor.getString(0);
//			String contractEmail=cursor.getString(1);
//			String contractNumber=cursor.getString(2);
//			if(!Utils.isEmpty(contractName))
//			{
//				if(!Utils.isEmpty(contractEmail))
//				{
//					address=new EmailAddress(contractName, contractEmail);
//					addressFromPhone.add(address);
//				}
//				else if(!Utils.isEmpty(contractEmail))
//				{
//					address=new EmailAddress(contractName, contractNumber);
//					addressFromPhone.add(address);
//				}
//			}
//		}
	    Uri uri = ContactsContract.Contacts.CONTENT_URI; // 通讯录的uri,这是推荐的常量 
	    ContentResolver resolver=MyApp.instance().getContentResolver();
        Cursor cursor = resolver.query(uri, null, null, null, null); 
        // 取得通讯录里的内容 
        while (cursor.moveToNext()) { 
        	EmailAddress address=null;
//	            StringBuffer buf = new StringBuffer(); // 实例化一个可变字符串StringBuffer 
            // 取得联系人id,每个条目都有一个唯一的id(主键) 
            String contactId = cursor.getString(cursor 
                    .getColumnIndex(ContactsContract.Contacts._ID)); 
            // 取得联系人的显示名称 
            String name = cursor.getString(cursor 
                    .getColumnIndex(ContactsContract.Data.DISPLAY_NAME)); 
//	            buf.append("id:" + contactId).append(",name:" + name); 
            if(!Utils.isEmpty(name))
            {
	            // 取得联系人的email 
	            Cursor email = resolver.query( 
	                    ContactsContract.CommonDataKinds.Email.CONTENT_URI, null, 
	                    ContactsContract.CommonDataKinds.Email.CONTACT_ID + " = "
	                            + contactId, null, null); 
	            boolean hasEmail=false;
	            while (email.moveToNext()) { 
	            	hasEmail=true;
	                String mail = email 
	                        .getString(email 
	                                .getColumnIndex(ContactsContract.CommonDataKinds.Email.DATA)); 
//		                buf.append(",mail:" + mail); 
	                address=new EmailAddress(name, mail);
	                phoneAddress.add(address);
	            } 
	            email.close(); 
	            if(!hasEmail)
	            {
		            // 取得联系人的号码 
		            Cursor phone = resolver.query( 
		                    ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, 
		                    ContactsContract.CommonDataKinds.Phone.CONTACT_ID + " = "
		                            + contactId, null, null); 
		            while (phone.moveToNext()) { 
		                String phonum = phone 
		                        .getString(phone 
		                                .getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); 
//			                buf.append(phonum); 
		                address=new EmailAddress(name, phonum);
		                phoneAddress.add(address);
		            } 
		            phone.close(); 
	            }
            }
        } 
        cursor.close(); 
        return phoneAddress;
	}
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
		setContentView(R.layout.address_book);
		//win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.address_book_titlebar);
		
		
		
		_addressListView = (ListView)findViewById(R.id.addressBookListView);
		_addButton = (Button)findViewById(R.id.ab_newBtn);
		_editButton = (Button)findViewById(R.id.ab_editBtn);
		_delButton = (Button)findViewById(R.id.ab_deleteBtn);
		
		_addButton.setOnClickListener(this);
		_editButton.setOnClickListener(this);
		_delButton.setOnClickListener(this);
		
		
		
		/*for(int i = 0; i < 3; i++)
		{
			addressArry.add(new EmailAddress("Tim Liu<mendynew@126.com>"));
		}*/
		
		
		
		getEmailAddresses();//load on demand;
		
		AddressListAdapter adapter = new AddressListAdapter(this, addressArry);
		_addressListView.setAdapter(adapter);
		_addressListView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> paramAdapterView,
					View paramView, int paramInt, long paramLong)
			{
				if(paramInt == 0)
					return;
				clearSelection();
				selectIdx =paramInt;
//				paramAdapterView.getChildAt(0).setBackgroundColor(Color.BLACK);
				int selectedColor = getResources().getColor(R.color.gray);
//				int backColor = getResources().getColor(R.color.white);
//				int childCount=paramAdapterView.getChildCount();
				paramView.setBackgroundColor(selectedColor);
//				for(int i=0;i<paramAdapterView.getCount();i++)
//				{
////		            View v=paramAdapterView.getChildAt(i);
////			        if (paramInt == i) {
////			        	v.setBackgroundColor(selectedColor);
////			        } else {
////			        	v.setBackgroundColor(backColor);
////			        }
//					
//					}
//				}
				enableButtons(true);
			}

		});
		
		enableButtons(false);
		
		_dialog = new EmailAddressDialog(this);
		_dialog.setListner(this);
	}
	
	private EmailAddress getSelectedAddress()
	{
		if(selectIdx < 1 || selectIdx >addressArry.size())
			return null;
		return addressArry.get(selectIdx-1);
	}
	
	@Override
	public void onDialogReturned(EmailAddress oldAddress, EmailAddress newAddress)
	{
		if(oldAddress == null)
		{
			if(newAddress == null)//cancel button clicked;
				return;
			//add new address;
			String errMsg = NewDbHelper.getInstance().addEmailAddress(newAddress);
			if(!errMsg.equals(""))
			{
				DialogUtils.showMsgBox(this,errMsg, getResources().getString(R.string.error));
				return;
			}
			addressArry.add(newAddress);
			updateListView(true);
		}
		else
		{//edit address;
			if(newAddress == null)
				return;
			String errMsg = NewDbHelper.getInstance().updateEmailAddress(newAddress, oldAddress.getAddress());
			if(!errMsg.equals(""))
			{
				DialogUtils.showMsgBox(this,errMsg, getResources().getString(R.string.error));
				return;
			}
			EmailAddress curAddress = getSelectedAddress();
			curAddress.setName(newAddress.getName());
			curAddress.setAddress(newAddress.getAddress());	
			updateListView(true);
		}
	}
	
	private void updateListView(boolean clearValue)
	{
		AddressListAdapter sAdapter = (AddressListAdapter)_addressListView.getAdapter();
    	sAdapter.notifyDataSetChanged();
    	if(clearValue)
    		clearSelection();
	}
	private void clearSelection()
    {
    	selectIdx = -1;
    	int childCount = _addressListView.getChildCount();
    	int backColor = getResources().getColor(R.color.white);
    	for(int i = 1; i < childCount; i++)
    		_addressListView.getChildAt(i).setBackgroundColor(backColor);
    	enableButtons(false);
    }
	
	private void enableButtons(Boolean value)
	{
		_editButton.setEnabled(value);
		_delButton.setEnabled(value);
	}
	
	@Override
    public void onClick(View v)
	{
    	switch(v.getId())
    	{
    	case R.id.ab_newBtn:
    		_dialog.setEmailAddress(null);
    		_dialog.show();
    		break;
    	case R.id.ab_editBtn:
    	{
    		_dialog.setEmailAddress(getSelectedAddress());
    		_dialog.show();
    		break;
    	}
    	case R.id.ab_deleteBtn:
    	{
    		if(selectIdx < 1)
    			return;
    		String errMsg = NewDbHelper.getInstance().deleteEmailAddress(getSelectedAddress());
    		if(!errMsg.equals(""))
			{
				DialogUtils.showMsgBox(this,errMsg, getResources().getString(R.string.error));
				return;
			}
    		addressArry.remove(selectIdx-1);
    		updateListView(true);
    		break;
    	}
    	default:
    		break;
    	}
	}
	
	private class EmailAddressDialog extends Dialog implements android.view.View.OnClickListener
	{
		private EditText nameEditText = null;
		private EditText addressEditText = null;
		private Button okButton = null;
		private Button cancelButton = null;
		
		EmailAddress eAddress = null;
		OnEmailAddressDialogListner l = null;
		
		public EmailAddressDialog(Context ctx)
		{
			super(ctx);
			setContentView(R.layout.email_address_dialog);
			
			nameEditText = (EditText)findViewById(R.id.ead_nameTxt);
			addressEditText = (EditText)findViewById(R.id.ead_addressTxt);
			okButton = (Button)findViewById(R.id.ead_okBtn);
			cancelButton = (Button)findViewById(R.id.ead_cancelBtn);
			
			okButton.setOnClickListener(this);
			cancelButton.setOnClickListener(this);
		}
		
		public void setEmailAddress(EmailAddress address)
		{
			eAddress = address;
			if(address != null)
			{
				nameEditText.setText(address.getName());
				addressEditText.setText(address.getAddress());
			}
			else {
				nameEditText.setText("");
				addressEditText.setText("");
			}
		}
		
		public void setListner(OnEmailAddressDialogListner l)
		{
			this.l = l;
		}
		
		@Override
	    public void onClick(View v)
		{
			if(l == null)
				return;
	    	switch(v.getId())
	    	{
	    	case R.id.ead_okBtn:
	    	{
	    		String name = nameEditText.getText().toString();
	    		String address = addressEditText.getText().toString();
	    		if(name.equals(""))
	    		{
	    			Resources res = getContext().getResources();
	    			DialogUtils.showMsgBox(getContext(),res.getString(R.string.ab_empty_name), res.getString(R.string.error));
	    			return;
	    		}
	    		if(!AccountWizard.isMailAddressValid(address, getContext()))
	    			return;
	    			
	    		this.hide();
	    		if(eAddress != null)//if not changed, ignore
	    		{
	    			if(eAddress.getName().equals(name) && eAddress.getAddress().equals(address))
	    				return;
	    		}
	    		l.onDialogReturned(eAddress, new EmailAddress(name, address));
	    		break;
	    	}
	    	case R.id.ead_cancelBtn:
	    		this.hide();
	    		break;
	    	}    	
	    }
	}
	
	private class AddressListAdapter extends BaseAdapter
	{
		private Context context;
		private LayoutInflater layoutInflater;
		private ArrayList<EmailAddress> addresses;
		class ViewHolder{
			TextView nameView=null;
			TextView addressView=null;
		}
		public AddressListAdapter(Context context, ArrayList<EmailAddress> addresses)
		{
			this.context = context;
			layoutInflater = (LayoutInflater) this.context
					.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
			this.addresses = addresses;
		}

		@Override
		public int getCount()
		{
			return addresses.size()+1;
		}

		@Override
		public Object getItem(int position)
		{
			if(position==0)
				return null;
			return addresses.get(position-1);
		}

		@Override
		public long getItemId(int position)
		{
			return position;
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent)
		{
			View view = layoutInflater.inflate(R.layout.address_book_item, null);
			// view.setBackgroundDrawable(getResources().getDrawable(R.drawable.tab_selected_two));
			TextView nameView = (TextView) view.findViewById(R.id.ab_name);
			TextView addressView = (TextView) view.findViewById(R.id.ab_address);

			if (position == 0)
			{
				// view.setBackgroundColor(Color.BLACK);
				// view.setBackgroundDrawable(getResources().getDrawable(R.drawable.tab_selected_two));
				nameView.setBackgroundDrawable(getResources()
						.getDrawable(R.drawable.tab_selected_two));
				addressView.setBackgroundDrawable(getResources()
						.getDrawable(R.drawable.tab_selected_two));
				// nameView.setBackgroundColor(Color.rgb(0, 128, 255));
				// nameView.setTextColor(Color.YELLOW);
				// addressView.setBackgroundColor(Color.rgb(0, 128, 255));
				// addressView.setTextColor(Color.YELLOW);
				nameView.setText(R.string.ab_name);
				addressView.setText(R.string.ab_address);
			}
			else
			{
				EmailAddress addr = addresses.get(position - 1);
				nameView.setText(addr.getName());
				addressView.setText(addr.getAddress());
			}
			return view;

			// ViewHolder holder = null;
			// if (convertView == null)
			// {
			// holder = new ViewHolder();
			// convertView = layoutInflater.inflate(R.layout.address_book_item,
			// null);
			// holder.nameView = (TextView)
			// convertView.findViewById(R.id.ab_name);
			// holder.addressView = (TextView)
			// convertView.findViewById(R.id.ab_address);
			// convertView.setTag(holder);
			// if (position == 0)
			// {
			// holder.nameView.setBackgroundDrawable(getResources()
			// .getDrawable(R.drawable.tab_selected_two));
			// holder.addressView.setBackgroundDrawable(getResources()
			// .getDrawable(R.drawable.tab_selected_two));
			// holder.nameView.setText(R.string.ab_name);
			// holder.addressView.setText(R.string.ab_address);
			// return convertView;
			// }
			//
			//
			// }
			// else
			// {
			// holder = (ViewHolder) convertView.getTag();
			// }
			//
			// EmailAddress addr = addresses.get(position - 1);//有问题
			// holder.nameView.setText(addr.getName());
			// holder.addressView.setText(addr.getAddress());
			// return convertView;
		}
	}
}
package mobi.cloudymail.mailclient;

import android.content.Context;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
public class Animations{
	Animation DelDown,DelUp;
	public Animation getDownAnimation(Context context){
		return AnimationUtils.loadAnimation(context, R.anim.del_down);
	}
}package mobi.cloudymail.mailclient;

import java.util.List;

import mobi.cloudymail.mailclient.net.AttachmentInfo;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

public class AttachmentAdapter extends BaseAdapter{
    private Context context;
    private LayoutInflater layoutInflater;
    private List<AttachmentInfo> attachments;
    private Composer _composerActivity;
    
	public AttachmentAdapter(Context context, 
			List<AttachmentInfo> attachmenet) {
		_composerActivity=((Composer)context);
		this.context = context;
		this.layoutInflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		this.attachments = attachmenet;
	}

	@Override
	public int getCount() {
		return attachments.size();
	}

	@Override
	public Object getItem(int position) {
		return attachments.get(position);
	}

	@Override
	public long getItemId(int position) {
		return position;
	}

	@Override
	public View getView(final int position, View convertView, ViewGroup parent) {
		View view=convertView;
		if(view == null)
			view = layoutInflater.inflate(R.layout.attachment_item_layout, null);
		ImageView attachIconView=(ImageView) view.findViewById(R.id.attachImage);
		TextView attachNameView=(TextView)view.findViewById(R.id.attachName);
		ImageButton delAttachBtn=(ImageButton)view.findViewById(R.id.delAttachItem);
		
		delAttachBtn.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				_composerActivity.delAttachment(position);
			}
		});
		AttachmentInfo attachmentInfo = attachments.get(position);
		attachNameView.setText(attachmentInfo.fileName+"("+attachmentInfo.size+")");
		return view;
	}

}
package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.lang.reflect.Method;

import com.umeng.analytics.MobclickAgent;

import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.mailclient.net.DownloadAttaTask;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.util.MyApp;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.Window;
import android.webkit.WebChromeClient;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;

public class AttachmentViewer extends BaseActivity
{
	public static final String ATTACHMENT_INFO = "attachment_info";
	
	AttachmentInfo attach = null;
	private String internalPath = null;
	
	public static void setBrowserOverviewMode(WebView view, boolean mode)
	{
		if(android.os.Build.VERSION.SDK_INT >= 7) //version 2.1 or higher
		{
			Class cls = WebSettings.class;
			try
			{
				Method method = cls.getMethod("setLoadWithOverviewMode", boolean.class);
				method.invoke(view.getSettings(), mode);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}

	}
	class CmailScriptInterface
	{
		public void fitView()
		{
			AttachmentViewer.this.runOnUiThread(new Runnable() {
				
				@Override
				public void run()
				{
					setBrowserOverviewMode(_previewViewer, true);
					_previewViewer.getSettings().setUseWideViewPort(true);
				}
			});

//			int h ;
//			h  = _previewViewer.getContentHeight();
//			if(h <= 0)
//			{
//				Timer t = new Timer();
//				t.schedule(new TimerTask() {
//					
//					@Override
//					public void run()
//					{
//						int h2  = _previewViewer.getContentHeight();
//						while((h2  = _previewViewer.getContentHeight()) > _previewViewer.getHeight())
//							_previewViewer.zoomOut();
//						
//					}
//				},1000);
//			}
//			while((h  = _previewViewer.getContentHeight()) > _previewViewer.getHeight())
//				_previewViewer.zoomOut();
		}
		
		//download file from extracted rar/zip package.
		public void downloadAttachment(final int attachmentIndex,final String fileName,final String internalPath)
		{
			if (!MailViewer.isSdCardAvailable(AttachmentViewer.this))
				return;
			runOnUiThread(new Runnable() {

				@Override
				public void run()
				{
					DownloadAttaTask downTask = new DownloadAttaTask(attach, internalPath, false);
					downTask.execute(MailViewer.getAvailableFilePathToSave(fileName));
				}
			});	
		}
		
		public void openAttachment(final int attachmentIndex,final String attachmentName, final String internalPath)
		{
			AttachmentViewer.this.internalPath = internalPath;
			runOnUiThread(new Runnable() {

				@Override
				public void run()
				{
					previewAttachment(attachmentIndex,attachmentName,internalPath);
				}

			});
		}
	}
	private static final int MODE_ATTACHLIST = 1; // read attachment for mail
													// viewer
	private static final int MODE_PREVIEW = 2; // preview attachment
	private static final int MODE_PREVIEW_PROGRESS = 3;// proviewing progress
														// bar
	private static final int MODE_ATTACHLIST_WRITE = 4;// add attachment view
														// for composer

	
	private WebView _previewViewer = null;
	private RelativeLayout _progressBarLayout = null;
	private ProgressBar _progressBar = null;

	private int _currentMode = MODE_ATTACHLIST;

	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		Window win = getWindow();
		win.requestFeature(Window.FEATURE_LEFT_ICON);
		setContentView(R.layout.attachment_viewer);
		win.setFeatureDrawableResource(	Window.FEATURE_LEFT_ICON,
										R.drawable.cloudymail);
//		_attachPreviewProgressLayout=findViewById(R.id.attachPreviewProgressLayout);
		_previewViewer = (WebView) findViewById(R.id.previewView);

		_progressBar = (ProgressBar) findViewById(R.id.attachPreviewProgressBar);
		_progressBarLayout = (RelativeLayout) findViewById(R.id.attachPreviewProgressLayout);

		_previewViewer.getSettings().setJavaScriptEnabled(true);
		_previewViewer.setWebChromeClient(new WebChromeClient() {
			@Override
			public void onProgressChanged(WebView view, int progress)
			{
				// Activities and WebViews measure progress with different
				// scales.
				// The progress meter will automatically disappear when we reach
				// 100%
				// activity.setProgress(progress * 1000);
				_progressBar.setProgress(progress);
			}
		});
		
		_previewViewer.setWebViewClient(new WebViewClient() {

			@Override
			public boolean shouldOverrideUrlLoading(WebView view, String url)
			{
				view.loadUrl(url);
				// Log.d("shouldOverrideUrlLoading", url);
				return true;
			}
            
			@Override
			public void onPageStarted(WebView view, String url, Bitmap favicon)
			{
				AttachmentViewer.this.setCurrentMode(MODE_PREVIEW_PROGRESS);
				super.onPageStarted(view, url, favicon);
			}

			@Override
			public void onPageFinished(WebView view, String url)
			{
				if (url.equals("about:relogin"))
				{
					view.stopLoading();
					if (MyApp.getAgent(AccountManager.getAccount(attach.getAccountId())).interactiveLogin(false,true,true))
					{
						view.loadUrl(makePreviewUrl(attach.getAttachIndx(), attach.getMailUid(), internalPath));
					}
					return;
				}
				else
				{
					AttachmentViewer.this.setCurrentMode(MODE_PREVIEW);
					Log.d(LOGTAG, "pagefinished");
				}
				
			}

		});
		_previewViewer.addJavascriptInterface(new CmailScriptInterface(), "cmail");
		_previewViewer.getSettings().setBuiltInZoomControls(true);
		Intent intent = getIntent();
		attach = intent.getParcelableExtra(AttachmentViewer.ATTACHMENT_INFO);
		if(attach != null)
		{
			previewAttachment(attach.index, attach.fileName, null);
		}
	}
	
	@Override
	 public boolean onKeyDown(int keyCode, KeyEvent event)
	 {
		if ((keyCode == KeyEvent.KEYCODE_BACK)
				&&_previewViewer.getVisibility() == View.VISIBLE
				&& _previewViewer.canGoBack()) 
		{ 
	        _previewViewer.goBack(); 
	        return true; 
	    } 
		return super.onKeyDown(keyCode, event);
	 }




	interface OnFileExistDialogListner
	{
		public abstract void onDialogReturned(int selectedId, String newFileName);
	}



	void setCurrentMode(int mode)
	{
		_currentMode = mode;
		switch (_currentMode)
		{
		case MODE_ATTACHLIST:
		case MODE_ATTACHLIST_WRITE:
		{
			_previewViewer.setVisibility(View.GONE);
			_progressBarLayout.setVisibility(View.VISIBLE);
		}
			break;
		case MODE_PREVIEW_PROGRESS:
			_previewViewer.setVisibility(View.VISIBLE);
			_progressBar.setVisibility(View.VISIBLE);
			break;
		case MODE_PREVIEW:
//			_attachListLayout.setVisibility(View.VISIBLE);
			_progressBarLayout.setVisibility(View.VISIBLE);
			_previewViewer.setVisibility(View.VISIBLE);
			_progressBar.setVisibility(View.GONE);
			break;
			
		default:
			break;
		}
	}
	
	private void previewAttachment(int attachmentIndex,String attachmentName,String internalPath)
	{
		/*
		 * _attachListLayout.setVisibility(View.GONE);
		 * _previewViewer.setVisibility(View.VISIBLE); _currentMode =
		 * MODE_PREVIEW_PROGRESS;
		 */
		
		setCurrentMode(MODE_PREVIEW_PROGRESS);
		
		_previewViewer.clearView();
		
		
		String attachUrl = makePreviewUrl(attachmentIndex, attach.getMailUid(),internalPath);
		if(attachUrl == null)
		{
			finish();
			return;
		}
		String upperFileName = attachmentName.toUpperCase();
		boolean isPPT = upperFileName.endsWith(".PPT") || upperFileName.endsWith(".PPTX");
		setBrowserOverviewMode(_previewViewer, isPPT);
		//_previewViewer.getSettings().setLoadWithOverviewMode(isPPT);
		_previewViewer.getSettings().setUseWideViewPort(true);
		_previewViewer.loadUrl(attachUrl);
		
	}

//	private String makePreviewUrl(int attachmentIndex,String mailUid)
//	{
//		return makePreviewUrl(attachmentIndex, mailUid,null);
//	}
	
	private String makePreviewUrl(int attachmentIndex,
			String mailUid,String internalPath)
	{
		String sid = MyApp.getAgent(AccountManager.getAccount(attach.getAccountId())).getSessionId(true,true,true);
		if(sid == null)
			return null;
		String attachUrl = ServerAgent.getUrlBase()
							+ "/ViewPart?uid="
							+ java.net.URLEncoder.encode(mailUid)
							+ "&folderName="
							+ java.net.URLEncoder.encode(attach.getMailInfo().getFolder())
							+ "&index="
							+ attachmentIndex
							+ "&pageNo=0";
		if(internalPath!=null && !internalPath.equals(""))
			attachUrl += "&internalPath="+internalPath;
		
		attachUrl += "&sid="+
						java.net.URLEncoder.encode(sid);
		return attachUrl;
	}
	
	@Override
	protected void onNewIntent(Intent intent)
	{
		setIntent(intent);
	}
	@Override
	protected void onResume() 
	{
		super.onResume();
		MobclickAgent.onResume(this);
		
	};
	
}
package mobi.cloudymail.mailclient;

import mobi.cloudymail.util.MyApp;
import android.app.Activity;

public class BaseActivity extends Activity
{
	@Override
	protected void onResume ()
	{
		super.onResume();
		MyApp.setCurrentActivity(this);
	}
}
package mobi.cloudymail.mailclient;

import java.util.ArrayList;
import java.util.List;

import mobi.cloudymail.util.Utils;
import android.database.DataSetObserver;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ListAdapter;
import android.widget.TextView;

abstract class BeanAdapter implements ListAdapter
{
	private List<DataSetObserver> dataObservers = new ArrayList<DataSetObserver>(2);
	private int[] toIds;
	private String[] fromNames;
	/**
	 * 
	 * @param from A list of column names that will be added to the Map associated with each item.
	 * @param to The views that should display column in the "from" parameter. These should all be TextViews. The first N views in this list are given the values of the first N columns in the from parameter. 
	 * @param itemView view to show a list item
	 */
	public BeanAdapter(String[] from, int[] to)
	{
		fromNames = from;
		toIds = to;
	}
	@Override
	public void registerDataSetObserver(DataSetObserver dataSetObserver)
	{
		dataObservers.add(dataSetObserver);
	}

	@Override
	public void unregisterDataSetObserver(DataSetObserver dataSetObserver)
	{
		dataObservers.remove(dataSetObserver);
	}

	@Override
	public abstract int getCount();

	@Override
	public abstract Object getItem(int position);

	@Override
	public long getItemId(int pos)
	{
		return pos;
	}

	@Override
	public boolean hasStableIds()
	{
		return true;
	}
	
	public abstract View createItemView(ViewGroup parent);
	public abstract int getViewBackGround(int position);
	
	@Override
	public View getView(int position, View convertView, ViewGroup parent)
	{
		if(convertView == null)
		{
			convertView = createItemView(parent);
			//convertView = activity.getLayoutInflater().inflate(R.layout.mail_item, parent);
		}
		Utils.ASSERT( convertView.getId() == R.layout.mail_item);
		Object m = getItem(position);
		for(int i=0;i<fromNames.length;i++)
		{
			((TextView)convertView.findViewById(toIds[i])).setText(getPropertyValue(m, fromNames[i]));
		}
		
		convertView.setBackgroundColor(getViewBackGround(position));
		return convertView;
	}

	public abstract String getPropertyValue(Object o, String name);
	
	@Override
	public int getItemViewType(int paramInt)
	{
		return 0;
	}

	@Override
	public int getViewTypeCount()
	{
		return 1;
	}

	@Override
	public boolean isEmpty()
	{
		return getCount() == 0;
	}

	@Override
	public boolean areAllItemsEnabled()
	{
		return true;
	}

	@Override
	public boolean isEnabled(int paramInt)
	{
		return true;
	}
	
}package mobi.cloudymail.mailclient;

import mobi.cloudymail.util.Utils;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.net.ConnectivityManager;
import android.os.SystemClock;
import android.util.Log;

public class BootReceiver extends BroadcastReceiver {
	public static final String CONNECTIVITY_ACTION=ConnectivityManager.CONNECTIVITY_ACTION;
    @Override
    public void onReceive(Context context, Intent intent) {
        // 在这里干你想干的事（启动一个Service，Activity等），本例是启动一个定时调度程序，每30分钟启动一个Service去更新数据
        final String action = intent.getAction();
        if (Intent.ACTION_BOOT_COMPLETED.equals(action))
        {
        	Utils.log("Boot completed");
            context.startService(new Intent(context, ReceiveMailService.class));
//            long firstTime = SystemClock.elapsedRealtime();
//            AlarmManager am = (AlarmManager) context
//                    .getSystemService(Activity.ALARM_SERVICE);
//            am.cancel(mAlarmSender);
//            am.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, firstTime,
//                    30 * 60 * 1000, mAlarmSender);
        }
        else if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action))
        {
        	Utils.log( "Connectivity changed");
        	Intent i = new Intent(context, ReceiveMailService.class);
        	i.putExtra(CONNECTIVITY_ACTION, 1);
            context.startService(i);
        	
        }
       
    }
}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URI;
import java.nio.charset.Charset;
import java.sql.SQLException;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.OutMailInfo;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.mailclient.net.DataPacket;
import mobi.cloudymail.mailclient.net.Result;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.mailclient.net.TrustAllSSLSocketFactory;
import mobi.cloudymail.util.DialogResult;
import mobi.cloudymail.util.DialogUtils;
import mobi.cloudymail.util.MessageBox;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.StatusLine;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.params.ConnManagerParams;
import org.apache.http.conn.params.ConnPerRoute;
import org.apache.http.conn.params.ConnPerRouteBean;
import org.apache.http.conn.params.ConnRouteParams;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.cookie.Cookie;
import org.apache.http.cookie.CookieSpec;
import org.apache.http.cookie.CookieSpecFactory;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.MultipartEntity;
import org.apache.http.entity.mime.content.ByteArrayBody;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.impl.cookie.BrowserCompatSpec;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.simpleframework.xml.Serializer;
import org.simpleframework.xml.core.Persister;

import mobi.cloudymail.mms.MMSInfo;
import mobi.cloudymail.mms.MMSSender;

import com.umeng.analytics.MobclickAgent;

import android.R.integer;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Dialog;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.provider.MediaStore;
import android.provider.OpenableColumns;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.text.Editable;
import android.text.Html;
import android.text.TextWatcher;
import android.util.Log;
import android.util.SparseBooleanArray;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.ViewGroup.LayoutParams;
import android.view.Window;
import android.webkit.WebView;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.MultiAutoCompleteTextView;
import android.widget.RemoteViews;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

public class Composer extends BaseActivity implements OnClickListener
{
	public static final int COMPOSER_NEWMAIL = 1;
	public static final int COMPOSER_REPLY = 2;
	public static final int COMPOSER_REPLYALL = 3;
	public static final int COMPOSER_FORWARDMAIL = 4;
	public static final int COMPOSER_EDIT_MAIL = 5;
	public static final int COMPOSER_NEW_FROM_SENDTO = 6;

	private static final int REQ_TAKE_PICTURE = 10;
	private static final int REQ_SOUND_RECORDER = 20;
	private static final int REQ_CROP = 2;
	private static final int REQ_FILE_BROWSER = 30;
	private String cameraFileName;
	
	
	
	private Spinner _fromSpinner = null;
	private Button _toButton = null;
	private EditText _toEditText = null;
	private Button _ccButton = null;
	private EditText _ccEditText = null;
	private Button _bccButton = null;
	private EditText _bccEditText;
	private CheckBox _addRefBox = null;
	private CheckBox _includeAttaBox = null;
	private EditText _contentText = null;
	private Button _sendButton = null;
	private Button _saveButton = null;
	private Button _cancelButton = null;
	private EditText _subjectText = null;
	private Button _respondInlineBtn = null;
	private WebView _refOldMailView = null;
	private LinearLayout _refMailLayout = null;
	boolean needSendMail=false;
	private String[] addressBookArray = null;
	// private MailInfo curEditMailInfo = null;
	private OutMailInfo curMailInfo = null;
//	public List<AttachmentInfo> _attachments = new ArrayList<AttachmentInfo>();

	private ListView lv = null;

	private int clickedButton = -1;

	// open type diff edit from reply/forwar/replay all.
	// it's used to initialize the widget.
	private int _openType = COMPOSER_NEWMAIL;
	// mail type is current edited mail's type, can be new/reply/forward;
	// it also controlls the wiget _addRefBox,_includeAttaBox,
	// private int _mailType = COMPOSER_NEWMAIL;
	// private int _mailId = -1;///current edited out mail's id.

	private DataPacket dp = null;

	private String _refBody;
	private boolean contentStateModif = false;

	private final static int CUSTOM_NOTIFICATION_VIEW_ID = 1;
	private final static int FINISH_NOTIFI_ID = 2;
	private static final int REQ_SEND_MMS = 0;

	
	private NotificationManager mNotificationManager;
	private ListView _attachListView;
	private int selectedIdx = -1;
	private boolean _hasAttachFlag;
	private boolean _fromEditable = true;
	Handler myHandler=new Handler();
	
	ArrayList<String> phoneNumbers=new ArrayList<String>();
	ArrayList<String> phoneInEditText=new ArrayList<String>();
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
		setContentView(R.layout.composer);
		//win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.composer_titlebar);
		
		contentStateModif = false;
	   
		_attachListView=(ListView)findViewById(R.id.attachmentListView);
		
		_fromSpinner = (Spinner) findViewById(R.id.addresserCmb);
		_fromSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
			@Override
			public void onItemSelected(AdapterView<?> parentView, View selectedItemView, int position, long id) {
				if(_fromEditable)
					((TextView)parentView.getChildAt(0)).setTextColor(Color.BLACK);
				else
					((TextView)parentView.getChildAt(0)).setTextColor(Color.GRAY);
			}

			@Override
			public void onNothingSelected(AdapterView<?> arg0)
			{
				// TODO Auto-generated method stub
				
			}});
		_toButton = (Button) findViewById(R.id.toBtn);
		_toEditText = (EditText) findViewById(R.id.autoEditText);
		_ccButton = (Button) findViewById(R.id.ccBtn);
		_ccEditText = (EditText) findViewById(R.id.ccEditText);
		_bccButton = (Button) findViewById(R.id.bccBtn);
		_bccEditText = (EditText) findViewById(R.id.bccEditText);
		_addRefBox = (CheckBox) findViewById(R.id.addRefCb);

		_includeAttaBox = (CheckBox) findViewById(R.id.includeAttachmentCb);
		_contentText = (EditText) findViewById(R.id.mainBody);
		_sendButton = (Button) findViewById(R.id.cp_sendBtn);
		_saveButton = (Button) findViewById(R.id.cp_saveBtn);
		_cancelButton = (Button) findViewById(R.id.cp_cancelBtn);
		_subjectText = (EditText) findViewById(R.id.cp_subjectText);
		_refOldMailView = (WebView) findViewById(R.id.refOldMailwView);
		_respondInlineBtn = (Button) findViewById(R.id.cp_respondInlineBtn);
		_refMailLayout = (LinearLayout) findViewById(R.id.cp_addRefLayout);

		_toButton.setOnClickListener(this);
		_ccButton.setOnClickListener(this);
		_bccButton.setOnClickListener(this);
		_sendButton.setOnClickListener(this);
		_saveButton.setOnClickListener(this);
		_cancelButton.setOnClickListener(this);
		_respondInlineBtn.setOnClickListener(this);     
		_refOldMailView.setBackgroundColor(0x00000000);
		
		_addRefBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {
			@Override
			public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
			{
				int vbt = isChecked ? View.VISIBLE : View.GONE;
				_respondInlineBtn.setVisibility(vbt);
				_refOldMailView.setVisibility(vbt);
			}
		});

		_ccButton.setVisibility(View.GONE);
		_ccEditText.setVisibility(View.GONE);
		_bccButton.setVisibility(View.GONE);
		_bccEditText.setVisibility(View.GONE);

		

		SearchEmailBookAdapter toAdapter = new SearchEmailBookAdapter(this, R.layout.list_item);
		// ArrayAdapter<String> toAdapter=new ArrayAdapter<String>(this,
		// android.R.layout.simple_dropdown_item_1line,array);
		// AutoCompleteTextView mutiAutoCompleteTextView =
		// (AutoCompleteTextView) findViewById(R.id.autoEditText);
		MultiAutoCompleteTextView mutiAutoCompleteTextView = (MultiAutoCompleteTextView) findViewById(R.id.autoEditText);
		mutiAutoCompleteTextView.setAdapter(toAdapter);
		mutiAutoCompleteTextView.setTokenizer(new SemicolonTokenizer());
		
		MultiAutoCompleteTextView ccMutiAutoCompleteTextView = (MultiAutoCompleteTextView) findViewById(R.id.ccEditText);
		ccMutiAutoCompleteTextView.setAdapter(toAdapter);
		ccMutiAutoCompleteTextView.setTokenizer(new SemicolonTokenizer());
		
		MultiAutoCompleteTextView bccMutiAutoCompleteTextView = (MultiAutoCompleteTextView) findViewById(R.id.bccEditText);
		bccMutiAutoCompleteTextView.setAdapter(toAdapter);
		bccMutiAutoCompleteTextView.setTokenizer(new SemicolonTokenizer());
	
		/* method_1 */
		// UserSetting userObj = MailClient.userSetting;
		// _contentText.setText(userObj.getNewSignature().toString());
		/* method_2 */
		// String newSignature = MyApp.userSetting.getSignature();
		// _contentText.setText(newSignature);
		Intent intent = getIntent();
		String action = intent.getAction();
		// if this is from the share menu
		if (Intent.ACTION_SEND.equals(action))
		{
			initMailInformation();
			loadAccountsToSpinner();
			
		}
		else
		{
			/*
			 * Someone has clicked a mailto: link. The address is in the URI.
			 */
			if (Intent.ACTION_SENDTO.equals(action) || Intent.ACTION_VIEW.equals(action))
			{
				_openType = COMPOSER_NEW_FROM_SENDTO;
			}
			else // if from reply,reply all, forward, the mail info should be set.
				_openType = getIntent().getIntExtra("composer_type", _openType);
			initMailInformation();
			loadAccountsToSpinner();
		}
		// If editText change, whether display save dialog box
		_toEditText.addTextChangedListener(new TextWatcher() {

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count)
			{
				if (_toEditText.getText().toString() != null && !_toEditText.getText().toString().equals(""))
				{
					contentStateModif = true;
				}
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after)
			{
			
			}

			@Override
			public void afterTextChanged(Editable s)
			{
				
			}
		});
		_ccEditText.addTextChangedListener(new TextWatcher() {

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count)
			{
				if (_ccEditText.getText().toString() != null && !_ccEditText.getText().toString().equals(""))
				{
					contentStateModif = true;
				}
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after)
			{

			}

			@Override
			public void afterTextChanged(Editable s)
			{

			}
		});
		_bccEditText.addTextChangedListener(new TextWatcher() {

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count)
			{
				if (_bccEditText.getText().toString() != null && !_bccEditText.getText().toString().equals(""))
				{
					contentStateModif = true;
				}
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after)
			{
			}

			@Override
			public void afterTextChanged(Editable s)
			{
			}
		});
		_contentText.addTextChangedListener(new TextWatcher() {

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count)
			{
				if (_contentText.getText().toString() != null && !_contentText.getText().toString().equals(""))
				{
					contentStateModif = true;
				}
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after)
			{
			}

			@Override
			public void afterTextChanged(Editable s)
			{
			}
		});
		_subjectText.addTextChangedListener(new TextWatcher() {

			@Override
			public void onTextChanged(CharSequence s, int start, int before, int count)
			{
				if (_subjectText.getText().toString() != null && !_subjectText.getText().toString().equals(""))
				{
					contentStateModif = true;
				}
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count, int after)
			{
			}

			@Override
			public void afterTextChanged(Editable s)
			{
			}
		});

	}

	
	@Override
	public boolean onCreateOptionsMenu(Menu menu)
	{
		MenuInflater infalter = getMenuInflater();

		infalter.inflate(R.menu.composer_menu, menu);
//		for (int idx = 0; idx < menu.size(); idx++)
//		{
//			MenuItem mItem = menu.getItem(idx);
//		}
		return true;

	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item)
	{
		switch (item.getItemId())
		{
		case R.id.sendMailMenu:
			onSendBtnClicked();
			break;
		case R.id.addToCcMailMenu:
			_ccButton.setVisibility(View.VISIBLE);
			_ccEditText.setVisibility(View.VISIBLE);
			_bccButton.setVisibility(View.VISIBLE);
			_bccEditText.setVisibility(View.VISIBLE);
			break;
		case R.id.addAttacmentMenu:
		{
			selectViewMode();
		}
			break;
		case R.id.cancleMenu:
			onCancelBtnClicked();
			break;

		}
		return super.onOptionsItemSelected(item);
	}

	private void initMailInformation()
	{

		if (_openType == COMPOSER_EDIT_MAIL)
		{
			this.curMailInfo = (OutMailInfo) (MyApp.curMailInfo);
			curMailInfo.setMailType(_openType);
		}
		else if (_openType == COMPOSER_NEWMAIL)
		{
			curMailInfo = new OutMailInfo();
			curMailInfo.setMailType(_openType);
			Bundle extras = getIntent().getExtras();
			String icaFiles[] = extras.getStringArray("icaFilePaths");
			if(icaFiles!=null)
			for(int i=0;i<icaFiles.length;i++)
				addAttachment(icaFiles[i]);
			
			// loadAccountsToSpinner();
			// get the shared image file, add it to attachment list.
			if (extras.containsKey(Intent.EXTRA_STREAM))
			{
				try
				{
					// Get resource path from intent callee
					Uri uri = (Uri) extras.getParcelable(Intent.EXTRA_STREAM);
					String intentType = getIntent().getType();
					if (uri != null)
					{
						ContentResolver cr = getContentResolver();
						String fileName = null;
						String fullPath = null;
						int fileSize = 0;
						Cursor metadataCursor = cr.query(uri, new String[] { MediaStore.Images.Media.DATA,
																			OpenableColumns.DISPLAY_NAME,
																			OpenableColumns.SIZE }, null, null, null);

						if (metadataCursor != null)
						{
							try
							{
								if (metadataCursor.moveToFirst())
								{
									fullPath = metadataCursor.getString(0);
									fileName = metadataCursor.getString(1);
									fileSize = metadataCursor.getInt(2);
								}
							}
							finally
							{
								metadataCursor.close();
							}
						}
						if (fileName == null)
						{
							fileName = uri.getLastPathSegment();
						}

						if ((intentType == null) || (intentType.indexOf('*') != -1))
						{
							intentType = cr.getType(uri);
						}

						if (fileSize <= 0)
						{
							String uriString = uri.toString();
							if (uriString.startsWith("file://"))
							{
								fullPath=uriString.substring("file://".length());
								File f = new File(fullPath);
								fileSize = (int) f.length();
							}
							else
							{
								Log.d(LOGTAG, "Not a file" + "Not a file: " + uriString);
							}
						}
						Log.d(LOGTAG, "Composer" + "new attachment.size: " + fileSize);
						Log.d(LOGTAG, "Composer" + "new attachment.fileName: " + fileName);
						Log.d(LOGTAG, "Composer" + "new attachment.file path: " + fullPath);

						AttachmentInfo attaInfo = new AttachmentInfo(curMailInfo);
						attaInfo.fileName = fileName;
						// Log.d(fileName,
						// "File.length()="+attFile.length()+"; FileInputStream.available():"+fi.available());
						attaInfo.size = Utils.getReadableSize(fileSize);// fi.available());
						attaInfo.fullFilePath = fullPath;
						curMailInfo.addAttachInfo(attaInfo);
						
					}

					// Query gallery for camera picture via
					// Android ContentResolver interface
					// ContentResolver cr = getContentResolver();
					// InputStream is = cr.openInputStream(uri);

//					return;
				}
				catch (Exception e)
				{
					Log.e(LOGTAG, this.getClass().getName() + e.toString());
				}
			}
		}
		else if (_openType == COMPOSER_NEW_FROM_SENDTO)
		{
			curMailInfo = new OutMailInfo();
			_openType = COMPOSER_NEWMAIL;
			curMailInfo.setMailType(_openType);
			Intent intent = getIntent();
			if (intent.getData() != null)
			{
				Uri uri = intent.getData();
				if ("mailto".equals(uri.getScheme()))
				{
					String schemaSpecific = uri.getSchemeSpecificPart();
					int end = schemaSpecific.indexOf('?');
					if (end == -1)
					{
						end = schemaSpecific.length();
					}

					// Extract the recipient's email address from the mailto URI
					// if there's one.
					String recipient = Uri.decode(schemaSpecific.substring(0, end));
					curMailInfo.setTo(recipient);
				}
			}
		}
		else
		{
			MailInfo orgMi = MyApp.curMailInfo;
			curMailInfo = new OutMailInfo();
			curMailInfo.setAccountId(orgMi.getAccountId());
			curMailInfo.setMailType(_openType);
			curMailInfo.setRefBodyFlag(OutMailInfo.REFMAIL_YES);
			curMailInfo.setUid(orgMi.getUid());// set refered Uid;
			curMailInfo.setRefFolder(orgMi.getFolder());
			Resources res = getResources();
			switch (_openType)
			{
			case COMPOSER_REPLYALL:
				curMailInfo.setMailType(COMPOSER_REPLY);
				// add others in original mail's tolist
				Account orgAcct = AccountManager.getAccount(orgMi.getAccountId());
				String orgToOthers = EmailAddress.filterMailAddress(orgMi.getTo(), orgAcct.name);
				String orgCC = EmailAddress.filterMailAddress(orgMi.getCc(), orgAcct.name);
				if (!Utils.isEmpty(orgCC) && !Utils.isEmpty(orgToOthers))
				{
					curMailInfo.setCc(orgToOthers + ";" + orgCC);
				}
				else
				{

					curMailInfo.setCc((orgToOthers == null ? "" : orgToOthers) + (orgCC == null ? "" : orgCC));
				}
				// go on.
			case COMPOSER_REPLY:
				curMailInfo.setTo(orgMi.getFrom());
				curMailInfo.setSubject(res.getString(R.string.reply) + ":" + orgMi.getSubject());
				break;
			case COMPOSER_FORWARDMAIL:
				if (orgMi.hasAttachment())
				{
					// if not login yet, the return result will be empty.
					// Account acct =
					// AccountManager.getAccount(orgMi.getAccountId());
					// if(!MyApp.getAgent(acct).isLogin())
					//curMailInfo.addAttachment(new AttachmentInfo(AttachmentInfo.ALL_REFATTACH_INDEX));
					// else
					curMailInfo.setAttachmentFlag(orgMi.getAttachmentFlag());
					curMailInfo.setAttachments(orgMi.getAttachments());
				}
				curMailInfo.setSubject(res.getString(R.string.forward) + ":" + orgMi.getSubject());
				break;
			}
		}
		// then initialize widget based on mail info.
		_toEditText.setText(curMailInfo.getTo());
		String receiver = curMailInfo.getCc();
		_ccEditText.setText(receiver);
		if(!Utils.isEmpty(receiver))
		{
			_ccButton.setVisibility(View.VISIBLE);
			_ccEditText.setVisibility(View.VISIBLE);
		}
		receiver = curMailInfo.getBc();
		_bccEditText.setText(receiver);
		if(!Utils.isEmpty(receiver))
		{
			_bccButton.setVisibility(View.VISIBLE);
			_bccEditText.setVisibility(View.VISIBLE);
		}		
		_subjectText.setText(curMailInfo.getSubject());

		_includeAttaBox.setVisibility(View.GONE);
		_addRefBox.setVisibility(View.GONE);
		this._refOldMailView.setVisibility(View.GONE);
		this._respondInlineBtn.setVisibility(View.GONE);
		_refMailLayout.setVisibility(View.GONE);

		boolean isShowSignature = false;
		switch (curMailInfo.getMailType())
		{
		case COMPOSER_NEWMAIL:
			isShowSignature = true;
			break;
		case COMPOSER_FORWARDMAIL:
			// must refer old mail.
			_addRefBox.setEnabled(false);
			if (curMailInfo.hasAttachment())
			{
				_includeAttaBox.setChecked(true);
				_includeAttaBox.setVisibility(View.VISIBLE);
				_fromSpinner.setEnabled(false);
				isShowSignature = true;
			}
			// go on.
		case COMPOSER_REPLY:
			_refMailLayout.setVisibility(View.VISIBLE);
			_addRefBox.setChecked(true);
			_addRefBox.setVisibility(View.VISIBLE);
			_respondInlineBtn.setVisibility(View.VISIBLE);
			_refOldMailView.setVisibility(View.VISIBLE);
			isShowSignature = true;
			break;
		case COMPOSER_EDIT_MAIL:
			isShowSignature = false;
			break;
		case COMPOSER_NEW_FROM_SENDTO:
			// isShowSignature=true;
			break;
		}
		String newSignature = MyApp.userSetting.getSignature();
		if (!Utils.isEmpty(newSignature) && isShowSignature == true)
		{
			_contentText.setText(curMailInfo.getBody() + "\n" + newSignature);
		}
		else
		{
			_contentText.setText(curMailInfo.getBody());
		}
		String refUid = curMailInfo.getUid();
		if (!refUid.equals(""))
		{
			Intent intent = getIntent();
			_refBody = intent.getStringExtra("refMailBody");
			_refOldMailView.loadDataWithBaseURL("", _refBody, "text/html", "utf-8", null);
		}
		
		if(curMailInfo!=null)
		{
		_hasAttachFlag=curMailInfo.hasAttachment();
			if(_hasAttachFlag)
			{
				
	//			_refAttachIndex=intent.getIntExtra("refAttachIndex", 0);
	//			_refAttachName=intent.getStringExtra("refMailAttathName");
	//			
	//			AttachmentInfo attInfo=new AttachmentInfo();
	//			attInfo.index=_refAttachIndex;
	//			attInfo.fileName=_refAttachName;
	//			_attachments.add(attInfo);
				_attachListView.setAdapter(new AttachmentAdapter(this, curMailInfo.getAttachments()));
				_attachListView.setVisibility(View.VISIBLE);
				setAttachmentHeight();
			}
		}
	}
    private void setAttachmentHeight()
    {
    	AttachmentAdapter listAdapter = (AttachmentAdapter)_attachListView.getAdapter();   
        if (listAdapter == null) {  
            return;  
        }  
  
        int totalHeight = 0;  
        for (int i = 0; i < listAdapter.getCount(); i++) {  
            View listItem = listAdapter.getView(i, null, _attachListView);  
            listItem.setLayoutParams(new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
            listItem.measure(0, 0);  
            totalHeight += listItem.getMeasuredHeight();  
        }  
  
        ViewGroup.LayoutParams params = _attachListView.getLayoutParams();  
        params.height = totalHeight + (_attachListView.getDividerHeight() * (listAdapter.getCount() - 1));  
        ((ViewGroup.MarginLayoutParams)params).setMargins(10, 10, 10, 10);
        _attachListView.setLayoutParams(params);  
    }
	private String html2text(String html)
	{
		// remove the head tag. the js will always included in this tag.
		int headBegin = html.indexOf("<head>");
		int headEnd = html.indexOf("</head>");
		String tmpHtm = html;
		if (headBegin >= 0 && headEnd >= 0)// matched
		{
			String first = html.substring(0, headBegin);
			String end = html.substring(headEnd + 7);
			tmpHtm = first + end;
		}
		// String tmpHtm = html.replaceAll("<head>.*</head>", "");
		String plainTxt = Html.fromHtml(tmpHtm).toString();
		return plainTxt;
	}

	@Override
	public void onClick(View v)
	{
		switch (v.getId())
		{
		case R.id.toBtn:
			clickedButton = 1;
			onToButtonClicked();
			break;
		case R.id.ccBtn:
			clickedButton = 2;
			onToButtonClicked();
			break;
		case R.id.bccBtn:
			clickedButton = 3;
			onToButtonClicked();
			break;
		case R.id.cp_sendBtn:
			curMailInfo.setFolder(FolderNames.FOLDER_SENT);
			onSendBtnClicked();
			break;
		case R.id.cp_saveBtn:
		{
			contentStateModif = false;
			updateMailInfo();
			curMailInfo.setFolder(FolderNames.FOLDER_DRAFT);
			NewDbHelper.getInstance().saveOutMail(curMailInfo);
			Resources res = getResources();
			if (curMailInfo.getUidx() < 0)
			{
				Log.d(LOGTAG, "Save mail failed" + "");
				DialogUtils.showMsgBox(this, res.getString(R.string.cp_saveMailFail), res.getString(R.string.error));
			}
			else
			{
				
				Log.d(LOGTAG, "Save mail sucessfully" + "");
				Toast.makeText(this, res.getString(R.string.cp_saveMailSuccess), Toast.LENGTH_LONG).show();
			}
			break;
		}
		case R.id.cp_cancelBtn:
			onCancelBtnClicked();
			break;
		case R.id.cp_respondInlineBtn:
		{
			// append referent body text to _contentText,then hide the related
			// widgets.
			_contentText.append(html2text(_refBody));
			_addRefBox.setChecked(false);
			_refMailLayout.setVisibility(View.GONE);
			_refOldMailView.setVisibility(View.GONE);
		}
			break;
		default:
			break;
		}
	}
	public void selectViewMode()
	{
		android.content.DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which)
			{
				switch (which)
				{
				case 0:
				{
					cameraClieded();
				}
					break;
				case 1:
					recordClicked();
					break;
				case 2:
					addAttachmentBtnClicked();
					break;
				}

			}

		};
        Resources res=getResources();
		String[] menu = {res.getString(R.string.atta_Photo_Mode) , res.getString(R.string.atta_Record_Mode) , res.getString(R.string.atta_file_Mode)};
		new AlertDialog.Builder(Composer.this).setTitle(res.getString(R.string.atta_Choose_Mode))
				.setItems(menu, listener).show();
	}
	
	private void addAttachment(String fileName)// including file path
	{
		if (fileName == null || fileName.equals(""))
			return;
		File attFile = new File(fileName);
		if (!attFile.exists())
		{
			Toast.makeText(this, fileName + " not exists.", Toast.LENGTH_SHORT)
					.show();
			return;
		}
		try
		{
			// FileInputStream fi = new FileInputStream(attFile);
			AttachmentInfo attaInfo = new AttachmentInfo(curMailInfo);
			attaInfo.fileName = attFile.getName();
			// Log.d(fileName,
			// "File.length()="+attFile.length()+"; FileInputStream.available():"+fi.available());
			attaInfo.size = getHumanSize(attFile.length());// fi.available());
			attaInfo.fullFilePath = fileName;
			curMailInfo.addAttachInfo(attaInfo);
			updateListView();
		}
		catch (Exception e)
		{
			// TODO: handle exception
			e.printStackTrace();
		}
	}
	static public String getHumanSize(long value)
	{
		double sizeF = value;
		String unit = "B";
		if (value > (1 << 30))
		{
			sizeF = sizeF / (1 << 30);
			unit = "GB";
		}
		else if (sizeF > (1 << 20))
		{
			sizeF = sizeF / (1 << 20);
			unit = "MB";
		}
		else if (sizeF > 1024)
		{
			sizeF = sizeF / (1024.0);
			unit = "KB";
		}
		NumberFormat nFormat = NumberFormat.getInstance();
		nFormat.setMaximumFractionDigits(1);
		return (nFormat.format(sizeF) + unit);
	}
	private void updateListView()
	{
		
		_attachListView.setAdapter(new AttachmentAdapter(this, curMailInfo.getAttachments()));
		((AttachmentAdapter) _attachListView.getAdapter())
				.notifyDataSetChanged();
		_attachListView.setVisibility(View.VISIBLE);
		// clear selectionattachListView
		selectedIdx = -1;
		int childCount = _attachListView.getChildCount();
		int backColor = getResources().getColor(R.color.white);
		for (int i = 1; i < childCount; i++)
			_attachListView.getChildAt(i).setBackgroundColor(backColor);
		setAttachmentHeight();
		if(curMailInfo.getAttachments().size()<=0)
		{
			_attachListView.setVisibility(View.GONE);
		}
	}
	public void delAttachment(int attachItemIndex)
	{
		selectedIdx=attachItemIndex;
		if(selectedIdx<0)
			return;
		curMailInfo.getAttachments().remove(selectedIdx);
		updateListView();
	}
	private boolean isSdCardAvailable()
	{
		Resources res = getResources();
		String state = Environment.getExternalStorageState();
		if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))
		{
			MessageBox.show(this, res.getString(R.string.atta_sdcardReadOnly),
							res.getString(R.string.error));
			return false;
		}
		else if (!Environment.MEDIA_MOUNTED.equals(state))
		{
			MessageBox.show(this,
							res.getString(R.string.atta_sdcardNotAvailable),
							res.getString(R.string.error));
			return false;
		}
		return true;
	}

	private void addAttachmentBtnClicked()
	{
		if (!isSdCardAvailable())
			return;
		Intent intent = new Intent(this, FileBrowser.class);
		startActivityForResult(intent, REQ_FILE_BROWSER);
	}
	private void cameraClieded()
	{


		Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
		cameraFileName = createUniqeFile();

		/****************/
		Uri uri = Uri.fromFile(new File(cameraFileName));
		intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
		startActivityForResult(intent, REQ_TAKE_PICTURE);
	}


	private String createUniqeFile() {
		Calendar cal = Calendar.getInstance();
		Date curDate = cal.getTime();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
		String stem = sdf.format(curDate);
		
		String fileName = stem;
		File out = new File(Environment.getExternalStorageDirectory(),
				fileName + ".png");
		/*****************/
		int i=1;
		while (out.exists())
		{
			fileName = stem + "(" + i + ")";
			out = new File(Environment.getExternalStorageDirectory(),
					fileName + ".png");
			i++;

		}
		try {
			return out.getCanonicalPath();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	private void recordClicked()
	{
		Intent intent = new Intent("android.provider.MediaStore.RECORD_SOUND");

//		 recordFileName = System.currentTimeMillis() + ".3gpp";
//		 File recordOut = new File(Environment.getExternalStorageDirectory(),
//		 recordFileName);
//		 Uri uri = Uri.fromFile(recordOut);
//		 intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);

		startActivityForResult(intent, REQ_SOUND_RECORDER);
	}
	/*
	 * @Override public void onActivityResult(int reqCode, int rstCode, Intent
	 * intent) { switch (reqCode) { case R.layout.attachment_viewer:// account
	 * wizard { // DialogUtils.showMsgBox(this,"activity result", "test"); // if
	 * (rstCode != Dialog.BUTTON_POSITIVE) // return; } break; default: break; }
	 * }
	 */

	// @Override
	// public boolean onMenuItemSelected(int featureId, MenuItem item)
	// {
	// switch(item.getItemId())
	// {
	// case R.id.sendMailMenu:
	// toBtnClicked = true;
	// onToButtonClicked();
	// break;
	// case R.id.addToCcMailMenu:
	// toBtnClicked = false;
	// onToButtonClicked();
	// break;
	// case R.id.addAttacmentMenu:
	// {
	// Intent intent = new Intent(this, AttachmentList.class);
	// intent.putExtra("isComposer", true);
	// startActivity(intent);
	// }
	// break;
	// case R.id.cancleMenu:
	// onCancelBtnClicked();
	// break;
	// default:
	// break;
	// }
	// return super.onMenuItemSelected(featureId, item);
	// }

	
	private void onCancelBtnClicked()
	{
		Resources res = getResources();
		try
		{
			if (_contentText.getText().toString().equals("")
				|| DialogUtils.showModalMsgBox(	this, res.getString(R.string.cp_discardMailMsg),
												res.getString(R.string.cp_discardMail),
												EnumSet.of(DialogUtils.ButtonFlags.Yes, DialogUtils.ButtonFlags.No)) == DialogResult.OK)
			{
				finish();
			}
		}
		catch (Exception e)
		{
			// TODO: handle exception
			e.printStackTrace();
		}
	}

	private DataPacket createDataPacket()
	{
		if (dp == null)
			dp = new DataPacket();
		// dp.packetType = _mailType;
		// in server there's no reply all.

		// based on OutMailInfo
		switch (curMailInfo.getMailType())
		{
		case COMPOSER_REPLY:
			dp.packetType = DataPacket.REPLYMAIL_TYPE;
			break;
		case COMPOSER_FORWARDMAIL:
			dp.packetType = DataPacket.FORWARDMAIL_TYPE;
			break;
		default:
			dp.packetType = DataPacket.NEWMAIL_TYPE;
			break;
		}
		dp.quoteOld = (curMailInfo.getRefBodyFlag() == OutMailInfo.REFMAIL_YES);
		dp.refMailId = curMailInfo.getUid();
		dp.refMailFolder = curMailInfo.getRefFolder();
		dp.forwardAttach = _includeAttaBox.isChecked();
		dp.toList = curMailInfo.getTo();
		dp.ccList = curMailInfo.getCc();
		dp.bccList = curMailInfo.getBc();
		dp.subject = curMailInfo.getSubject();
		dp.bodyText = curMailInfo.getBody();
		dp.attachments = curMailInfo.getAttachments();
		return dp;
	}

	private void updateMailInfo()// based on widgets
	{
		if (!_addRefBox.isChecked())
			curMailInfo.setRefBodyFlag(OutMailInfo.REFMAIL_NO);
		else if (_addRefBox.isShown())//
			curMailInfo.setRefBodyFlag(OutMailInfo.REFMAIL_YES);
		else
			curMailInfo.setRefBodyFlag(OutMailInfo.REFMAIL_RESPOND_INLINE);

		String[] toList = _toEditText.getText().toString().split(";");
		String tos = toList[0];
		for (int i = 1; i < toList.length; i++)
			tos += ";" + toList[i];
		curMailInfo.setTo(tos);

		String[] ccList = _ccEditText.getText().toString().split(";");
		String ccs = ccList[0];
		for (int i = 1; i < ccList.length; i++)
			ccs += ";" + ccList[i];
		curMailInfo.setCc(ccs);

		String[] bccList = _bccEditText.getText().toString().split(";");
		String bccs = bccList[0];
		for (int i = 1; i < bccList.length; i++)
			bccs += ";" + bccList[i];
		curMailInfo.setBc(bccs);

		curMailInfo.setBody(_contentText.getText().toString());
		curMailInfo.setSubject(_subjectText.getText().toString());

		int fromIdx = _fromSpinner.getSelectedItemPosition();
		curMailInfo.setAccountId(AccountManager.getByIndex(fromIdx).id);
	}

	private void onSendBtnClicked()
	{
		if (!checkAddressValid())
			return;
		/* start add */
		String toEditEmailString = _toEditText.getText().toString() + ";" + _ccEditText.getText().toString() + ";"
									+ _bccEditText.getText().toString();

		ArrayList<EmailAddress> emailAddBookArray = AddressBook.getEmailAddresses();
		needSendMail=false;
		phoneNumbers.clear();
		phoneInEditText.clear();
		String[] toAddList = toEditEmailString.split(";");
		if (!toEditEmailString.equals(""))
		{
			doReturn: for (int i = 0; i < toAddList.length; i++)
			{
				String toList = toAddList[i];
				if (Utils.isEmpty(toList.trim()))
					continue;
				EmailAddress newMailAddr = new EmailAddress(toList);
				if(newMailAddr!=null)
				{
					for (int j = 0; j < emailAddBookArray.size(); j++)
					{
						EmailAddress emailAddress = emailAddBookArray.get(j);
	
						if (emailAddress.equals(newMailAddr))
						{
							needSendMail=true;
							continue doReturn;
						}
					}
				}
				String phoneNumber=getPhoneNumber(toList);
				if(phoneNumber!=null)
				{
					phoneInEditText.add(toList);
					phoneNumbers.add(phoneNumber);
					
				}
				else
				{
					needSendMail=true;
					emailAddBookArray.add(newMailAddr);
					NewDbHelper.getInstance().addEmailAddress(newMailAddr);
				}
			}
		}

		String title = _subjectText.getText().toString();

		Resources res = getResources();
		if (title.equals(""))
		{
			try
			{
				if (DialogUtils.showModalMsgBox(this, res.getString(R.string.cp_emptySubjectMsg),
												res.getString(R.string.cp_emptySubject),
												EnumSet.of(DialogUtils.ButtonFlags.Yes, DialogUtils.ButtonFlags.No)) == DialogResult.CANCEL)
					return;
			}
			catch (Exception e)
			{
				// TODO: handle exception
				e.printStackTrace();
			}
		}
		if(phoneNumbers.size()!=0)
		{
			if (DialogUtils.showModalMsgBox(this, getResources().getString(R.string.mms),
											getResources().getString(R.string.mms_info), EnumSet
													.of(DialogUtils.ButtonFlags.Yes,
														DialogUtils.ButtonFlags.No)) == DialogResult.YES)
			{
				if(dataDisconnected())
				{
					if (DialogUtils
							.showModalMsgBox(	this,
												getResources().getString(R.string.open_setting),
												getResources().getString(R.string.setting_info),
												EnumSet.of(	DialogUtils.ButtonFlags.Yes,
															DialogUtils.ButtonFlags.No)) == DialogResult.YES)
					{
						Intent intent = new Intent("/");
						ComponentName cm = new ComponentName("com.android.settings",
																"com.android.settings.WirelessSettings");
						intent.setComponent(cm);
						intent.setAction("android.intent.action.VIEW");
						startActivityForResult(intent,REQ_SEND_MMS);
					}
				}
				else
				{
					sendMMS();
					sendMail();
				}
			}
		}
		else
		{
			sendMail();
		}
	}
	private void sendMail()
	{
		if (needSendMail)
		{
			// send mail;
			updateMailInfo();
			createDataPacket();
			// save draft before send the mail;
			// now only support current account id.
			int curIdx = _fromSpinner.getSelectedItemPosition();
			Account account = AccountManager.getByIndex(curIdx);
	
			
			
			// notification.defaults = Notification.DEFAULT_ALL;
			try
			{
				String sid = MyApp.getAgent(account).getSessionId(true, true, true);
				if (Utils.isEmpty(sid))
					return;
				/*
				 * Notice on
				 */
				Notification notification = null;
				RemoteViews contentView = null;
				mNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notification = new Notification(R.anim.notification_fram_anim, getResources().getString(R.string.wait_sending), System.currentTimeMillis());
	//			contentView = new RemoteViews(getPackageName(), R.layout.custom_notification);
				contentView = new RemoteViews(getPackageName(), R.layout.sent_notification);
				
				// contentView.setProgressBar(R.id.noti_progressView, 10, 0, true);
				contentView.setImageViewResource(R.id.custom_notifi_image, R.drawable.sign_up_icon);
				contentView.setTextViewText(R.id.custom_notifi_title, getResources().getString(R.string.wait_sending));
				notification.contentView = contentView;
				notification.flags |= Notification.FLAG_AUTO_CANCEL;
				Intent notificationIntent = new Intent(Intent.ACTION_MAIN);
				notificationIntent.addCategory(Intent.CATEGORY_LAUNCHER);
				notificationIntent.setClass(MyApp.instance(), GlobalInBoxActivity.class);
				PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);
				notification.contentIntent = contentIntent;
				notification.contentView.setProgressBar(R.id.noti_progressView, 100, 0, true);
				mNotificationManager.notify(CUSTOM_NOTIFICATION_VIEW_ID, notification);
				dp.toList=getAddrs(_toEditText.getText().toString());
				dp.ccList=getAddrs(_ccEditText.getText().toString());
				dp.bccList=getAddrs(_bccEditText.getText().toString());
				new SendMailTask(account, sid).execute(dp);
				finish();
			}
			catch (Exception e)
			{
				// TODO: handle exception
				e.printStackTrace();
			}
		}
		
	}

	class SendMailTask extends AsyncTask<DataPacket, Integer, String>
	{

		private Resources res = MyApp.instance().getResources();
		// private ProgressDialog prgDialog = new ProgressDialog(Composer.this);
		private String sid;

		private MailInfo refMailInfo=MyApp.curMailInfo;
		public SendMailTask(Account a, String sessionId)
		{
			sid = sessionId;
		}

		@Override
		protected String doInBackground(DataPacket... dPackets)
		{
			DataPacket dp = dPackets[0];
			try
			{
				MultipartEntity reqEntity = new MultipartEntity(HttpMultipartMode.STRICT, null,
																Charset.forName("UTF-8"));

				// load attachment information
				// int attaCount = _attachments.size();
				// for (int i = 0; i < attaCount; i++)
				// {
				// AttachmentInfo att = _attachments.get(i);
				// if (att.index != AttachmentInfo.LOCAL_ATTACH_INDEX)
				// continue;
				// File inputFile = new File(att.fullFilePath);
				// FileInputStream finput = new FileInputStream(inputFile);
				// byte[] barry = new byte[(int) inputFile.length()];
				// finput.read(barry);
				//
				// byte[] temp = Base64.encodeBase64(barry, true);
				// att.body = new String(temp);
				// // Log.d("Encoding result",
				// // "Length:"+att.body.length()+"  contents:"+new
				// // String(att.body));
				// finput.close();
				// }
				Serializer serializer = new Persister();
				// Persister serializer = new Persister();
				ByteArrayOutputStream out = new ByteArrayOutputStream(100000);
				// FileOutputStream xmlFile = new
				// FileOutputStream("/mnt/sdcard/test.xml");
				// serializer.write(dp, xmlFile,"UTF-8");
				serializer.write(dp, out);// ,"UTF-8");
				byte[] outBytes = out.toByteArray();
                   
				ByteArrayBody bin = new ByteArrayBody(outBytes, "text/_xml_", "__thebody.__");
				reqEntity.addPart("bin", bin);
				int attaCount = curMailInfo.getAttachments().size();
				for (int i = 0; i < attaCount; i++)
				{
					AttachmentInfo att = curMailInfo.getAttachment(i);
					if (att.index != AttachmentInfo.LOCAL_ATTACH_INDEX)
						continue;
					File inputFile = new File(att.fullFilePath);
					FileBody body = new FileBody(inputFile);
					reqEntity.addPart(att.fullFilePath, body);
				}

				HttpPost p = new HttpPost(ServerAgent.getUrlBase() + "/SendMail?sid=" + java.net.URLEncoder.encode(sid));

				Log.d(LOGTAG, "byte output" + "out.size():" + out.size() + ";;;out.toByteArray:" + outBytes.length);

				p.setEntity(reqEntity);

				HttpParams params = new BasicHttpParams();
				HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
				HttpProtocolParams.setContentCharset(params, "UTF-8");
				HttpProtocolParams.setUseExpectContinue(params, true);
				HttpProtocolParams.setUserAgent(params, "CloudyMail 1.0");

				// Make pool
				ConnPerRoute connPerRoute = new ConnPerRouteBean(12);
				ConnManagerParams.setMaxConnectionsPerRoute(params, connPerRoute);
				ConnManagerParams.setMaxTotalConnections(params, 20);

				// Set timeout
				HttpConnectionParams.setStaleCheckingEnabled(params, false);
				HttpConnectionParams.setConnectionTimeout(params, 20 * 1000); // 20
																				// seconds
																				// to
																				// wait
																				// connection
				HttpConnectionParams.setSoTimeout(params, 10 * 60 * 1000); // 10
																			// minutes
																			// to
																			// wait
																			// response
																			// data
				HttpConnectionParams.setSocketBufferSize(params, 8192);

				// Some client params
				HttpClientParams.setRedirecting(params, false);

				// Register http/s shemas!
				SchemeRegistry schReg = new SchemeRegistry();
				schReg.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
				try
				{
					schReg.register(new Scheme("https", TrustAllSSLSocketFactory.getDefault(), 443));
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}

				ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params, schReg);
				DefaultHttpClient client = new DefaultHttpClient(conMgr, params);

				// method 1, for cookie enable
				// CookieHandler h = CookieHandler.getDefault();
				// sClient.getParams().setParameter(
				// ClientPNames.COOKIE_POLICY, CookiePolicy.RFC_2965);
				// sClient.getCookieSpecs().register("def", new
				// RFC2965SpecFactory());

				// method 2
				CookieSpecFactory csf = new CookieSpecFactory() {
					@Override
					public CookieSpec newInstance(HttpParams params)
					{
						return new BrowserCompatSpec() {
							@Override
							public boolean match(Cookie cookie, org.apache.http.cookie.CookieOrigin origin)
							{
								boolean b = super.match(cookie, origin);
								b = cookie.getDomain().equals(origin.getHost());
								return b;
							}
						};
					}
				};

				client.getCookieSpecs().register("easy", csf);
				client.getParams().setParameter(ClientPNames.COOKIE_POLICY, "easy");
				HttpResponse rsp = client.execute(p);
				Result rst = new Result(rsp.getEntity().getContent());
				if (rst.isSuccessed())
					return "";
				else
					return rst.failReason;
			}
			catch (Exception e)
			{
				e.printStackTrace();
				return e.getMessage();
			}
		}

		@Override
		protected void onPreExecute()
		{
			// save the mail, so user can restore it if there's error during
			// sending
			curMailInfo.setFolder(FolderNames.FOLDER_NOTSENT);
			NewDbHelper.getInstance().saveOutMail(curMailInfo);
			String msg = res.getString(R.string.inSending) + "\n" + curMailInfo.getSubject();
			Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_LONG).show();
			// prgDialog.setMessage(res.getString(R.string.cp_sendingMail));
			// prgDialog.show();
		}

		@Override
		protected void onProgressUpdate(Integer... progress)
		{
			// setProgressPercent(progress[0]);
		}

		@Override
		protected void onPostExecute(String result)
		{
			// prgDialog.hide();
			// prgDialog.dismiss();
			String msg = null;
			String notifiMsg=null;
			mNotificationManager.cancel(CUSTOM_NOTIFICATION_VIEW_ID);
			Log.d(LOGTAG, "Cancel the notification statue bar");
			if ("".equals(result))
			{
				Log.d(LOGTAG, "Send mail sucessfully" + "");
				msg = "\""+curMailInfo.getSubject()+"\" "+res.getString(R.string.cp_sendSuccess);
				notifiMsg=getResources().getString(R.string.cp_sendSuccess);
				try
				{
					boolean updataMailView=false;
					if((_openType==COMPOSER_REPLYALL||_openType==COMPOSER_REPLY)&&!refMailInfo.hasReply())
					{
						
						refMailInfo.setAttachmentFlag(MailInfo.REPLY|refMailInfo.getAttachmentFlag());
						NewDbHelper.getInstance().setMailAttachment(refMailInfo.getUid(), refMailInfo.getFolder(), refMailInfo.getAttachmentFlag());
						updataMailView=true;
					}
					else if(_openType==COMPOSER_FORWARDMAIL&&!refMailInfo.hasForward())
					{
						refMailInfo.setAttachmentFlag(MailInfo.FORWARD|refMailInfo.getAttachmentFlag());
						NewDbHelper.getInstance().setMailAttachment(refMailInfo.getUid(), refMailInfo.getFolder(), refMailInfo.getAttachmentFlag());
						updataMailView=true;
					}
					if(updataMailView&&MyApp.getCurrentActivity()instanceof InBoxActivity)
					{
						InBoxActivity activity=(InBoxActivity)MyApp.getCurrentActivity();
						activity.updateMail();
					}
				}
				catch (Exception e)
				{
					Utils.logException(e);
				}
				// save the mail to outBox;
				curMailInfo.setFolder(FolderNames.FOLDER_SENT);
				NewDbHelper.getInstance().saveOutMail(curMailInfo);
				Activity activity = MyApp.getCurrentActivity();
				if(activity instanceof OutBoxActivity)
				{
					try
					{
						((OutBoxActivity) activity).updateMail();
					}
					catch (SQLException e)
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
			else
			{
				Log.d(LOGTAG, "Send mail failed:" + result);
				msg = "\""+curMailInfo.getSubject()+"\" "+res.getString(R.string.cp_sendFailure);
				notifiMsg=getResources().getString(R.string.cp_sendFailure);
				curMailInfo.setFolder(FolderNames.FOLDER_NOTSENT);
				NewDbHelper.getInstance().saveOutMail(curMailInfo);
			}

			Notification finishNotification = null;
			RemoteViews finishContentView = null;
			
			finishNotification = new Notification(R.drawable.sign_up_4, curMailInfo.getSubject() + notifiMsg,
													System.currentTimeMillis());
			finishContentView = new RemoteViews(getPackageName(), R.layout.sending_notification);
			// finishContentView.setProgressBar(R.id.noti_progressView, 100,
			// 100, false);
			finishContentView.setImageViewResource(R.id.custom_notifi_image, R.drawable.sign_up_icon);
			finishContentView.setTextViewText(R.id.custom_notifi_title, res.getString(R.string.appName));
			finishContentView.setTextViewText(R.id.custom_notifi_text,msg);
			finishNotification.contentView = finishContentView;

			Intent endNotificationIntent = new Intent(Intent.ACTION_MAIN);
			endNotificationIntent.addCategory(Intent.CATEGORY_LAUNCHER);
			endNotificationIntent.setClass(MyApp.instance(), GlobalInBoxActivity.class);

			PendingIntent endcontentIntent = PendingIntent.getActivity(	MyApp.instance(), 0, endNotificationIntent,
																		0);
			finishNotification.contentIntent = endcontentIntent;
			finishNotification.flags |= Notification.FLAG_AUTO_CANCEL;
			mNotificationManager.notify(FINISH_NOTIFI_ID, finishNotification);
			Toast.makeText(getApplicationContext(), msg, Toast.LENGTH_LONG).show();
		}
	}

	private void onToButtonClicked()
	{
		initAddressBookArray();
		/* test */
		final EditText activeTextBox = clickedButton == 1 ? _toEditText : (clickedButton == 2	? _ccEditText
																								: _bccEditText);
		Utils.ASSERT(activeTextBox != null);
		int m = AddressBook.addressArry.size();
		String toMailAddress = activeTextBox.getText().toString();
		String[] split = toMailAddress.split(";");
		boolean[] checkedItems = new boolean[m];
		final ArrayList<EmailAddress> allAddr = AddressBook.getEmailAddresses();
		for (int i = 0; i < split.length; i++)
		{
			if (split[i].trim().length() == 0)
				continue;

			String addr=split[i].trim();
				
			for (int k = 0; k < checkedItems.length; k++)
			{
				String addressInAddrBook=allAddr.get(k).toString();
				if (addr.equals(addressInAddrBook))
				{
					checkedItems[k] = true;
					break;
				}
			}
		}
		AlertDialog ad = new AlertDialog.Builder(this)
						.setMultiChoiceItems(addressBookArray, checkedItems,
												new DialogInterface.OnMultiChoiceClickListener() {
													// public abstract void
													// onClick
													// (DialogInterface dialog,
													// int
													// which, boolean isChecked)
													public void onClick(DialogInterface dialog, int whichButton,
																	boolean isChecked)
													{
													}
												}

						).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
							public void onClick(DialogInterface dialog, int whichButton)
							{
								// String toString = "";
								String toString="";
								String oldValueString ="";
								SparseBooleanArray checkedState = lv.getCheckedItemPositions();
								for (int i = 0; i < addressBookArray.length; i++)
								{
									
									if (checkedState.get(i))// selected
									{
										if (oldValueString.contains(allAddr.get(i).getAddress()))
											continue;
										toString = lv.getItemAtPosition(i).toString() + ";";
										if (oldValueString.lastIndexOf(";") == oldValueString.length() - 1)
										{
											oldValueString += toString;
										}
										else
										{
											oldValueString += ";" + toString;
										}
										
									}
								}
								activeTextBox.setText(oldValueString);
							}

						}).setNegativeButton(R.string.cancel, null).create();

		ad.setTitle(getResources().getString(	clickedButton == 1	? R.string.cp_selectToAddr
														: (clickedButton == 2	? R.string.cp_selectCcAddr
																				: R.string.cp_selectBccAddr)));
		lv = ad.getListView();

		Builder ad2 = new AlertDialog.Builder(this).setTitle(R.string.cp_whetherAddAddressBook)
						.setIcon(android.R.drawable.ic_dialog_info)
						.setPositiveButton(R.string.cp_immediatelyAdd, new DialogInterface.OnClickListener() {

							@Override
							public void onClick(DialogInterface dialog, int which)
							{

								Intent intent = new Intent(Composer.this, AddressBook.class);
								startActivity(intent);

							}
						}).setNegativeButton(R.string.cp_laterSay, new DialogInterface.OnClickListener() {

							@Override
							public void onClick(DialogInterface dialog, int which)
							{
								return;
							}
						});
		if (allAddr.size() == 0)
		{

			ad2.show();
		}
		else
		{
			ad.show();
		}
	}

	private void initAddressBookArray()
	{
		ArrayList<EmailAddress> addressArry = AddressBook.getEmailAddresses();
		// NewDbHelper.getInstance().loadAddressBook();
		if (addressArry.isEmpty())
			return;
		if (addressBookArray != null && addressBookArray.length == addressArry.size())
		{
			return;
		}

		int len = addressArry.size();
		addressBookArray = new String[len];
		for (int i = 0; i < len; i++)
		{
			EmailAddress ea = addressArry.get(i);
			addressBookArray[i] = ea.toString();
		}
	}

	private void loadAccountsToSpinner()
	{
		int acctCount = AccountManager.getCount();
		// if no account exists, then need create an account at first.
		if (acctCount < 1)
		{
			/*
			 * Intent intent = new Intent(this, MailClient.class);
			 * intent.putExtra(MailClient.CLIENT_OPEN_MODE,
			 * MailClient.OPEN_FROM_COMPOSE); startActivityForResult(intent,
			 * R.layout.main); return;
			 */
			if (AccountManager.getCount() == 0)
			{
				finish();
				return;
			}
		}

		String[] accoutNames = new String[acctCount];
		int curIdx = 0;
		Account curAccount = null;
		if (this.curMailInfo != null && curMailInfo.getAccountId() >= 0)
			curAccount = AccountManager.getAccount(curMailInfo.getAccountId());
		if (curAccount == null)
			curAccount = MyApp.currentAccount;
		if (curAccount == null)
			curAccount = AccountManager.getByIndex(0);
		for (int idx = 0; idx < acctCount; ++idx)
		{
			Account a = AccountManager.getByIndex(idx);
			accoutNames[idx] = a.name;
			if (curAccount.name.equals(a.name))
				curIdx = idx;
		}
		ArrayAdapter<String> spinAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item,
																	accoutNames);
		spinAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);

		_fromSpinner.setAdapter(spinAdapter);
		_fromSpinner.setSelection(curIdx);
	}

	@Override
	public void onActivityResult(int reqCode, int rstCode, Intent intent)
	{
		MyApp.setCurrentActivity(this);
		// create account after MailClient returned.
	  switch(reqCode){
	  case REQ_SEND_MMS:
//	  		if(!dataDisconnected())
//	  		{
//	  			sendMMS();
//	  			sendMail();
//	  		}
	  		break;
	  case R.layout.main:
		{
			if (AccountManager.getCount() == 0)// do not add any accounts,
													// finish this activity.
			{
				finish();
				return;
			}
			initMailInformation();
			loadAccountsToSpinner();
		}
	case REQ_FILE_BROWSER:
	{
		if (rstCode != Dialog.BUTTON_POSITIVE)
			return;
		addAttachment(intent.getStringExtra("selectedFile"));
	}
		break;
	case REQ_TAKE_PICTURE:

		if (rstCode == RESULT_OK)
		{
			// int i=1;
			// Calendar cal = Calendar.getInstance();
			// Date curDate = cal.getTime();
			Intent cj1 = new Intent("com.android.camera.action.CROP");

			try
			{

				cj1.setData(Uri.parse(android.provider.MediaStore.Images.Media.
						insertImage(getContentResolver(),cameraFileName, null, null)));

			}
			catch (FileNotFoundException e)
			{

				e.printStackTrace();

			}

			cj1.putExtra("crop", "true");

			cj1.putExtra("outputX", 384);

			cj1.putExtra("outputY", 256);

			cj1.putExtra("return-data", true);

			startActivityForResult(cj1, REQ_CROP);

			break;

		}

		break;
	case REQ_CROP:
		Bundle extras = intent.getExtras();  
		if(extras != null ) {  
		    Bitmap photo = extras.getParcelable("data");  
		    FileOutputStream stream;
			try {
				stream = new FileOutputStream(cameraFileName);
				photo.compress(Bitmap.CompressFormat.JPEG, 75, stream);
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}  
		      
		        
		}  
		addAttachment(cameraFileName );
		break;
	case REQ_SOUND_RECORDER:
		if (rstCode == RESULT_OK)
		{
			// recordFilePath = "/adcard/audio/note/";
			// folderScan(recordFilePath);
			Cursor audioCursor = managedQuery(	intent.getData(), null,
												null,
												null, null);
			audioCursor.moveToFirst();
			String audioFileName = audioCursor.getString(1);
			audioCursor.close();
			addAttachment(audioFileName);
		}
		break;
	default:
		break;
	  }
	
	}
    @Override
    protected void onNewIntent(Intent intent) 
    {
    	setIntent(intent);
    };

    private boolean checkAddressValid()
	{
		Resources res = getResources();
		String toString = _toEditText.getText().toString();
		String ccString = _ccEditText.getText().toString();
		String bccString = _bccEditText.getText().toString();
		if (Utils.isEmpty(toString) && Utils.isEmpty(ccString) && Utils.isEmpty(bccString))
		{
			DialogUtils.showMsgBox(this, res.getString(R.string.cp_specifyAddr), res.getString(R.string.error));
			return false;
		}
		String[] lists = new String[] { toString, ccString, bccString };
		for (String s : lists)
		{
			if (!Utils.isEmpty(s))
			{
				String[] toList = s.split(";");
				for (int i = 0; i < toList.length; i++)
				{
					String addr = toList[i].trim();
					if (Utils.isEmpty(addr))
						continue;
					if (!doCheckAddressValid(addr)&&getPhoneNumber(addr)==null)
					{
						DialogUtils.showMsgBox(	this, res.getString(R.string.cp_invalidAddr) + toList[i],
												res.getString(R.string.error));
						return false;
					}
				}
			}

		}
		return true;
	}
    /**
     * 
     * @param address
     * @return 
     *
     */
    private String getPhoneNumber(String address)
    {
    	if(address!=null)
    	{
	    	int posLT = address.indexOf('<');
			int posGT = address.indexOf('>');
			if (posLT > 0 && posGT > 0)
			{
				address = address.substring(posLT + 1, posGT).trim();
			}
			else
			{
			    address=address.trim();
			}
			if(AddressBook.patternPhoneNumber(address))
				return address;
    	}
		return null;
    }

	private boolean doCheckAddressValid(String addr)
	{

		EmailAddress address = new EmailAddress(addr);
		return address.isValid();
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event)
	{
		if (keyCode == KeyEvent.KEYCODE_BACK)
		{
			Builder ad = new AlertDialog.Builder(this).setTitle(R.string.cp_isSaveDrafts)
							.setIcon(android.R.drawable.ic_dialog_alert)
							.setPositiveButton(R.string.cp_saveAndExit, new DialogInterface.OnClickListener() {

								@Override
								public void onClick(DialogInterface dialog, int which)
								{

									updateMailInfo();
									curMailInfo.setFolder(FolderNames.FOLDER_DRAFT);
									NewDbHelper.getInstance().saveOutMail(curMailInfo);
									Resources res = getResources();
									if (curMailInfo.getUidx() < 0)
									{
										Log.d(LOGTAG, "Save mail failed" + "");
										DialogUtils.showMsgBox(	Composer.this, res.getString(R.string.cp_saveMailFail),
																res.getString(R.string.error));
									}
									else
									{
										Log.d(LOGTAG, "Save mail sucessfully" + "");
										Toast.makeText(Composer.this, res.getString(R.string.cp_saveMailSuccess),
														Toast.LENGTH_LONG).show();
									}
									finish();
								}
							}).setNeutralButton(R.string.cp_ReturnTo, new DialogInterface.OnClickListener() {

								@Override
								public void onClick(DialogInterface dialog, int which)
								{
									return;
								}
							});
			// contentStateModif=((OutBoxActivity)
			// outBoxActivity).getContentModif();

			if (contentStateModif == false)
			{
				finish();
			}
			else
			{
				ad.show();
			}
			return true;

		}
		return super.onKeyDown(keyCode, event);
	}
    
	@Override
	protected void onResume() {
		super.onResume();
		MobclickAgent.onResume(this);
		if(curMailInfo!=null)
		{
			if (curMailInfo instanceof OutMailInfo && curMailInfo.getUid() != null
				&& !curMailInfo.getUid().trim().equals(""))
			{
				
				_fromSpinner.setEnabled(false);
				_fromSpinner.setBackgroundResource(R.drawable.spinner_sytle_serverset_bg_disabled);
				_fromEditable = false;
			}
			else
			{
				_fromSpinner.setEnabled(true);
				_fromSpinner.setBackgroundResource(R.drawable.spinner_sytle_bg);
				_fromEditable = true;
			}
		}	
		
	}
    
	@Override
	protected void onDestroy()
	{
		super.onDestroy();
//		if(_attachments!=null)
//		{
//			for(int i=0;i<curMailInfo._attachments.size();i++)
//			{
//				curMailInfo._attachments.remove(i);
//			}
//		}
		setAttachmentHeight();
	
	}

	private void sendMMS(MMSInfo mms, final MMSSender sender)
	{
		final MMSInfo mmsInfo = mms;
		final List<String> list = sender.getSimMNC(Composer.this);
		final Handler myHandler = new Handler();
		Thread t = new Thread(new Runnable() {
			@Override
			public void run()
			{
				// 因为在切换apn过程中需要一定时间，所以需要加上一个重试操作
				int retry = 0;
				do
				{
					Log.d("发送彩信", "第" + (retry + 1)+"次发彩信");
					try
					{
						if (sender.sendMMS(list, Composer.this, mmsInfo.getMMSBytes()))
						{
							myHandler.post(new Runnable() {

								@Override
								public void run()
								{
									Toast.makeText(getApplicationContext(), "彩信发送成功！", Toast.LENGTH_LONG)
											.show();
								}
							});
							return;
						}
						retry++;
						Thread.sleep(2000);
					}
					catch (Exception e)
					{
						e.printStackTrace();
					}
				} while (retry < 5);
				myHandler.post(new Runnable() {
					@Override
					public void run()
					{
						Toast.makeText(getApplicationContext(), "彩信发送失败！", Toast.LENGTH_LONG).show();
					}
				});
			}
		});
		t.start();
	}
    private void deletePhoneInfo(ArrayList<String> phoneInEditText)
    {
    	// 删除edittext中的电话号码信息
		for (int i = 0; i < phoneInEditText.size(); i++)
		{
			String phone = phoneInEditText.get(i);
			if (!Utils.isEmpty(_toEditText.getText().toString()))
			{
				String old_toString = _toEditText.getText().toString();
				if (old_toString.contains(phone))
				{

					int startPos = old_toString.indexOf(phone);
					int endPos = startPos + phone.length();
					if (endPos < old_toString.length()
						&& old_toString.charAt(endPos) == ';')
						endPos += 1;
					StringBuffer old = new StringBuffer(old_toString);
					StringBuffer to = old.delete(startPos, endPos);
					_toEditText.setText(to);
				}
			}
			if (!Utils.isEmpty(_ccEditText.getText().toString()))
			{
				String old_ccString = _ccEditText.getText().toString();
				if (old_ccString.contains(phone))
				{
					int startPos = old_ccString.indexOf(phone);
					int endPos = startPos + phone.length();
					if (endPos < old_ccString.length()
						&& old_ccString.charAt(endPos) == ';')
						endPos += 1;
					StringBuffer old = new StringBuffer(old_ccString);
					StringBuffer to = old.delete(startPos, endPos);
					_ccEditText.setText(to);
				}
			}
			if (!Utils.isEmpty(_bccEditText.getText().toString()))
			{
				String old_bccString = _bccEditText.getText().toString();
				if (old_bccString.contains(phone))
				{
					int startPos = old_bccString.indexOf(phone);
					int endPos = startPos + phone.length();
					if (endPos < old_bccString.length()
						&& old_bccString.charAt(endPos) == ';')
						endPos += 1;
					StringBuffer old = new StringBuffer(old_bccString);
					StringBuffer to = old.delete(startPos, endPos);
					_bccEditText.setText(to);
				}
			}
		}
	}
   private void sendMMS()
   {
	   MMSSender sender = new MMSSender();
	   sender.shouldChangeApn(Composer.this);
	   ConnectivityManager conManager = (ConnectivityManager) this
				.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo info = conManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
		String currentAPN = info.getExtraInfo();
		conManager.startUsingNetworkFeature(ConnectivityManager.TYPE_MOBILE, "mms");
		currentAPN = info.getExtraInfo();
		// 只有CMWAP才能发送彩信
		if ("cmwap".equals(currentAPN) || "3gwap".equals(currentAPN)
			|| "uniwap".equals(currentAPN) || "ctwap".equals(currentAPN))
		{
			String bodyText = _contentText.getText().toString();
			StringBuffer phone = new StringBuffer();
			for (String phoneNum : phoneNumbers)
			{

				phone.append(phoneNum + ";");

			}
			if (phone.length() != 0)
				phone.deleteCharAt(phone.lastIndexOf(";"));
			MMSInfo mms = new MMSInfo(this, phone.toString());// 发送的手机号
			mms.setSubject(_subjectText.getText().toString());
			mms.addPart("text", bodyText);
			if (curMailInfo.hasNormalAttachment())
			{
				for (int i = 0; i < curMailInfo.getAttachments().size(); i++)
				{
					AttachmentInfo attach = curMailInfo.getAttachments().get(i);
					if (attach.fileName.endsWith(".png")
						|| attach.fileName.endsWith(".jpg"))
						mms.addPart("image", attach.fullFilePath);
					else if (attach.fileName.endsWith(".amr"))
						mms.addPart("audio", attach.fullFilePath);
				}
			}
			sendMMS(mms,sender);
		}
   }
   private boolean dataDisconnected()
   {
	   TelephonyManager telephonyManager = (TelephonyManager) this
				.getSystemService(Context.TELEPHONY_SERVICE);
	   return telephonyManager.getDataState() == TelephonyManager.DATA_DISCONNECTED;
   }
	private String getAddrs(String toEditTextString)
	{
		String[] toAddrs = toEditTextString.split(";");
		StringBuffer toAddrString =new StringBuffer();
		for (int i = 0; i < toAddrs.length; i++)
			if (doCheckAddressValid(toAddrs[i]))
				toAddrString.append(toAddrs[i]+";");
		if(toAddrString.length()!=0)
			toAddrString.deleteCharAt(toAddrString.lastIndexOf(";"));
		return toAddrString.toString();
		
	}
}
package mobi.cloudymail.mailclient;

import android.app.Activity;
import android.util.DisplayMetrics;

public class Configure{
	public static boolean isMove=false;
	public static boolean isChangingPage=false;
	public static boolean isDelDark = false;
	public static int screenHeight=0;
	public static int screenWidth=0;
	public static float screenDensity=0;
	
	public static int curentPage=0;
	public static int countPages=1;
	public static int removeItem=0;
	
	public static void init(Activity context) {
		if(screenDensity==0||screenWidth==0||screenHeight==0){
			DisplayMetrics dm = new DisplayMetrics();
			context.getWindowManager().getDefaultDisplay().getMetrics(dm);
			Configure.screenDensity = dm.density;
			Configure.screenHeight = dm.heightPixels;
			Configure.screenWidth = dm.widthPixels;
		}
		curentPage=0;countPages=1;
	}

	public int[] ret(int[] intArray) {
		int size = intArray.length;
		for (int i =size - 1; i >= 0; i--)
			for (int j = 0; j < i; j++)
				if (intArray[j] > intArray[j + 1]) {
					int t = intArray[j];
					intArray[j] = intArray[j + 1];
					intArray[j + 1] = t;
				}
		return intArray;
	}
}
package mobi.cloudymail.mailclient;

import android.content.Context;
import android.graphics.Camera;
import android.graphics.Matrix;
import android.util.AttributeSet;
import android.view.View;
import android.view.animation.Transformation;
import android.widget.Gallery;
import android.widget.ImageView;

//宸卞涔Gallery
public class CoverFlow extends Gallery {

	private Camera mCamera = new Camera();
	private int mMaxRotationAngle = 50;
	private int mMaxZoom = -500;
	private int mCoveflowCenter;
	private boolean mAlphaMode = true;
	private boolean mCircleMode = false;

	public CoverFlow(Context context) {
		super(context);
		this.setStaticTransformationsEnabled(true);
	}

	public CoverFlow(Context context, AttributeSet attrs) {
		super(context, attrs);
		this.setStaticTransformationsEnabled(true);
	}

	public CoverFlow(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);
		this.setStaticTransformationsEnabled(true);
	}

	public int getMaxRotationAngle() {
		return mMaxRotationAngle;
	}

	public void setMaxRotationAngle(int maxRotationAngle) {
		mMaxRotationAngle = maxRotationAngle;
	}

	public boolean getCircleMode() {
		return mCircleMode;
	}

	public void setCircleMode(boolean isCircle) {
		mCircleMode = isCircle;
	}

	public boolean getAlphaMode() {
		return mAlphaMode;
	}

	public void setAlphaMode(boolean isAlpha) {
		mAlphaMode = isAlpha;
	}

	public int getMaxZoom() {
		return mMaxZoom;
	}

	public void setMaxZoom(int maxZoom) {
		mMaxZoom = maxZoom;
	}

	private int getCenterOfCoverflow() {
		return (getWidth() - getPaddingLeft() - getPaddingRight()) / 2
				+ getPaddingLeft();
	}

	private static int getCenterOfView(View view) {
		return view.getLeft() + view.getWidth() / 2;
	}

	// Garray规 锛浜х灞惧ぇ
	@Override
	protected boolean getChildStaticTransformation(View child, Transformation t) {
		final int childCenter = getCenterOfView(child);
		final int childWidth = child.getWidth();
		int rotationAngle = 0;
		t.clear();
		t.setTransformationType(Transformation.TYPE_MATRIX);
		if (childCenter == mCoveflowCenter) {
			transformImageBitmap((ImageView) child, t, 0, 0);
		} else {
			rotationAngle = (int) (((float) (mCoveflowCenter - childCenter) / childWidth) * mMaxRotationAngle);
//			System.out.println("recanglenum:"
//					+ Math.floor((mCoveflowCenter - childCenter) / childWidth));
			if (Math.abs(rotationAngle) > mMaxRotationAngle) {
				rotationAngle = (rotationAngle < 0) ? -mMaxRotationAngle
						: mMaxRotationAngle;
			}
			transformImageBitmap(
					(ImageView) child,
					t,
					rotationAngle,
					(int) Math.floor((mCoveflowCenter - childCenter)
							/ (childWidth == 0 ? 1 : childWidth)));
		}
		return true;
	}

	/**
	 * This is called during layout when the size of this view has changed. If
	 * you were just added to the view hierarchy, you're called with the old
	 * values of 0.
	 * 
	 * @param w
	 *            Current width of this view.
	 * @param h
	 *            Current height of this view.
	 * @param oldw
	 *            Old width of this view.
	 * @param oldh
	 *            Old height of this view.
	 */
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
		mCoveflowCenter = getCenterOfCoverflow();
		super.onSizeChanged(w, h, oldw, oldh);
	}

	/**
	 * Transform the Image Bitmap by the Angle passed
	 * 
	 * @param imageView
	 *            ImageView the ImageView whose bitmap we want to rotate
	 * @param t
	 *            transformation
	 * @param rotationAngle
	 *            the Angle by which to rotate the Bitmap
	 */
	private void transformImageBitmap(ImageView child, Transformation t,
			int rotationAngle, int d) {
		mCamera.save();
		final Matrix imageMatrix = t.getMatrix();
		final int imageHeight = child.getLayoutParams().height;
		final int imageWidth = child.getLayoutParams().width;
		final int rotation = Math.abs(rotationAngle);
		mCamera.translate(0.0f, 0.0f, 100.0f);
		// As the angle of the view gets less, zoom in
		if (rotation <= mMaxRotationAngle) {
			float zoomAmount = (float) (mMaxZoom + (rotation * 1.5));
			mCamera.translate(0.0f, 0.0f, zoomAmount);
			if (mCircleMode) {
				if (rotation < 40)
					mCamera.translate(0.0f, 155, 0.0f);
				else
					mCamera.translate(0.0f, (255 - rotation * 2.5f), 0.0f);
			}
			if (mAlphaMode) {
				((ImageView) (child)).setAlpha((int) (255 - rotation * 2.5));
			}
		}
		mCamera.rotateY(rotationAngle);
		mCamera.getMatrix(imageMatrix);

		imageMatrix.preTranslate(-(imageWidth / 2), -(imageHeight / 2));
		imageMatrix.postTranslate((imageWidth / 2), (imageHeight / 2));
		mCamera.restore();
	}
}
package mobi.cloudymail.mailclient;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import mobi.cloudymail.data.InMailInfo;
import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.data.OutMailInfo;
import mobi.cloudymail.util.NewDbHelper;
import android.content.res.Resources;
import android.database.Cursor;
import android.os.Bundle;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.Button;

public class DeleteBoxActivity extends OutBoxActivity
{
	private int _inMaildelNum=0;
	private int _outMailDelNum = 0;
	private Button _recoverMailBtn=null;
	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		Resources res = getResources();
		_delMailBtn.setText(res.getString(R.string.deleteForever));
		_recoverMailBtn = (Button)findViewById(R.id.recoverMailBtn);
		_recoverMailBtn.setVisibility(View.VISIBLE);
		_recoverMailBtn.setOnClickListener(this);
		updateMailView();
	}
	
	@Override
	public void onClick(View v)
	{
		if (v.getId() == R.id.recoverMailBtn)
		{
			//set back to state NEW
			updateMailStatus(MailStatus.MAIL_NEW);
		}
		else
			super.onClick(v);
	}
	
	@Override
	protected void openMail(MailInfo mailInfo)
	{//do nothing for deleted mail.
	}
	
	@Override
	protected boolean doCreateOptionsMenu(Menu menu)
	{
		//hide sort menu item, we do not want to sort the deleted mails.
		//we sort it fixedly, 'in' mails first and 'out' mails below.
		MenuItem sortItem = menu.findItem(R.id.sort);
		sortItem.setVisible(false);
		return super.doCreateOptionsMenu(menu);
	}
	
	//get deleted mails from 'mail' and 'outBox'
	public static int getDelMailCount(int accountId)
	{
		int count= getInDelMailCount(accountId);
		count += getOutDelMailCount(accountId);
		return count;
	}
	
	private static int getInDelMailCount(int accountId)
	{
		return NewDbHelper.getInstance().getInMailCount(accountId,"",new int[]{MailStatus.MAIL_LOCAL_DELETED},false);
	}
	
	private static int getOutDelMailCount(int accountId)
	{
		return NewDbHelper.getInstance().getOutMailCount(accountId,"", new int[]{MailStatus.MAIL_LOCAL_DELETED});
	}
	
	@Override
	protected int getTotalMailCount(boolean query)
	{
		if (query)
		{
			int curAccountId = getCurrentAccountId();
			_inMaildelNum= getInDelMailCount(curAccountId);
			_outMailDelNum = getOutDelMailCount(curAccountId);
			totalMailCount = _inMaildelNum+_outMailDelNum;
		}
		return totalMailCount;
	}
	
	@Override
	protected Cursor doQueryMail(int index)
	{
		NewDbHelper db = NewDbHelper.getInstance();
		if(index < _inMaildelNum)//'in' mail
		{
			return db.getDelInMails(getCurrentAccountId(),
						Math.min(mailCountPerScreen, _inMaildelNum),
						index,floatingSearch);
		}
		else
			return db.getDelOutMails(getCurrentAccountId(),
		                                             Math.min(mailCountPerScreen, _outMailDelNum),
		                                             index-_inMaildelNum,floatingSearch);
	}

	@Override
	protected MailInfo newMailInfo(Cursor cursor)
	{
		if(cursor.getColumnIndex("uid") < 0)//not exists 'uid',it's out mail.
			return new OutMailInfo(cursor);
		else
			return new InMailInfo(cursor);
	}

	@Override
	protected MailInfo[] newMailInfoArray(int count)
	{
		// TODO Auto-generated method stub
		return new MailInfo[count];
	}

	@Override
	protected boolean shouldRebuildMailList(int state)
	{
		//always update mail list.
		return true;
	}
	
	@Override
	protected String doUpdateMailStates(Iterator<MailInfo> mails, int state)
	{
		// update mail status
		int idx = 0;
		List<MailInfo> inMails = new LinkedList<MailInfo>();
		List<MailInfo> outMails = new LinkedList<MailInfo>();
		Vector<Integer> inAcctIds = new Vector<Integer>();
		Vector<Integer> inUidxs = new Vector<Integer>();
		Vector<String> inFolders=new Vector<String>();
		Vector<Integer> outAcctIds = new Vector<Integer>();
		Vector<Integer> outUidxs = new Vector<Integer>();
		Vector<String> outFolders=new Vector<String>();

		while (mails.hasNext())
		{
			MailInfo mailInfo = mails.next();
			if(idx < _inMaildelNum)
			{
				inMails.add(mailInfo);
				inAcctIds.add(mailInfo.getAccountId());
				inUidxs.add(mailInfo.getUidx());
				inFolders.add(mailInfo.getFolder());
			}
			else
			{
				outMails.add(mailInfo);
				outAcctIds.add(mailInfo.getAccountId());
				outUidxs.add(mailInfo.getUidx());
				outFolders.add(mailInfo.getFolder());
			}
			idx ++;
		}
		//if delete forever
		if (state == MailStatus.MAIL_LOCAL_DELETED)
			state = MailStatus.MAIL_DELETE_FOREVER;
		NewDbHelper db = NewDbHelper.getInstance();
		// in box mail
		int inMailNum = inMails.size();
		if (inMailNum > 0)
		{
			String result = db.updateInMailStatus(inAcctIds, inUidxs, state,inFolders);
			if (!result.equals(""))
				return result;
		}

		int outMailNum = outMails.size();
		if (outMailNum > 0)
		{
			String result = db.updateOutMailStatus(outAcctIds, outUidxs, state);
			if (!result.equals(""))
				return result;
		}	
		return "";
	}
	
	protected void updateMailItemView(MailInfo mailInfo, ViewHolder holder, View convertView)
	{
		
		
	}
	
	@Override
	protected boolean inGroupMode()
	{
		return false;
	}
}
package mobi.cloudymail.mailclient;

import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.TextView;

public class DialogCustom extends Dialog {

	public DialogCustom(Context context, int theme) {
		super(context, theme);
	}

	public DialogCustom(Context context) {
		super(context);
	}
	
	
    /**
     * Helper class for creating a custom dialog
     * @author kjjia
     *
     */
	public static class Builder
	{
		private Context context;
		private String title;
		private String message;
		private String positiveButtonText;
		private String negativeButtonText;
		private View contentView;
		
		private DialogInterface.OnClickListener
		                          positiveButtonClickListener,
		                          negativeButtonClickListener;
		private boolean mCancelable;
        public Builder(Context context)
        {
        	this.context=context;
        } 
        
        public void setCancelable(boolean flag) {
            mCancelable = flag;
        }
        /**
         * Set the Dialog message from String
         * @param title
         * @return
         */
        public Builder setMessage(String message) {
            this.message = message;
            return this;
        }
 
        /**
         * Set the Dialog message from resource
         * @param title
         * @return
         */
        public Builder setMessage(int message) {
            this.message = (String) context.getText(message);
            return this;
        }
 
        /**
         * Set the Dialog title from resource
         * @param title
         * @return
         */
        public Builder setTitle(int title) {
            this.title = (String) context.getText(title);
            return this;
        }
 
        /**
         * Set the Dialog title from String
         * @param title
         * @return
         */
        public Builder setTitle(String title) {
            this.title = title;
            return this;
        }
 
        /**
         * Set a custom content view for the Dialog.
         * If a message is set, the contentView is not
         * added to the Dialog...
         * @param v
         * @return
         */
        public Builder setContentView(View v) {
            this.contentView = v;
            return this;
        }
        /**
         * Set the positive button resource and it's listener
         * @param positiveButtonText
         * @param listener
         * @return
         */
        public Builder setPositiveButton(int positiveButtonText,
                DialogInterface.OnClickListener listener) {
            this.positiveButtonText = (String) context
                    .getText(positiveButtonText);
            this.positiveButtonClickListener = listener;
            return this;
        }
 
        /**
         * Set the positive button text and it's listener
         * @param positiveButtonText
         * @param listener
         * @return
         */
        public Builder setPositiveButton(String positiveButtonText,
                DialogInterface.OnClickListener listener) {
            this.positiveButtonText = positiveButtonText;
            this.positiveButtonClickListener = listener;
            return this;
        }
 
        /**
         * Set the negative button resource and it's listener
         * @param negativeButtonText
         * @param listener
         * @return
         */
        public Builder setNegativeButton(int negativeButtonText,
                DialogInterface.OnClickListener listener) {
            this.negativeButtonText = (String) context
                    .getText(negativeButtonText);
            this.negativeButtonClickListener = listener;
            return this;
        }
 
        /**
         * Set the negative button text and it's listener
         * @param negativeButtonText
         * @param listener
         * @return
         */
        public Builder setNegativeButton(String negativeButtonText,
                DialogInterface.OnClickListener listener) {
            this.negativeButtonText = negativeButtonText;
            this.negativeButtonClickListener = listener;
            return this;
        }
 
        /**
         * Create the custom dialog
         */
        public DialogCustom create() {
            LayoutInflater inflater = (LayoutInflater) context
                    .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            // instantiate the dialog with the custom Theme
            final DialogCustom dialog = new DialogCustom(context, 
            		R.style.Dialog);
            View layout = inflater.inflate(R.layout.dialog_style, null);
            dialog.addContentView(layout, new LayoutParams(
                    LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
            // set the dialog title
            ((TextView) layout.findViewById(R.id.dialogTitle)).setText(title);
            // set the confirm button
            if (positiveButtonText != null) {
                ((Button) layout.findViewById(R.id.dialog_positiveButton))
                        .setText(positiveButtonText);
                if (positiveButtonClickListener != null) {
                    ((Button) layout.findViewById(R.id.dialog_positiveButton))
                            .setOnClickListener(new View.OnClickListener() {
                                public void onClick(View v) {
                                    positiveButtonClickListener.onClick(
                                    		dialog, 
                                            DialogInterface.BUTTON_POSITIVE);
                                }
                            });
                }
            } else {
                // if no confirm button just set the visibility to GONE
                layout.findViewById(R.id.dialog_positiveButton).setVisibility(
                        View.GONE);
            }
            // set the cancel button
            if (negativeButtonText != null) {
                ((Button) layout.findViewById(R.id.dialog_negativeButton))
                        .setText(negativeButtonText);
                if (negativeButtonClickListener != null) {
                    ((Button) layout.findViewById(R.id.dialog_negativeButton))
                            .setOnClickListener(new View.OnClickListener() {
                                public void onClick(View v) {
                                    positiveButtonClickListener.onClick(
                                    		dialog, 
                                            DialogInterface.BUTTON_NEGATIVE);
                                }
                            });
                }
            } else {
                // if no confirm button just set the visibility to GONE
                layout.findViewById(R.id.dialog_negativeButton).setVisibility(
                        View.GONE);
            }
            // set the content message
            if (message != null) {
                ((TextView) layout.findViewById(
                		R.id.dialog_message)).setText(message);
            } else if (contentView != null) {
                // if no message set
                // add the contentView to the dialog body
                ((LinearLayout) layout.findViewById(R.id.content))
                        .removeAllViews();
                ((LinearLayout) layout.findViewById(R.id.content))
                        .addView(contentView, 
                                new LayoutParams(
                                        LayoutParams.WRAP_CONTENT, 
                                        LayoutParams.WRAP_CONTENT));
            }
            dialog.setContentView(layout);
            return dialog;
        }
 
        
	}
}
package mobi.cloudymail.mailclient;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;

public class DialogCustomActivity extends AlertDialog {
    Context context;
	public DialogCustomActivity(Context context) {
		super(context);
        this.context=context;
	}
    public DialogCustomActivity(Context context,int theme)
    {
    	super(context,theme);
    	this.context=context;
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	super.onCreate(savedInstanceState);
        setContentView(R.layout.dialog_style);
    }
}
package mobi.cloudymail.mailclient;


public class EmailAddress
{
	private String name = null;
	private String address = null;
	public EmailAddress(String addr)
	{
		int posLT = addr.indexOf('<');
		int posGT = addr.indexOf('>');
		int posAT = addr.indexOf('@');
		if (posAT <= 0)
			return;
//		if(addr.indexOf('@', posAT + 1) > 0)
//			return; //more than one @ is not allowed
		if (posLT > 0 && posGT > 0)
		{
			name = addr.substring(0, posLT).trim();
			address = addr.substring(posLT + 1, posGT).trim();
		}
		else
		{
//			name = address = addr.trim();
		    String[] reciverName = addr.split("@");
		    name=reciverName[0];
		    address=addr.trim();
		}
	}
	
	public EmailAddress(String name, String address)
	{
		this.name = name.trim();
		this.address = address.trim();
	}
	
	//eliminate the provided address from address list.
	public static String filterMailAddress(String addrs,String excludeAddr)
	{
		if(addrs.indexOf(excludeAddr) < 0)
			return addrs;
		String[] addrList = addrs.split(";");
		StringBuffer sb = new StringBuffer();
		for(int i = 0; i < addrList.length; i++)
		{
			EmailAddress ea = new EmailAddress(addrList[i]);
			if(ea.getAddress().equals(excludeAddr))
				continue;
			if(sb.length() > 0)
				sb.append(";");
			sb.append(ea);
		}
		return sb.toString();
	}
	public boolean isValid()
	{
		return address != null;
			
//		Pattern p = Pattern.compile("\\w+@\\w+\\;?"); //fail to match liu@126.com
//		Matcher m=p.matcher(address);
//		return m.matches();

	}
	
	public String getName()
	{
		return name;
	}
	
	public String getAddress()
	{
		return address;
	}
	
	public void setName(String name)
	{
		this.name = name;
	}
	
	public void setAddress(String address)
	{
		this.address = address;
	}
	
	@Override
	public String toString()
	{
//		return String.format("<%s> %s", name, address);
		return String.format("%s <%s>", name, address);
	}
	
	@Override
	public boolean equals(Object o)
	{
		if(o == null || (! (o instanceof EmailAddress)) || !this.isValid())
			return false;
		EmailAddress a = (EmailAddress) o;
		return this.address.equals(a.getAddress());
	}
}package mobi.cloudymail.mailclient;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Locale;

import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.util.MessageBox;

import org.apache.http.HttpEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;

public class FeedbackActivity extends BaseActivity
{

	private String softwareVersion;
	private String sdkVersion;
	private String phoneModel;
	private String netType;
	private String languageEnvironment;
	private OnClickListener confimBtnListener;
	private OnClickListener cancelBtnListener;
	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
		setContentView(R.layout.feedback_account);
		//win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.feedback_titlebar);
		
		
	    final EditText feedbackInfoEdit = (EditText) findViewById(R.id.feedbackInfo);
	    Button   confimBtn=(Button) findViewById(R.id.confirmFeedbackBtn);
	    Button   cancelBtn=(Button) findViewById(R.id.cancleFeedbackBtn);
	    
	    //set focus
	    feedbackInfoEdit.requestFocus();
	    softwareVersion=getString(R.string.about_version);
	    sdkVersion=android.os.Build.VERSION.RELEASE;
	    phoneModel=android.os.Build.MODEL.toString();
	    
	    if(this.getNetType()==null)
	    {
	    	netType=getString(R.string.no_network_connection);
	    }
	    else
	    {
	    	netType=this.getNetType().toString();
	    }
	    
	    languageEnvironment=Locale.getDefault().getCountry()+Locale.getDefault().getLanguage();
		String configurationInfor = getString(R.string.feedback_software_version)+" " + softwareVersion + "\n"+
		                            getString(R.string.feedback_sdk_version)+" " + sdkVersion + "\n"+
		                            getString(R.string.feedback_phone_Model)+" " + phoneModel + "\n"+
		                            getString(R.string.feedback_network_type)+" " + netType + "\n"+
		                            getString(R.string.feedback_language_Environment)+" " + languageEnvironment+"\n"+"\n"+
		                            getString(R.string.feedback_my_recommend)+"\n";
		feedbackInfoEdit.setText(configurationInfor);
		//Set initial cursor position
	    feedbackInfoEdit.setSelection(feedbackInfoEdit.getText().length());
	    
	    if(confimBtnListener==null)
	    	
	    	confimBtnListener=new View.OnClickListener() {
				@Override
				public void onClick(View v)
				{
		           Thread feedbackThread=new Thread()
		           {
		        	  @Override
		        	  public void run()
		        	  {
		        		  
		        		try
						{
							HttpPost feedbackRequest=new HttpPost(ServerAgent.getUrlBase()+"/FeedBack");
							StringEntity ent = new StringEntity(feedbackInfoEdit.getText().toString(), "UTF-8");
							feedbackRequest.setEntity(ent );
							try
							{
								ServerAgent.execute(feedbackRequest);
							}
							catch (IOException e)
							{
								e.printStackTrace();
							}
						}
						catch (Exception e)
						{
							e.printStackTrace();
						}
		        		  
		        	  }
		           };
		           MessageBox.show(FeedbackActivity.this, getString(R.string.feedback_msg), getString(R.string.feedback_msg_title));
                   feedbackThread.start();	
                   finish();
				}
				
			};
	    
	    confimBtn.setOnClickListener(confimBtnListener);
	    
	    if(cancelBtnListener==null)
	    {
	    	cancelBtnListener=new View.OnClickListener() {
				
				@Override
				public void onClick(View v)
				{
                   finish();					
				}
			};
	    }
	    cancelBtn.setOnClickListener(cancelBtnListener);
	}
	/**
	 * Get network type
	 * @return netWorkType
	 */
	public String getNetType()
	{
	    ConnectivityManager cm=(ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
	    NetworkInfo activeNetworkInfo = cm.getActiveNetworkInfo();
	    //nullPointException
	    if(activeNetworkInfo==null)
	    {
	    	return null;
	    }
	    else
	    {
	    	return activeNetworkInfo.getTypeName()+"["+activeNetworkInfo.getSubtypeName()+"]";
	    }
	}
}
package mobi.cloudymail.mailclient;


import android.app.Dialog;
import android.os.Bundle;
import android.view.Window;

interface OnFileBrowserListener {
	public void onFileItemClick(String filename);
	public void onDirItemClick(String path);
}

public class FileBrowser extends BaseActivity implements OnFileBrowserListener {

	@Override
	public void onFileItemClick(String filename) {
	//	setTitle(filename);
		getIntent().putExtra("selectedFile", filename);
		setResult(Dialog.BUTTON_POSITIVE,getIntent());
		finish();
	}

	@Override
	public void onDirItemClick(String path) {
//		setTitle(path);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		Window win = getWindow();
		win.requestFeature(Window.FEATURE_LEFT_ICON);
		setContentView(R.layout.file_browser);
		FileBrowserView fileBrowser = (FileBrowserView)findViewById(R.id.filebrowser);
		fileBrowser.setOnFileBrowserListener(this);
		win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
	}
}package mobi.cloudymail.mailclient;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

public class FileBrowserView extends ListView implements
			android.widget.AdapterView.OnItemClickListener {
		private final String namespace = "http://cloudymail.mobi";
		private String sdcardDirectory;
		private List<File> fileList = new ArrayList<File>();
		private Stack<String> dirStack = new Stack<String>();
		private FileListAdapter fileListAdapter;
		private OnFileBrowserListener onFileBrowserListener;
		private int folderImageResId;
		private int otherFileImageResId;
		private Map<String, Integer> fileImageResIdMap = new HashMap<String, Integer>();
		private boolean onlyFolder = false;

		public FileBrowserView(Context context, AttributeSet attrs) {
			super(context, attrs);
			sdcardDirectory = android.os.Environment.getExternalStorageDirectory()
					.toString();
			setOnItemClickListener(this);
			setBackgroundColor(android.graphics.Color.BLACK);

			folderImageResId = attrs.getAttributeResourceValue(namespace,
					"folderImage", 0);
			otherFileImageResId = attrs.getAttributeResourceValue(namespace,
					"otherFileImage", 0);
			onlyFolder = attrs.getAttributeBooleanValue(namespace,
					"onlyFolder", false);
			int index = 1;
			while (true) {
				String extName = attrs.getAttributeValue(namespace, "extName"
						+ index);
				int fileImageResId = attrs.getAttributeResourceValue(namespace,
						"fileImage" + index, 0);

				if ("".equals(extName) || extName == null
						|| fileImageResId == 0) {
					break;
				}
				fileImageResIdMap.put(extName, fileImageResId);
				index++;
			}

			dirStack.push(sdcardDirectory);
			addFiles();

			fileListAdapter = new FileListAdapter(getContext());
			setAdapter(fileListAdapter);

		}

		private void addFiles() {
			fileList.clear();
			String currentPath = getCurrentPath();
			File[] files = new File(currentPath).listFiles();
			if (dirStack.size() > 1)
				fileList.add(null);
			if(files == null)
				return;
			for (File file : files) {
				if (onlyFolder) {
					if (file.isDirectory())
						fileList.add(file);
				} else {
					fileList.add(file);
				}
			}
		}

		private String getCurrentPath() {
			String path = "";
			for (String dir : dirStack) {
				path += dir + "/";
			}
			path = path.substring(0, path.length() - 1);
			return path;
		}

		private String getExtName(String filename) {

			int position = filename.lastIndexOf(".");
			if (position >= 0)
				return filename.substring(position + 1);
			else
				return "";
		}

		@Override
		public void onItemClick(AdapterView<?> parent, View view, int position,
				long id) {
			if (fileList.get(position) == null) {
				dirStack.pop();
				addFiles();
				fileListAdapter.notifyDataSetChanged();
				if (onFileBrowserListener != null) {
					onFileBrowserListener.onDirItemClick(getCurrentPath());
				}
			} else if (fileList.get(position).isDirectory()) {
				dirStack.push(fileList.get(position).getName());
				addFiles();
				fileListAdapter.notifyDataSetChanged();
				if (onFileBrowserListener != null) {
					onFileBrowserListener.onDirItemClick(getCurrentPath());
				}
			} else {
				if (onFileBrowserListener != null) {
					String filename = getCurrentPath() + "/"
							+ fileList.get(position).getName();
					onFileBrowserListener.onFileItemClick(filename);
				}
			}

		}

		private class FileListAdapter extends BaseAdapter {
			private Context context;

			public FileListAdapter(Context context) {
				this.context = context;
			}

			@Override
			public int getCount() {
				return fileList.size();
			}

			@Override
			public Object getItem(int position) {
				return fileList.get(position);
			}

			@Override
			public long getItemId(int position) {
				return position;
			}

			@Override
			public View getView(int position, View convertView, ViewGroup parent) {
				LinearLayout fileLayout = new LinearLayout(context);
				fileLayout.setLayoutParams(new LayoutParams(
						LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
				fileLayout.setOrientation(LinearLayout.HORIZONTAL);
				fileLayout.setPadding(5, 10, 0, 10);
				ImageView ivFile = new ImageView(context);
				ivFile.setLayoutParams(new LayoutParams(48, 48));
				TextView tvFile = new TextView(context);
				tvFile.setTextColor(android.graphics.Color.WHITE);
				tvFile.setTextAppearance(context,
						android.R.style.TextAppearance_Large);

				tvFile.setPadding(5, 5, 0, 0);
				if (fileList.get(position) == null) {

					if (folderImageResId > 0)
						ivFile.setImageResource(folderImageResId);
					tvFile.setText(". .");
				} else if (fileList.get(position).isDirectory()) {
					if (folderImageResId > 0)
						ivFile.setImageResource(folderImageResId);
					tvFile.setText(fileList.get(position).getName());
				} else {
					tvFile.setText(fileList.get(position).getName());
					Integer resId = fileImageResIdMap.get(getExtName(fileList
							.get(position).getName()));
					int fileImageResId = 0;
					if (resId != null) {
						if (resId > 0) {
							fileImageResId = resId;
						}

					}
					if (fileImageResId > 0)
						ivFile.setImageResource(fileImageResId);
					else if (otherFileImageResId > 0)
						ivFile.setImageResource(otherFileImageResId);
				}

				tvFile.setLayoutParams(new LayoutParams(
						LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));
				fileLayout.addView(ivFile);
				fileLayout.addView(tvFile);
				return fileLayout;
			}
		}

		public void setOnFileBrowserListener(OnFileBrowserListener listener) {
			this.onFileBrowserListener = listener;
		}
	}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.mailclient.FolderNames.FOLDER_DELETE;
import static mobi.cloudymail.mailclient.FolderNames.FOLDER_INBOX;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.zip.Inflater;

import com.umeng.analytics.MobclickAgent;

import mobi.cloudymail.data.FolderInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.util.DialogResult;
import mobi.cloudymail.util.DialogUtils;
import mobi.cloudymail.util.DialogUtils.ButtonFlags;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import android.app.Dialog;
import android.app.ExpandableListActivity;
import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.widget.Button;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.ExpandableListView.OnGroupClickListener;
import android.widget.ExpandableListView.OnGroupExpandListener;
import android.widget.TextView;

public class FolderActivity extends ExpandableListActivity implements View.OnClickListener
{

	private ExpandableListView _elv = null;
	private FolderAdapter fa = null;

	// public Map<Integer,FolderItemData> _folderMap = null;
	public Map<Integer, ArrayList<FolderItemData>> folderMap = null;
	private Account oldAccount = null;
	int selectedIdx = -1;
	// private Activity context=null;
	public static boolean showFlag;
	// public FolderAdapter2 _folderAdapter=null;

	public static final int INDEX_GLOBAL = 0;
	public static final int INDEX_ACCOUNT = 1;
	public static final int INDEX_INBOX = 2;
	public static final int INDEX_DRAFT = 3;
	public static final int INDEX_NOTSENT = 4;
	public static final int INDEX_SENT = 5;
	public static final int INDEX_WRITTEN_MAIL = 7;
	public static final int INDEX_DELETE = 6;
	public static final int INDEX_SERVER = -1;
	// public static final List<Account> accounts = new ArrayList<Account>();
	public static final String DAT_FOLDER_NAME = "folderName";
	public static final String DAT_FOLDER_DESCRIPTION = "folderDes";

	class FolderItemData
	{
		public int image;
		public String folderDes;
		public int totalCount;
		public int unreadCount = -1;
		public String folderName;
		public Class<?> activity = null;
		public int id = 0;
	}

	// public static int getAccountIndex(Account a)
	// {
	// int selectedIdx = accounts.indexOf(a);
	// return selectedIdx;
	// }
	//

	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		// TODO Auto-generated method stub
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
		setContentView(R.layout.folder);
		//win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.folder_titlebar_layout);
		initEditWidget();
		folderMap = new HashMap<Integer, ArrayList<FolderItemData>>();
		_elv = this.getExpandableListView();
		_elv.setGroupIndicator(null);
		_elv.setOnGroupExpandListener(new OnGroupExpandListener() {

			@Override
			public void onGroupExpand(int groupPosition)
			{
				// TODO Auto-generated method stub
				for(int i=0; i<FolderActivity.this.getExpandableListAdapter().getGroupCount(); i++){
					// _elv.setGroupIndicator(FolderActivity.this.getResources().getDrawable(R.drawable.delete));
					if(groupPosition!=i){
						_elv.collapseGroup(i);
						// _elv.setGroupIndicator(FolderActivity.this.getResources().getDrawable(R.drawable.expand));
					}
				}
			}
		});

		_elv.setOnGroupClickListener(new OnGroupClickListener() {
			@Override
			public boolean onGroupClick(ExpandableListView arg0, View arg1, int groupPosition,
					long arg3)
			{
				// TODO Auto-generated method stub
				boolean currentAccountChanged=false;
				if(MyApp.currentAccount!=AccountManager.getByIndex(groupPosition))
				{
					MyApp.currentAccount = AccountManager.getByIndex(groupPosition);
					currentAccountChanged=true;
				}
				if (fa.isTextClicked){
					// int item_index = INDEX_INBOX;
					// if(folderMap.get(MyApp.currentAccount.id).containsKey(item_index))
					// {
					// FolderItemData fid =folderMap.get(MyApp.currentAccount.id).get(item_index));
					Intent intent = new Intent(FolderActivity.this, InBoxActivity.class);
					intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
					intent.putExtra(DAT_FOLDER_NAME, "INBOX");
					intent.putExtra("currentAccountChanged", currentAccountChanged);
					intent.putExtra(DAT_FOLDER_DESCRIPTION,getResources().getString(R.string.folder_inbox));
					startActivity(intent);
					// }
					return true;
				}
				return false;
			}
		});

		_elv.setOnChildClickListener(new OnChildClickListener() {
			
			public boolean onChildClick(ExpandableListView parent, View v,
					int groupPosition, int childPosition, long id)
			{
				// TODO Auto-generated method stub
				//int item_index = childPosition;
				//if(_folderMap.containsKey(item_index))
				if(fa.itemList.get(groupPosition)!=null && fa.itemList.get(groupPosition).size()!=0)
				{
					FolderItemData fid = fa.itemList.get(groupPosition).get(childPosition);
					//FolderItemData fid = folderMap.get(AccountManager.accounts.get(groupPosition).name).get(childPosition);
					Intent intent = new Intent(FolderActivity.this,fid.activity);
					intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
					intent.putExtra(DAT_FOLDER_NAME, fid.folderName);
					intent.putExtra(DAT_FOLDER_DESCRIPTION, fid.folderDes);
				//	intent.putExtra(DATA_FOLDER_NAME, selectedFolderName);
					startActivity(intent);
				}
				return false;
			}
		});	
		MyApp.addActivity(this);
		if(AccountManager.isEmpty())
		{
			createNewAccount();
		}

	}

	// @Override
	// protected void onActivityResult(int requestCode, int resultCode, Intent data)
	// {
	// switch(requestCode)
	// {
	// case R.id.titleLeftBtn:
	// if(getIntent().getBooleanExtra("accountFolder", false)==true)
	// {
	// itemExpandInit();
	// }
	// break;
	//
	// }
	//
	// super.onActivityResult(requestCode, resultCode, data);
	// }

	private void initEditWidget()
	{
		Button editTitleBtn = (Button) findViewById(R.id.editfolderTitlebtn);
		editTitleBtn.setOnClickListener(this);
	}

	public void expandAccount()
	{
		// TODO Auto-generated method stub
		int groupPos = AccountManager.getAccountIndex(MyApp.currentAccount);
		_elv.expandGroup(groupPos);

	}

	public void collapseAccount()
	{
		int groupPos = AccountManager.getAccountIndex(MyApp.currentAccount);
		_elv.collapseGroup(groupPos);
	}

	private void updateMailCount(Account account)
	{
		//Account curAccount = MyApp.currentAccount;
		if(account == null)
			return;
		Account curAccount = account;		
		NewDbHelper dbHelper = NewDbHelper.getInstance();
		ArrayList<FolderItemData> list=folderMap.get(curAccount.id);
		for (FolderItemData data:list)
		{
			switch (data.id)
			{
			case INDEX_GLOBAL:
				data.totalCount=dbHelper.getInMailCount(-1,FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD},true);
				data.unreadCount= dbHelper.getInMailCount(-1,FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW},false);
				break;
			case INDEX_INBOX:
				data.totalCount= dbHelper.getInMailCount(curAccount.id, FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD},true);
				data.unreadCount = dbHelper.getInMailCount(curAccount.id, FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW},true);
				break;
			case INDEX_WRITTEN_MAIL:
				data.totalCount = dbHelper.getOutMailCount(curAccount.id,"",new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
				break;
//			case INDEX_SENT:
//				data.totalCount = dbHelper.getOutMailCount(curAccount.id,FOLDER_SENT,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
//				break;
//			case INDEX_NOTSENT:
//				data.totalCount = dbHelper.getOutMailCount(curAccount.id,FOLDER_NOTSENT,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
//				break;
//			case INDEX_DRAFT:
//				data.totalCount = dbHelper.getOutMailCount(curAccount.id,FOLDER_DRAFT,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
//				break;
			case INDEX_DELETE:
				data.totalCount = DeleteBoxActivity.getDelMailCount(curAccount.id);
				break;
			default:
				data.totalCount=dbHelper.getInMailCount(curAccount.id,data.folderName,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED},true);
				break;
			}
		}
//		Map<Integer,FolderItemData> accountMap = folderMap.get(curAccount.id);
//		accountMap.get(INDEX_GLOBAL).totalCount = dbHelper.getInMailCount(-1,FOLDER_INBOX,MailStatus.MAIL_DELETED,true,true);
//		accountMap.get(INDEX_GLOBAL).unreadCount = dbHelper.getInMailCount(-1,FOLDER_INBOX,MailStatus.MAIL_NEW,false,false);
//		accountMap.get(INDEX_INBOX).totalCount = dbHelper.getInMailCount(curAccount.id, FOLDER_INBOX, MailStatus.MAIL_DELETED, true,false);
//		accountMap.get(INDEX_INBOX).unreadCount = dbHelper.getInMailCount(curAccount.id, FOLDER_INBOX, MailStatus.MAIL_NEW, false,false);
//		accountMap.get(INDEX_SENT).totalCount = dbHelper.getOutMailCount(curAccount.id,FOLDER_SENT,MailStatus.MAIL_DELETED, true);
//		accountMap.get(INDEX_NOTSENT).totalCount = dbHelper.getOutMailCount(curAccount.id,FOLDER_NOTSENT,MailStatus.MAIL_DELETED, true);
//		accountMap.get(INDEX_DRAFT).totalCount = dbHelper.getOutMailCount(curAccount.id,FOLDER_DRAFT,MailStatus.MAIL_DELETED, true);
//		
//		accountMap.get(INDEX_DELETE).totalCount = DeleteBoxActivity.getDelMailCount(curAccount.id);
	}

	@Override
	protected void onResume()
	{
		// TODO Auto-generated method stub
		super.onResume();
		MobclickAgent.onResume(this);
		MyApp.setCurrentActivity(this);
		ArrayList<FolderItemData> itemDataList=null;
		ArrayList<FolderInfo> folders = null;
		Resources res = getResources();
		NewDbHelper dbHelper = NewDbHelper.getInstance();
		for (int i = 0; i < AccountManager.getCount(); i++)
		{
			itemDataList=new ArrayList<FolderItemData>();
//		    FolderItemData fid = new FolderItemData();
//		    fid.image = R.drawable.webtext;
//			fid.folderName = FOLDER_INBOX;
//		    fid.folderDes = res.getString(R.string.folder_global);
//			fid.activity = GlobalInBoxActivity.class;
//			fid.id=INDEX_GLOBAL;
//		    fid.totalCount = dbHelper.getInMailCount(-1, FOLDER_INBOX,
//		    MailStatus.MAIL_DELETED, true, true);
//			fid.unreadCount = dbHelper.getInMailCount(-1, FOLDER_INBOX,
//			MailStatus.MAIL_NEW, false, false);
//			itemDataList.add(fid);
						
			Account acct = AccountManager.getByIndex(i);
			FolderItemData fid = new FolderItemData();
			fid.image = R.drawable.inbox;
			fid.folderName = FOLDER_INBOX;
			fid.folderDes = res.getString(R.string.folder_inbox);
		    fid.activity = InBoxActivity.class;
		    fid.id=INDEX_INBOX;
		    fid.totalCount = dbHelper.getInMailCount(acct.id, FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED}, false);
			fid.unreadCount = dbHelper.getInMailCount(acct.id, FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW}, false);
			itemDataList.add(fid);
			
			 fid = new FolderItemData();
			 fid.image = R.drawable.draftbox;
			 fid.folderName = "";
			 fid.id=INDEX_WRITTEN_MAIL;
			 fid.folderDes = res.getString(R.string.folder_write);
			 fid.activity = OutBoxActivity.class;
			 fid.totalCount = dbHelper.getOutMailCount(acct.id,"",new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED});
			 itemDataList.add(fid);
			
//			 fid = new FolderItemData();
//			 fid.image = R.drawable.draftbox;
//			 fid.folderName = FOLDER_DRAFT;
//			 fid.id=INDEX_DRAFT;
//			 fid.folderDes = res.getString(R.string.folder_draft);
//			 fid.activity = OutBoxActivity.class;
//			 fid.totalCount = dbHelper.getOutMailCount(acct.id, FOLDER_DRAFT,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
//			 itemDataList.add(fid);
//			 
//			 fid = new FolderItemData();
//			 fid.image = R.drawable.outbox;
//			 fid.folderName = FOLDER_NOTSENT;
//			 fid.id=INDEX_NOTSENT;
//			 fid.folderDes = res.getString(R.string.folder_notsentbox);
//			 fid.activity = OutBoxActivity.class;
//			 fid.totalCount = dbHelper.getOutMailCount(acct.id, FOLDER_NOTSENT,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
//			 itemDataList.add(fid);		
//			 
//			 fid = new FolderItemData();
//			 fid.image = R.drawable.sentbox;
//			 fid.folderName = FOLDER_SENT;
//			 fid.id=INDEX_SENT;
//			 fid.folderDes = res.getString(R.string.folder_sentbox);
//			 fid.activity = OutBoxActivity.class;
//			 fid.totalCount = dbHelper.getOutMailCount(acct.id, FOLDER_SENT,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED, MailStatus.FLAG_HAS_MORE_PLACEHOLD});
//			 itemDataList.add(fid);
				
			 fid = new FolderItemData();
			 fid.image = R.drawable.deletebox;
			 fid.id=INDEX_DELETE;
			 fid.folderName = FOLDER_DELETE;// FOLDER_INBOX;
			 fid.folderDes = res.getString(R.string.folder_delete);
			 fid.activity = DeleteBoxActivity.class;
			 itemDataList.add(fid);			
			folders = dbHelper.getFolders(acct.id);					
			if (folders.size() != 0)
			{
				for (int j = 0; j < folders.size(); j++)
				{
					fid = new FolderItemData();
					FolderInfo info = folders.get(j);
					if (info.folderName.equalsIgnoreCase("INBOX"))
					{
						continue;
					}
					
					
					fid.image = R.drawable.inbox;
					fid.folderName = info.folderName;
					fid.folderDes = info.displayName;
					fid.activity = InBoxActivity.class;
					fid.id = INDEX_SERVER;
					itemDataList.add(fid);

				}	
			}
			folderMap.put(acct.id, itemDataList);	
		}
		fa = new FolderAdapter(this);
		setListAdapter(fa);

		boolean doExpand = getIntent().getBooleanExtra("expandCurrentAccount", false);
		if (doExpand == true)
		{
			expandAccount();
		}
		else
			collapseAccount();

		updateMailCount(MyApp.currentAccount);
		fa.init();
		showFlag = false;
		fa.notifyDataSetChanged();
	}

	protected void onNewIntent(Intent intent)
	{
		fa.notifyDataSetChanged();
		setIntent(intent);
	}

	public void createNewAccount()
	{
		Account a = new Account();
		Intent intent = new Intent(this, AccountWizard.class);
		intent.putExtra("account", a);
		intent.putExtra("isNew", true);
		startActivityForResult(intent, R.layout.account_wizard);
	}

	public void deleteAccount(int groupPosition)
	{
		
		EnumSet<ButtonFlags> buttons = EnumSet.noneOf(ButtonFlags.class);
		buttons.add(ButtonFlags.Yes);
		buttons.add(ButtonFlags.No);
		Resources res = getResources();
		int checkFlag = DialogUtils.showModalMsgBox(
				this,
				String.format(
						res.getString(R.string.deleteAccountQuery), AccountManager.getByIndex(groupPosition).name),
						 res.getString(R.string.deleteAccountTitle), buttons);
		if (checkFlag == DialogResult.NO)
			return;
	    
//		int checkFlag = DialogUtils.showModalMsgBox(
//				this,
//				String.format(
//						res.getString(R.string.deleteAccountQuery), AccountManager.getByIndex(groupPosition).name),
//						 res.getString(R.string.deleteAccountTitle), buttons);
//		if (checkFlag == DialogResult.NO)
//			return;
		

		// update current account;
		Account toDel = AccountManager.deleteAccount(groupPosition);
		Account curAccount = MyApp.currentAccount;
		if (curAccount != null && curAccount.id == toDel.id) 
		{//current account is deleted
			if (!AccountManager.isEmpty())
				MyApp.currentAccount = AccountManager.getByIndex(0);
			else
				MyApp.currentAccount = null;
		}
		// update list view.
		showFlag = false;
		updateListView();
	}

	public void editAccount(int groupPosition)
	{
		Intent intent = new Intent(this, AccountWizard.class);

		Account a = AccountManager.getByIndex(groupPosition);
		oldAccount = a;
		intent.putExtra("account", a);
		intent.putExtra("isNew", false);
		startActivityForResult(intent, R.string.editStr);
	}

	@Override
	public void onActivityResult(int reqCode, int rstCode, Intent intent)
	{
		MyApp.setCurrentActivity(this);
		switch (reqCode)
		{
		case R.layout.account_wizard:// account wizard
		{
			if(rstCode == AccountWizard.RESULT_CANCELED)
			{
				return ;
			}
			Account a = (Account) intent.getSerializableExtra("account");
			// String errStr = DbHelper.getInstance().addAccount(a);
			AccountManager.addAccount(a);
			if(rstCode == AccountWizard.ACTRST_CHECKNEWMAIL){
					MyApp.currentAccount = a;
					MyApp.userSetting.currentAccountId = a.id;
					Intent intent1 = new Intent(this, InBoxActivity.class);
					intent1.putExtra("CheckMail", true);
					intent1.putExtra("accountID", a.id);
					startActivity(intent1);
					finish();

				break;
			}
			else if(rstCode == AccountWizard.ACTRST_NORMAL){
				// if it's the first account, return to mail box.
				if(MyApp.currentAccount == null){
					MyApp.currentAccount = a;
				}
				if (getIntent().getBooleanExtra(AccountManager.FirstAccount, false))
				{
					setResult(Dialog.BUTTON_POSITIVE, getIntent());
					finish();
				}
				showFlag = false;
				fa.notifyDataSetChanged();
				break;
			}
		}
		case R.string.editStr: // edit account
		{
			if (rstCode != Dialog.BUTTON_POSITIVE)
				return;
			Account a = (Account) intent.getSerializableExtra("account");
			// String errStr = DbHelper.getInstance().updateAccount(a,oldAccountName);
			AccountManager.updateAccount(oldAccount, a);
			showFlag = false;
			fa.notifyDataSetChanged();
			break;
		}
		}
	}

	public void onClick(View v)
	{
		switch (v.getId())
		{
		case R.id.editfolderTitlebtn:
			showFlag = !showFlag;
			updateListView();
			break;
		}
	}

	// }

	private void updateListView()
	{
		fa.init();
		fa.notifyDataSetChanged();
	}

}
package mobi.cloudymail.mailclient;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import mobi.cloudymail.mailclient.FolderActivity.FolderItemData;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.util.NewDbHelper;
import android.app.Activity;
import android.content.Intent;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.widget.BaseExpandableListAdapter;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;

public class FolderAdapter extends BaseExpandableListAdapter
{
	private Activity _mContext = null;
	private FolderActivity _folderActivity=null;
	public String[] children = null;
	private List<String> groupList = null;
	public List<List<FolderItemData>> itemList = null;

	//private  Map<Integer,FolderItemData> _folderMap = null;accounts.add(a)
	public Map<Integer,ArrayList<FolderItemData>> folderMap = null;
	public boolean isTextClicked = false;
	private OnClickListener addAccountItemListener;
	private OnClickListener editAccountListener;
	
	public void init(){
		
		children = new String[]{_mContext.getResources().getString(R.string.folder_inbox), 
		                        _mContext.getResources().getString(R.string.folder_draft), 
		                        _mContext.getResources().getString(R.string.folder_notsentbox), 
		                        _mContext.getResources().getString(R.string.folder_sentbox), 
		                        _mContext.getResources().getString(R.string.folder_delete)};
		groupList.clear();
		itemList.clear();
		for(int i=0; i<AccountManager.getCount(); i++){
			Account acct = AccountManager.getByIndex(i);
			groupList.add(acct.name);
			List<FolderItemData> ll =folderMap.get(acct.id);
			itemList.add(ll);
		}
	}
	
	public FolderAdapter(FolderActivity context){
		this._folderActivity=((FolderActivity)context);
		this._mContext = context;
		this.folderMap = ((FolderActivity)context).folderMap;
		groupList = new ArrayList<String>();
		itemList = new ArrayList<List<FolderItemData>>();
		init();
	}

	@Override
	public Object getChild(int groupPosition, int childPosition)
	{
		return itemList.get(groupPosition).get(childPosition);
	}

	@Override
	public long getChildId(int groupPosition, int childPosition)
	{
		return childPosition;
	}

	@Override
	public View getChildView(int groupPosition, int childPosition,
			boolean isLastChild, View convertView, ViewGroup parent)
	{
		if(convertView == null){
			convertView = _mContext.getLayoutInflater().inflate(R.layout.folder_child, null);
		}
		convertView.setBackgroundResource(R.drawable.mail_folder_child_bg);
		TextView text = (TextView)convertView.findViewById(R.id.childText);
		ImageView image = (ImageView)convertView.findViewById(R.id.groupImage);
		String name = itemList.get(groupPosition).get(childPosition).folderDes+ "    "  + "[";
		if(itemList.get(groupPosition).get(childPosition).unreadCount >= 0)
			name += itemList.get(groupPosition).get(childPosition).unreadCount+"/";
		name += itemList.get(groupPosition).get(childPosition).totalCount+"]";
		text.setText(name);
		image.setImageResource(itemList.get(groupPosition).get(childPosition).image);
		

		return convertView;
	}
	@Override
	public int getChildrenCount(int groupPosition)
	{
		if(groupPosition == getGroupCount() - 1)
			return 0;
		return itemList.get(groupPosition).size();
	}

	@Override
	public Object getGroup(int groupPosition)
	{
		return itemList.get(groupPosition);
	}

	@Override
	public int getGroupCount()
	{
		return groupList.size()+1;
	}

	@Override
	public long getGroupId(int groupPosition)
	{
		return groupPosition;
	}

	@Override
	public int getGroupType(int groupPosition)
	{
		if (groupPosition == getGroupCount() - 1)
		{
			return 1;
		}
		return 0;
	}

	@Override
	public int getGroupTypeCount()
	{
		return 2;
	}

	@Override
	public View getGroupView(final int groupPosition, boolean isExpanded,
			View convertView, ViewGroup parent)
	{
		

		
		if (groupPosition == getGroupCount() - 1)
		{
			return getAddingAccountView(convertView);
		}
			
		if(convertView == null)
		{
			convertView = _mContext.getLayoutInflater().inflate(R.layout.folder_group, null);
		}
		
		convertView.setBackgroundResource(R.drawable.mail_folder_father_bg);
		ImageButton editAccountBtn=(ImageButton)convertView.findViewById(R.id.folder_edit_btn);
		ImageButton delAccountBtn=(ImageButton)convertView.findViewById(R.id.folder_del_btn);
		if(FolderActivity.showFlag==true)
		{
			editAccountBtn.setVisibility(View.VISIBLE);
			delAccountBtn.setVisibility(View.VISIBLE);
			FolderActivity.showFlag=!FolderActivity.showFlag;
		}
		else
		{
			editAccountBtn.setVisibility(View.GONE);
			delAccountBtn.setVisibility(View.GONE);
			FolderActivity.showFlag=!FolderActivity.showFlag;
		}
		FolderActivity.showFlag=!FolderActivity.showFlag;
		
		editAccountListener=new OnClickListener() {
			
			@Override
			public void onClick(View v)
			{
				
				_folderActivity.selectedIdx = groupPosition;
				_folderActivity.editAccount(groupPosition);
			}
		};
		editAccountBtn.setOnClickListener(editAccountListener);
		
		delAccountBtn.setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v)
			{
				_folderActivity.deleteAccount(groupPosition);
			}
		});
		
		
		TextView text = (TextView)convertView.findViewById(R.id.groupText);
		ImageView image = (ImageView)convertView.findViewById(R.id.groupImage);
		//show editBtn and delBtn
		

		text.setOnTouchListener(new OnTouchListener() {
			@Override
			public boolean onTouch(View arg0, MotionEvent arg1)
			{
				FolderAdapter.this.isTextClicked = true;
				return false;
			}
		});
		
		image.setOnTouchListener(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event)
			{
				// TODO Auto-generated method stub
				FolderAdapter.this.isTextClicked = false;
				return false;
			}
		});
		String name = (String) groupList.get(groupPosition);
		text.setText(name);
		image.setImageDrawable(_mContext.getResources().getDrawable(R.drawable.normal));
		if(isExpanded)
			image.setImageDrawable(_mContext.getResources().getDrawable(R.drawable.open));
		
		return convertView;
	}


	private View getAddingAccountView(View convertView)
	{
		View addAccountItem = convertView;
         //ImageView image;
       if (addAccountItem == null) {
        	 addAccountItem = View.inflate(_mContext, R.layout.add_account_item, null);
        	 
      	 if(addAccountItemListener==null)
  	       {
  	    	   addAccountItemListener=new View.OnClickListener() {
  				
  				@Override
  				public void onClick(View v)
  				{

  					Account a = new Account();
         				Intent intent = new Intent(_folderActivity, AccountWizard.class);
         				intent.putExtra("account", a);
         				intent.putExtra("isNew",true);
         				_folderActivity.startActivityForResult(intent, R.layout.account_wizard);	
  				}
  			};
  	       }
          addAccountItem.setOnClickListener(addAccountItemListener);
         }
         
	     
       	return addAccountItem;
	}

	@Override
	public boolean hasStableIds()
	{
		return false;
	}

	@Override
	public boolean isChildSelectable(int groupPosition, int childPosition)
	{
		return true;
	}

	@Override
	public boolean isEmpty()
	{
		return false;
	}

	@Override
	public void onGroupCollapsed(int groupPosition)
	{
	}
	
}
package mobi.cloudymail.mailclient;


/**
 * 
 * @author kj_jia
 * @date 2011-7-7
 */
public interface FolderNames
{

	public static final String FOLDER_INBOX = "INBOX";
	public static final String FOLDER_DRAFT = "DRAFT";
	public static final String FOLDER_NOTSENT = "NOTSENT";
	public static final String FOLDER_STATE_UNREAD = "UNREAD";
	public static final String FOLDER_SENT="SENT";
	public static final String FOLDER_GLOBAL_INBOX="GLOBALINBOX";
	public static final String FOLDER_DELETE="DELETEBOX";

//	private static final String FOLDER_DELETED="DELETED";
	
  
	
	public static final String DAT_FOLDER_NAME = "folderName";
	public static final String DAT_FOLDER_DESCRIPTION = "folderDes";
	

}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.SoftwareUpdate;
import mobi.cloudymail.util.Utils;
import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.util.Log;
import android.view.MenuItem;

public class GlobalInBoxActivity extends InBoxActivity
{
	private static boolean firstLoad = true;
	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
//		Debug.startMethodTracing("cloudmail", 50*1024*1024);
		_excludeHasMoreMail = true;
		Log.d(LOGTAG,getClass().getName()+ "onCreate()");
		if(firstLoad)
		{
			firstLoad = false;
			SoftwareUpdate.getInstance().checkUpdate(true);
		}
		doReceiveMails(0, true);
//		((PullToRefreshListView)getListView()).performItemClick(getListView(), 0, 0);
	}
	
	protected boolean isLocalInBoxActivity() 
	{
		return false;
	}
	
	@Override
	protected void initBaseTitle()
	{
		_baseWinTitle = getResources().getString(R.string.folder_global);
		
	}
	@Override
	protected void beforeOpenMail(MailInfo mailInfo)
	{
		MyApp.setCurrentMailInfo(mailInfo);
	}
//	
//	@Override
//	protected boolean doCreateOptionsMenu(Menu menu)
//	{
//		return true;
//	}
	
	@Override
	protected int getCurrentAccountId()
	{
		return -1;
	}
	/**
	 * 
	 * @param mailUidxCeil
	 *            the maximux uidx of mail want to receive. -1 to indicate no
	 *            limit
	 */
	protected void doReceiveMails(int mailUidxCeil, boolean beQuiet)
	{
		Utils.ASSERT(MyApp.currentAccount != null);
		((PullToRefreshListView)getExpandableListView()).enforceToRefreshState();
//		((PullToRefreshListView)getExpandableListView()).enforceToRefreshState();
		recvTask = new ReceiveMailTask(mailUidxCeil,this,true, beQuiet, true);
		recvTask.execute(true);
	}
	@Override
	public boolean onOptionsItemSelected(MenuItem item)
	{
		if (item.getGroupId() == ACCOUNT_GRP_ID)
		{
			String actName = item.getTitle().toString();
			Account a = AccountManager.getAccount(actName);
			if (a == null)
				return super.onOptionsItemSelected(item);
			MyApp.currentAccount = a;
			MyApp.userSetting.currentAccountId = a.id;
			//start InBoxActivity
			Intent intent = new Intent(this,InBoxActivity.class);
			intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
			intent.putExtra(CLIENT_OPEN_MODE, OPEN_FROM_GLOBAL_BOX);
			startActivity(intent);
			return true;
		}
		return super.onOptionsItemSelected(item);
	}
	
//	@Override
//	public void onClick(View v) {
//		onSearchRequested();
//	}
//	
//	@Override
//	public boolean onSearchRequested(){
//		startSearch("", false, null, false);
////		doSearchQuery();
//		return true;
//	}
//	public void doSearchQuery(){
//		final Intent intent = getIntent();
//		//获得搜索框里值
//		String query=intent.getStringExtra(SearchManager.QUERY);
////		tvquery.setText(query);
//		//保存搜索记录
//		SearchRecentSuggestions suggestions=new SearchRecentSuggestions(this,
//		SearchSuggestionSampleProvider.AUTHORITY, SearchSuggestionSampleProvider.MODE);
//		suggestions.saveRecentQuery(query, null);
//		if(Intent.ACTION_SEARCH.equals(intent.getAction())){
//		//获取传递的数据
//		Bundle bundled=intent.getBundleExtra(SearchManager.APP_DATA);
//		if(bundled!=null){
//		String ttdata=bundled.getString("data");
////		tvdata.setText(ttdata);
//		}else{
////		tvdata.setText("no data");
//		}
//		}
//		}
	@Override
	protected void onNewIntent (Intent intent)
	{
		super.onNewIntent(intent);
		int newType = intent.getIntExtra(CLIENT_OPEN_MODE, 0);
		if(newType == OPEN_FROM_STATUS_BAR)
		{
			Log.d(LOGTAG,getClass().getName()+ "onNewIntent called, open from status bar");
			try
			{
				updateMail();
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}
		
//		else if(Intent.ACTION_SEARCH.equals(intent.getAction()))
//		{
////		else if(searchExtra==intent.getStringExtra(SearchManager.QUERY))
////		{
//			 floatingSearch = intent.getStringExtra(SearchManager.QUERY);
//			try
//			{
//				updateMail();
//			}
//			catch (SQLException e)
//			{
//				e.printStackTrace();
//			}
//		}
	}
	
	@Override
	protected void onResume ()
	{
		super.onResume();
		Log.d(LOGTAG,getClass().getName()+ "onResume()");
		try
		{
			updateMail();
		}
		catch (Exception e)
		{
			// TODO: handle exception
			e.printStackTrace();
		}
	}
	
	@Override
	protected boolean inReceiving()
	{
		for(int i=0;i<AccountManager.getCount();i++)
		{
			if(MyApp.getAgent(AccountManager.getByIndex(i)).isReceiving())
				return true;
		}
		return false;
	}
	@Override
	protected Cursor doQueryGroup(int index) {
		return NewDbHelper.getInstance().getInGroups(getCurrentAccountId(),mailCountPerScreen,index,folderName, orderType,true);
		
	}
	@Override
	protected int getTotalGroupCount(boolean query) {
		totalGroupCount=NewDbHelper.getInstance().getGroupCount(getCurrentAccountId(), folderName, true);
		return totalGroupCount;
	}

}package mobi.cloudymail.mailclient;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import android.content.Context;
import android.database.Cursor;
import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

public class MailGroup 
{
	private int id=0;
	private int accountId=0;
	private String suffix="";
	private Date date;
	private String from="";
	private int count;
    Vector<MailInfo> groupVector=new Vector<MailInfo>();
	
	public MailGroup(Cursor cursor)//throws SQLException
	{
		setId(cursor.getInt(cursor.getColumnIndex("id")));
		setSuffix(cursor.getString(cursor.getColumnIndex("suffix")));
		setAccountId(cursor.getInt(cursor.getColumnIndex("accountId")));
		setFrom(cursor.getString(cursor.getColumnIndex("from")));
		String dateStr = cursor.getString(cursor.getColumnIndex("date"));
		
		count = cursor.getInt(cursor.getColumnIndex("count"));
		//get mailInfo
		groupVector= NewDbHelper.getInstance().queryMailByGroup(id);
        
		try 
		{
			setDate(Utils.netDateFormater.parse(dateStr));
		} catch (ParseException e) {
			e.printStackTrace();
		}
	}
	
	public int getAccountId() {
		return accountId;
	}

	public void setAccountId(int accountId) {
		this.accountId = accountId;
	}

	public String getSuffix() {
		return suffix;
	}

	public void setSuffix(String suffix) {
		this.suffix = suffix;
	}

	public int getId() {
		return id;
	}

	public void setId(int groupId) {
		this.id = groupId;
	}

	public Date getDate() {
		return date;
	}

	public void setDate(Date date) {
		this.date = date;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}


//	private List<MailInfo> ins = new ArrayList<MailInfo>();
//	public int id = 0;

	public MailInfo getMailInfo(int i)
	{
		if(groupVector.size()>1)
		{ 
			return groupVector.elementAt(i);
		}
		if(groupVector.size()>0)
		{
			return groupVector.elementAt(0);
		}
		else
			return null;
	}
	
	public int getGroupSize()
	{
		return groupVector.size();
	}

	public boolean isReaded()
	{
		Iterator<MailInfo> it = groupVector.iterator();
		while(it.hasNext())
		{
			if(it.next().getState() == MailStatus.MAIL_NEW)
				return false;
		}
		return true;
	}
}


package mobi.cloudymail.mailclient;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Vector;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.mailclient.FolderActivity.FolderItemData;
import mobi.cloudymail.mailclient.MailFolderActivity.ViewHolder;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import android.content.Intent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.BaseExpandableListAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.ExpandableListView;
import android.widget.ImageView;
import android.widget.TextView;

 class MailGroupAdapter extends BaseExpandableListAdapter 
	{
//		private MailInfo[] _mails;
	  
//		private MailFolderActivity _ctx;
//		private Vector<MailGroup> groupList;
//		private List<MailInfo> childList;
//		private MailGroup[] _groups;
	    private Vector<MailGroup> _groupVec;
		private MailFolderActivity _ctx;
		private OnClickListener hasMoreGroupListener;
//		private Map<MailGroup,MailInfo> _Group=null;

		public MailGroupAdapter(Vector<MailGroup> groupVec,MailFolderActivity _ctx) {
			this._ctx = _ctx;
			_groupVec=groupVec;
		}
		public void setGroups(Vector<MailGroup> mailGroup)
		{
			_groupVec=mailGroup;
			notifyDataSetChanged();
		}


		@Override
		public int getGroupCount() {
			if(!_ctx.inGroupMode())
			{
				return _ctx.getTotalMailCount(false);
			}
			return _groupVec.size();
//			return 0;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			int size = _ctx.getGroup(groupPosition).getGroupSize();
			if(size <= 1)
				return 0;
			return size;
		}
		@Override
		public int getGroupType(int groupPosition)
		{
			if(_ctx.inGroupMode())
			{
				MailGroup group = _ctx.getGroup(groupPosition);
				if(group.getGroupSize()==1 && (group.getMailInfo(0).getState()&MailStatus.FLAG_HAS_MORE_PLACEHOLD) != 0)
				{
					return 2;
				}
				if(group.getGroupSize() > 1)
					return 0;
				return 1;
			}
			else
			{
				MailInfo info = _ctx.getMail(groupPosition);
				if((info.getState()&MailStatus.FLAG_HAS_MORE_PLACEHOLD) != 0)
					return 2;
				else
					return 1;
			}
		}
		@Override
		public Object getGroup(int groupPosition){
			return _ctx.getGroup(groupPosition);
//			return _ctx.getMail(groupPosition);
		}

		@Override
		public Object getChild(int groupPosition, int childPosition) {
//			return _mailList.get(groupPosition).get(childPosition);
			return _ctx.getGroup(groupPosition).getMailInfo(childPosition);
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			return childPosition;
		}

		@Override
		public boolean hasStableIds() {
			return false;
		}
		@Override
		public int getGroupTypeCount()
		{
			return 3;
		}
		@Override
		public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent)
		{
			if(!_ctx.inGroupMode())
			{
				return getMailView(_ctx.getMail(groupPosition), convertView);
			}
			MailGroup group = _ctx.getGroup(groupPosition);
			
//			if ((group.getStatu() & MailStatus.FLAG_HAS_MORE_PLACEHOLD) != 0)
//			{// this is a place holder to indicate there are more mails
//				
////				return getHasMoreView(convertView, group);
//				return getMailView(group.getMailInfo(0), convertView);
//
//			}
		
			Utils.ASSERT(group.getGroupSize()>0);
		    if(group.getGroupSize()==1)
			{
		    	convertView = getMailView(group.getMailInfo(0), convertView);
				return convertView;
			}
			
			if(convertView==null)
				convertView = _ctx.getLayoutInflater().inflate(R.layout.mail_group_item, null);	
			TextView groupDate = (TextView)convertView.findViewById(R.id.groupDateTxt);
			TextView groupFrom = (TextView)convertView.findViewById(R.id.groupFromTxt);
			TextView groupSubject = (TextView)convertView.findViewById(R.id.groupSubjectTxt);
			ImageView groupImage = (ImageView) convertView.findViewById(R.id.mailGroupImage);
			TextView expandMarkView=(TextView)convertView.findViewById(R.id.expand_mark_group);
			if(group!=null)
			{
				String subject = group.getSuffix();
				groupSubject.setText(subject);
				groupFrom.setText(group.getFrom());
				if(group.getDate() != null)
					groupDate.setText(Utils.nearFormat.format(group.getDate()));
				else
					Utils.ASSERT(false);
			}
			groupImage.setImageResource(R.drawable.expander_ic_minimized);
//			expandMarkView.setHeight(convertView.getHeight());
			expandMarkView.setVisibility(View.GONE);
			if(isExpanded)
			{
				expandMarkView.setVisibility(View.VISIBLE);
				groupImage.setImageResource(R.drawable.expander_ic_maximized);
			}
				
			if (group.isReaded())
			{
				convertView.setBackgroundResource(R.drawable.mail_read_bg);
			}
			else
				convertView.setBackgroundResource(R.drawable.mail_unread_bg);

			return convertView;
		}
		private View getMailView(MailInfo mailInfo, View convertView) {
			//ExpandableListView elv = _ctx.getExpandableListView();
			if ((mailInfo.getState() & MailStatus.FLAG_HAS_MORE_PLACEHOLD) != 0)
			{// this is a place holder to indicate there are more mails
				
				if (convertView == null)
				{
					convertView = _ctx.getLayoutInflater()
							.inflate(R.layout.showmore_item, null);
				}
				if(_ctx instanceof InBoxActivity && ((InBoxActivity)_ctx).isItemInReceivingState(mailInfo.getUid()))
				{
					convertView.findViewById(R.id.showmore_progressBar).setVisibility(View.VISIBLE);
					convertView.findViewById(R.id.showmore_text).setVisibility(View.GONE);
				}
				else
				{
					convertView.findViewById(R.id.showmore_progressBar).setVisibility(View.GONE);
					convertView.findViewById(R.id.showmore_text).setVisibility(View.VISIBLE);
				}
				return convertView;
			}
			
			// else, this is a normal mail

			// A ViewHolder keeps references to children views to avoid
			// unnecessary calls
			// to findViewById() on each row.
			final ViewHolder holder;
			if (convertView == null)
			{
				convertView = _ctx.getLayoutInflater()
						.inflate(R.layout.mail_item, null);
//				TextView expandMarkView_child=(TextView)convertView.findViewById(R.id.expand_mark_child);
//				expandMarkView_child.setVisibility(View.GONE);
				// Creates a ViewHolder and store references to the two children
				// views
				// we want to bind data to.
				holder = new ViewHolder();
				
				holder.starBtn = (Button) convertView
						.findViewById(R.id.starTargetBtn);
				holder.starBtn.setOnClickListener(_ctx);
				holder.mailDelBtn = (Button) convertView
						.findViewById(R.id.delMail);
				holder.calendarFlagView = convertView.findViewById(R.id.calendarFlag);
				holder.normalAttachmentFlagView = convertView.findViewById(R.id.attachmentFlag);
				holder.replyFlagView=convertView.findViewById(R.id.replyFlag);
				holder.forwardFlagView=convertView.findViewById(R.id.forwardFlag);
				holder.dateTxt = (TextView) convertView
						.findViewById(R.id.dateTxt);
				holder.fromTxt = (TextView) convertView
						.findViewById(R.id.fromTxt);
				holder.draftTxt=(TextView)convertView.findViewById(R.id.draftTxt);
				holder.subjectTxt = (TextView) convertView
						.findViewById(R.id.subjectTxt);
				holder.mailItemCtx = (CheckBox) convertView
						.findViewById(R.id.mailItemCtx);
				holder.mailItemCtx.setOnCheckedChangeListener(_ctx);
				holder.groupFlag=(TextView)convertView.findViewById(R.id.expand_mark_child);
				convertView.setPadding(0, 2, 0, 2);
				convertView.setTag(holder);

				holder.mailDelBtn.setWidth(40);
				holder.mailDelBtn.setHeight(40);
				holder.mailDelBtn.setOnClickListener(_ctx);
				
			}
			else
			{
				// Get the ViewHolder back to get fast access to the TextView
				// and the ImageView.
				holder = (ViewHolder) convertView.getTag();
			}

			
			
			
			holder.dateTxt.setText(mailInfo.getDateString());
			holder.fromTxt.setText(new EmailAddress(mailInfo.getFrom())
					.getName());
			holder.subjectTxt.setText(mailInfo.getSubject());
			holder.mailItemCtx.setTag(mailInfo);
			holder.mailItemCtx.setChecked(_ctx._checkedMails.isSelected(mailInfo));
            holder.calendarFlagView.setVisibility(mailInfo.hasCalendarAttachment()?View.VISIBLE:View.GONE);
            holder.normalAttachmentFlagView.setVisibility(mailInfo.hasNormalAttachment()?View.VISIBLE:View.GONE);
            holder.replyFlagView.setVisibility(mailInfo.hasReply()?View.VISIBLE:View.INVISIBLE);
            holder.forwardFlagView.setVisibility(mailInfo.hasForward()?View.VISIBLE:View.INVISIBLE);
			int asteriskValue = mailInfo.getAsterisk();
			//init AsteriskBtnBackGround
			if(asteriskValue==1)
			{
				holder.starBtn.setBackgroundResource(R.drawable.btn_star_big_buttonless_on);
			}
			else
			{
				holder.starBtn.setBackgroundResource(R.drawable.btn_star_big_buttonless_off);
			}
			holder.starBtn.setTag(mailInfo);

			if (mailInfo.getState() != MailStatus.MAIL_READED)
			{
				convertView.setBackgroundResource(R.drawable.mail_unread_bg);
			}
			else
				convertView.setBackgroundResource(R.drawable.mail_read_bg);

//			if(position == 0)
//			{
//				convertView.setPadding(2,10, 2, 2);
//			}
			if (showGestureDelButton(mailInfo))
			{
				holder.mailDelBtn.setVisibility(View.VISIBLE);
	            holder.mailDelBtn.setTag(mailInfo);
			}
			else
			{
				holder.mailDelBtn.setVisibility(View.GONE);
			}
			_ctx.updateMailItemView(mailInfo, holder, convertView); //fix bug 395
			return convertView;
		}
		private boolean showGestureDelButton(MailInfo info)
		{
			if(_ctx.gesturePosition < 0)
				return false;
			if(ExpandableListView.getPackedPositionType(_ctx.gesturePosition) == ExpandableListView.PACKED_POSITION_TYPE_CHILD)
			{
				int groupPos = ExpandableListView.getPackedPositionGroup(_ctx.gesturePosition);
				int childPos = ExpandableListView.getPackedPositionChild(_ctx.gesturePosition);
				MailGroup g = _ctx.getGroup(groupPos);
				MailInfo info2 = g.getMailInfo(childPos);
				return info2 != null && info2.equals(info);
			}
			else if(ExpandableListView.getPackedPositionType(_ctx.gesturePosition) == ExpandableListView.PACKED_POSITION_TYPE_GROUP)
			{
				int groupPos = ExpandableListView.getPackedPositionGroup(_ctx.gesturePosition);
				MailGroup g = _ctx.getGroup(groupPos);
				return (g.getGroupSize() == 1 && info.equals(g.getMailInfo(0)));
			}
			return false;
		}

        

		@Override
		public View getChildView(int groupPosition, int childPosition,
				boolean isLastChild, View convertView, ViewGroup parent) {
			MailInfo mailInfo = _ctx.getGroup(groupPosition).getMailInfo(childPosition);
			
			View view=getMailView(mailInfo, convertView);
			TextView expandMarkView=(TextView)view.findViewById(R.id.expand_mark_child);
			expandMarkView.setVisibility(View.VISIBLE);
//			expandMarkView.setHeight(view.getHeight());
			
			return view;
		}
			
		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}
	}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Timer;
import java.util.TimerTask;

import mobi.cloudymail.data.InMailInfo;
import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.mailclient.net.DownloadAttaTask;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.util.MessageBox;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import android.app.Activity;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Parcelable;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.webkit.WebChromeClient;
import android.webkit.WebSettings;
import android.webkit.WebSettings.RenderPriority;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.ProgressBar;
import android.widget.Toast;

public class MailViewer extends BaseActivity 
{
	public static MailViewer instance = null;

	public static final String PREVIOUS_MAIL = "preMail";
	public static final String NEXT_MAIL = "nextMail";
	public static final String DEL_MAIL = "delMail";

	private MyWebView _htmlView = null;
	private ProgressBar _progresBar = null;
	private String _currentUrl = "";
	// private Button _attachBtn = null;
	private String refMailBody = null;
	
	private boolean hasAttachFlag;
	
	private Resources res = MyApp.instance().getResources();
	
	private final class MailWebViewClient extends WebViewClient
	{
		private final Activity activity;

		private MailWebViewClient(Activity activity)
		{
			this.activity = activity;
		}

		@Override //never called ? 
		public boolean shouldOverrideUrlLoading(WebView view, String url)
		{
			
			Uri uri = Uri.parse(url);
			URL currentUrl;
			try
			{
				currentUrl = new URL(view.getUrl());
				//Judge whether the current mailView, if is open mailView, or is the external browser
				if (!currentUrl.getHost().equalsIgnoreCase(uri.getHost()))
				{
					Intent intent = new Intent(Intent.ACTION_VIEW, uri);
					startActivity(intent);
				}
				else
				{
					view.loadUrl(url);
				}
			}
			catch (MalformedURLException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			// Log.d("shouldOverrideUrlLoading", url);
			return true;

		}

		@Override
		public void onPageStarted(WebView view, String url,
				android.graphics.Bitmap favicon)
		{
			Log.d(LOGTAG, "onPageStarted" + url);
			showProgressBar(true);
		}

		@Override
		public void onPageFinished(WebView view, String url)
		{
			Log.d(LOGTAG, "onPageFinished" + url);
			if (url.equals("about:relogin"))
			{
				view.stopLoading();
				if (MyApp.getAgent().interactiveLogin(false,true,true))
				{
					view.stopLoading();
					String tmpUrl = _currentUrl;
					int pos = tmpUrl.indexOf("sid=");
					if (pos > 0)
						tmpUrl = tmpUrl.substring(0, pos)
									+ "sid="
									+ java.net.URLEncoder.encode(MyApp
											.getAgent().getSessionId(false,true,true));
					else
						tmpUrl += "&sid="
									+ java.net.URLEncoder.encode(MyApp
											.getAgent().getSessionId(false,true,true));
					view.loadUrl(tmpUrl);
				}
				else
					finish(); // since login failed or canceled, back to
								// previous step
				return;
			}
			// MyApp.curMailInfo will be null if MailViewer activity finished
			// before HTML load complete
			if (MyApp.curMailInfo == null)
				return;
			if (MyApp.curMailInfo.getAsterisk() != 0)
			{
				final Timer t = new Timer();
				t.schedule(new TimerTask() {

					@Override
					public void run()
					{
						_htmlView.loadUrl("javascript:setStarOn();");
						t.cancel();
					}
				}, 100);
			}

			_currentUrl = url;
			showProgressBar(false);
			// _htmlView.loadUrl("javascript:window.HTMLOUT.showHTML(document.getElementsByTagName('html')[0].innerHTML);");
		}

		@Override
		public void doUpdateVisitedHistory(WebView view, String url,
				boolean isReload)
		{
			Log.d(LOGTAG, "doUpdateVisitedHistory" + url);
		}

		@Override
		public void onLoadResource(WebView view, String url)
		{
			Log.d(LOGTAG, "onLoadResource " + url);
		}

		@Override
		public void onReceivedError(WebView view, int errorCode,
				String description, String failingUrl)
		{
//			Toast.makeText(activity, "Oh no! " + description,
//							Toast.LENGTH_SHORT).show();
		}
		// public void onPageStarted (WebView view, String url, Bitmap
		// favicon)
		// {
		//
		// }
	}

	private final class MailChromeClient extends WebChromeClient
	{
		@Override
		public void onProgressChanged(WebView view, int progress)
		{
			_progresBar.setProgress(progress);
		}
		// @Override
		// public boolean onJsAlert(WebView view, String url, String message,
		// android.webkit.JsResult result)
		// {
		// Log.d(LOGTAG, "JSAlert:"+message);
		// result.confirm();
		// return true;
		// }
	}
	
	static public boolean isSdCardAvailable(Activity activity)
	{
		Resources res = MyApp.instance().getResources();
		String state = Environment.getExternalStorageState();
		if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))
		{
			MessageBox.show(activity, res.getString(R.string.atta_sdcardReadOnly),
							res.getString(R.string.error));
			return false;
		}
		else if (!Environment.MEDIA_MOUNTED.equals(state))
		{
			MessageBox.show(activity,
							res.getString(R.string.atta_sdcardNotAvailable),
							res.getString(R.string.error));
			return false;
		}
		return true;
	}
	
	static public String getAvailableFilePathToSave(String fileName)
	{
		File sdCardDir = Environment.getExternalStorageDirectory();
		Log.d("SDCard dir:", sdCardDir.toString());
		File storeFile = new File(sdCardDir,fileName);
		Log.d("save to:", storeFile.toString());
		int i = 1;
		while (storeFile.exists())
		{
			String attInfoFileName = fileName;
			String attInfoFileFormat = "";
			int pointIndex = fileName.lastIndexOf(".");
			if(pointIndex >=0)
			{
				attInfoFileName = fileName.substring(0, pointIndex);
				attInfoFileFormat = fileName.substring(pointIndex, fileName.length());
			}
			String storeFileName = attInfoFileName + "(" + i + ")"+attInfoFileFormat;
			
			storeFile = new File(sdCardDir, storeFileName);
			i++;
		}
		return storeFile.getAbsolutePath();
	}

	class CmailScriptInterface 
	{
		
        public void addAttachInfo(int attachIndex,String fileName,
        							String size,String fileType,boolean previewFlag)
        {
        	//if loaded before, do not insert into database.
        	if(MyApp.curMailInfo.getAttachment(attachIndex) != null)
        		return;
        	AttachmentInfo attach = new AttachmentInfo(MyApp.curMailInfo);
        	attach.index = attachIndex;
        	attach.fileName = fileName;
        	attach.size = size;
        	attach.canPreview = previewFlag;
        	attach.fileType = fileType;
        	MyApp.curMailInfo.addAttachInfo(attach);
        	
        	NewDbHelper.getInstance().insertAttachInfo(attach,MyApp.curMailInfo.getAccountId());
        	/**Data stored in the Attach*/
//        	NewDbHelper.getInstance().getAttachmentInfo();
        }
        public void setHasAttachment(boolean attach)
        {
        }
		public void reply()
		{
			MailViewer.this.openComposer(Composer.COMPOSER_REPLY);
		}

		public void importCalendarAttachment(final int attachmentIndex, final String fileName)
		{
			try {
				downloadAttachment(attachmentIndex, true);
			}
			catch (Exception e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}
		
		public void downloadAttachment(final int attachmentIndex, final boolean isCalendarImport)
		{		
			if(!isSdCardAvailable())
			{
				MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.atta_sdcardNotAvailable), res.getString(R.string.atta_sdcardTitle));
				return; 
			}
				 
			AttachmentInfo attach = MyApp.curMailInfo.getAttachment(attachmentIndex);
				        	
			File sdCardDir=Environment.getExternalStorageDirectory();
			Log.d("SDCard dir:", sdCardDir.toString());
			File storeFile=new File(sdCardDir,attach.fileName);
			Log.d("save to:", storeFile.toString());
			int i=1;
			while(storeFile.exists())
			{
				String attInfoFileName=attach.fileName;
				String attInfoFileFormat="";
				int pointIndex=attach.fileName.lastIndexOf(".");
				if(pointIndex>=0)
				{
					attInfoFileName=attach.fileName.substring(0,pointIndex);
				    attInfoFileFormat=attach.fileName.substring(pointIndex, attach.fileName.length());
				}
				String storeFileName=attInfoFileName+"("+i+")"+attInfoFileFormat;
				storeFile=new File(sdCardDir,storeFileName);
				i++;
			}
			new DownloadAttaTask(attach, null, isCalendarImport).execute(storeFile.getAbsolutePath());
		}
		
		public void openAttachment(final int attachmentIndex,final String attachmentName)
		{
			runOnUiThread(new Runnable() {

				@Override
				public void run()
				{
					showAttachmentView(attachmentIndex,attachmentName);
				}

			});
		}

		private boolean isSdCardAvailable() {
			Resources res=MyApp.instance().getResources();
			String state=Environment.getExternalStorageState();
			if(Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))
			{
				MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.atta_sdcardReadOnly),res.getString(R.string.error));
				return false;
			}
			else if(!Environment.MEDIA_MOUNTED.equals(state))
			{
				MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.atta_sdcardNotAvailable), 
						        MyApp.getCurrentActivity().getString(R.string.error));
			    return false;
			}
			return true;
		}
		

		public void replyAll()
		{
			MailViewer.this.openComposer(Composer.COMPOSER_REPLYALL);
		}

		public void forward()
		{
			MailViewer.this.openComposer(Composer.COMPOSER_FORWARDMAIL);
		}

		/**
		 * 
		 * @param state
		 *            "1" or "0" for has star or not
		 */
		public void setStar(String state)
		{
			MailInfo mailInfo = MyApp.curMailInfo;
			
			int asteriskState = Integer.parseInt(state);
			
			NewDbHelper.getInstance().updateInAsteriskstatu(mailInfo.getAccountId(), asteriskState, mailInfo.getUidx(), mailInfo.getFolder());

		}

		public void setMailBody(String mail)
		{
			refMailBody = mail;
		}

		public void showHTML(String html)
		{
			/*
			 * new AlertDialog.Builder(MailViewer.this) .setTitle("HTML")
			 * .setMessage(html) .setPositiveButton(android.R.string.ok, null)
			 * .setCancelable(false) .create() .show();
			 */
			MailInfo curMailInfo = MyApp.curMailInfo;
			// only update the mail content if mail is the first time to read.
			if (curMailInfo.getBody() != null
				&& (!curMailInfo.getBody().equals("") || html.equals("")))
				return;
			curMailInfo.setBody(html);
			NewDbHelper.getInstance().updateMailBody((InMailInfo) curMailInfo);
		}
	}

	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		instance = MailViewer.this;
		// Window win = getWindow();
		// win.requestFeature(Window.FEATURE_LEFT_ICON);
		// win.requestFeature(Window.FEATURE_PROGRESS);
		setContentView(R.layout.mail_viewer);
		// win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON,
		// R.drawable.cloudymail);

		_htmlView = (MyWebView) findViewById(R.id.htmlMailView);
		// _htmlView = new MyWebView(this);
		_progresBar = (ProgressBar) findViewById(R.id.maiViewProgressBar);


		MailInfo curMailInfo = MyApp.curMailInfo;
		// _subTextView.setText(curMailInfo.subject);
		// Let's display the progress in the activity title bar, like the
		// browser app does.
		WebSettings setting = _htmlView.getSettings();
		Log.d(Utils.LOGTAG, "Cache Mode:" + setting.getCacheMode());
		
		_htmlView.getSettings().setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);
		_htmlView.getSettings().setJavaScriptEnabled(true);
		_htmlView.getSettings().setBuiltInZoomControls(true);
		_htmlView.getSettings().setRenderPriority(RenderPriority.HIGH);
		_htmlView.addJavascriptInterface(new CmailScriptInterface(), "cmail");
		final Activity activity = this;
		_htmlView.setWebChromeClient(new MailChromeClient());
		
		// try
		// {
		// Log.d(LOGTAG,
		// "Cache dir:"+CacheManager.getCacheFileBaseDir().getCanonicalPath());
		// }
		// catch (IOException e1)
		// {
		//
		// }
		_htmlView.setWebViewClient(new MailWebViewClient(activity));
		// prgDialog.show();
		// lstView = (ListView)findViewById(R.id.mvVirtualListView);
		// lstView.setAdapter(new VirtualListAdapter(this,
		// _htmlView,MyApp.curMailInfo));
		showProgressBar(true);
		String mbody = curMailInfo.getBody();
		if (mbody == null || mbody.equals(""))
		{
			String sid = MyApp.getAgent().getSessionId(true,true,true);
			if (sid == null)
			{
				finish();
				return;
			}
			String urlStr = ServerAgent.getUrlBase()
							+ "/MailRender?uid="
							+ java.net.URLEncoder.encode(curMailInfo.getUid())
							+ "&folderName="
							+ java.net.URLEncoder.encode(MyApp.curMailInfo.getFolder())
							+ "&multipage="
							+ (MyApp.userSetting.showMultipage	? "true"
																: "false")
							+ "&pageNo=0&sid="
							+ java.net.URLEncoder.encode(sid);
			Log.d(LOGTAG, "Opening mail:" + urlStr);
			_htmlView.loadUrl(urlStr);
		}
		else
		{
			_htmlView.loadDataWithBaseURL(	ServerAgent.getUrlBase() + "/",
											curMailInfo.getBody(), "text/html",
											"utf-8", ServerAgent.getUrlBase());
			showProgressBar(false);
		}
	}

	private void showProgressBar(boolean visible)
	{
		_progresBar.setVisibility(visible ? View.VISIBLE : View.GONE);
		
	}

	@Override
	protected void onStop()
	{
		super.onStop();
		_htmlView.stopLoading();
	}

	public void openComposer(int type)
	{
		Intent intent = new Intent(this, Composer.class);
		intent.putExtra("composer_type", type);
		if (type == Composer.COMPOSER_REPLYALL)
			intent.putExtra("ccList", MyApp.curMailInfo.getCc());
		// _htmlView.loadUrl("javascript:window.cmail.setMailBody(mailBody.innerHTML);");
		intent.putExtra("refMailBody", refMailBody);
		intent.putExtra("hasAttachment", hasAttachFlag);
		startActivity(intent);
	}

	private void showAttachmentView(int attachmentIndex, String attachmentName)
	{
		MailInfo curMailInfo = MyApp.curMailInfo;
		if (curMailInfo == null || !curMailInfo.hasAttachment())
			return;
		if (MyApp.getAgent(	AccountManager.getAccount(MyApp.curMailInfo
									.getAccountId())).getSessionId(true,true,true) == null)
		{
			MessageBox.show(this, "Internal error, need login", "Error");
			return;
		}
		// login failed
		// if attachment list is not get yet, get from server. do this in
		// mailinfo.
		/*
		 * if(curMailInfo._attachments.isEmpty()) { try { HttpGet req = new
		 * HttpGet(ServerAgent.urlBase + "/AttachList?uid=" +
		 * Utils.escapeStr(curMailInfo.uid)); HttpResponse rsp =
		 * ServerAgent.execute(req); Result result = new
		 * Result(rsp.getEntity().getContent()); Element element =
		 * result.xmlReader; NodeList nodes =
		 * element.getElementsByTagName("attach"); int nodeCount =
		 * nodes.getLength(); for(int i = 0; i < nodeCount; i++) { Element
		 * attachElement = (Element)nodes.item(0); Log.d("attachment name",
		 * attachElement.getAttribute("name")); Log.d("attachment size",
		 * attachElement.getAttribute("size")); Log.d("attachment preview",
		 * attachElement.getAttribute("preview")); } } catch (Exception e) { //
		 * TODO: handle exception e.printStackTrace(); } }
		 */

		
//		intent.putExtra(name, value);
		
		Intent intent = new Intent(this, AttachmentViewer.class);
		intent.putExtra(AttachmentViewer.ATTACHMENT_INFO, (Parcelable)curMailInfo.getAttachment(attachmentIndex));
		startActivity(intent);
	}

	@Override
	public boolean onKeyUp(int keyCode, KeyEvent event)
	{
		if (keyCode == KeyEvent.KEYCODE_MENU)
		{
			Intent intent = this.getIntent();
			Intent newIntent = new Intent(MailViewer.this,TranslucentButton.class);
			newIntent.putExtra(MailViewer.PREVIOUS_MAIL,intent.getBooleanExtra(PREVIOUS_MAIL, true));
			newIntent.putExtra(MailViewer.NEXT_MAIL,intent.getBooleanExtra(NEXT_MAIL, true));
			newIntent.putExtra(MailViewer.DEL_MAIL,intent.getBooleanExtra(DEL_MAIL, true));
			startActivityForResult(newIntent, 1);
			overridePendingTransition(R.anim.fade, R.anim.hold);
		}
		return super.onKeyUp(keyCode, event);
	}

	@Override
	protected void onActivityResult(int reqCode, int rstCode, Intent intent)
	{
		MyApp.setCurrentActivity(this);
		if (reqCode == 1) // override menu bar activity finished
		{
			switch (rstCode)
			{
			case R.id.last:
				setResult(R.id.last);
				finish();
				break;
			case R.id.next:
				setResult(R.id.next);
				finish();
				break;
			case R.id.delMail:
				setResult(R.id.delMail);
				finish();
				break;
			case R.id.replyMail:
				openComposer(Composer.COMPOSER_REPLYALL);
				break;
			}
		}
	}
}


package mobi.cloudymail.mailclient;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.PorterDuffXfermode;
import android.graphics.Bitmap.Config;
import android.graphics.PorterDuff.Mode;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.Drawable;

public class MyImgView {

	/**
	 * 娣诲褰憋锛缈昏浆剧锛变颁惧ぇ搴?
	 * 
	 * @param originalImage
	 * @return
	 */
	public static Bitmap createReflectedImage(Bitmap originalImage) {
		// The gap we want between the reflection and the original image
		final int reflectionGap = 4;

		int width = originalImage.getWidth();
		int height = originalImage.getHeight();

		// This will not scale but will flip on the Y axis
		Matrix matrix = new Matrix();
		matrix.preScale(1, -1);

		// Create a Bitmap with the flip matrix applied to it.
		// We only want the bottom half of the image
		Bitmap reflectionImage = Bitmap.createBitmap(originalImage, 0,
				height / 2, width, height / 2, matrix, false);

		// Create a new bitmap with same width but taller to fit reflection
		Bitmap bitmapWithReflection = Bitmap.createBitmap(width,
				(height + height / 2), Config.ARGB_8888);

		// Create a new Canvas with the bitmap that's big enough for
		// the image plus gap plus reflection
		Canvas canvas = new Canvas(bitmapWithReflection);
		// Draw in the original image
		canvas.drawBitmap(originalImage, 0, 0, null);
		// Draw in the gap
		Paint defaultPaint = new Paint();
		canvas.drawRect(0, height, width, height + reflectionGap, defaultPaint);
		// Draw in the reflection
		canvas.drawBitmap(reflectionImage, 0, height + reflectionGap, null);

		// Create a shader that is a linear gradient that covers the reflection
		Paint paint = new Paint();
		LinearGradient shader = new LinearGradient(0,
				originalImage.getHeight(), 0, bitmapWithReflection.getHeight()
						+ reflectionGap, 0x70ffffff, 0x00ffffff, TileMode.CLAMP);
		// Set the paint to use this shader (linear gradient)
		paint.setShader(shader);
		// Set the Transfer mode to be porter duff and destination in
		paint.setXfermode(new PorterDuffXfermode(Mode.DST_IN));
		// Draw a rectangle using the paint with our linear gradient
		canvas.drawRect(0, height, width, bitmapWithReflection.getHeight()
				+ reflectionGap, paint);

		return bitmapWithReflection;
	}
	//drawable 绫诲杞涓bitmap
	public static Bitmap drawableToBitmap(Drawable drawable) {

		Bitmap bitmap = Bitmap
				.createBitmap(
						drawable.getIntrinsicWidth(),
						drawable.getIntrinsicHeight(),
						drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888
								: Bitmap.Config.RGB_565);
		Canvas canvas = new Canvas(bitmap);
		// canvas.setBitmap(bitmap);
		drawable.setBounds(0, 0, drawable.getIntrinsicWidth(), drawable
				.getIntrinsicHeight());
		drawable.draw(canvas);
		return bitmap;
	}

}
package mobi.cloudymail.mailclient;

import android.content.Context;
import android.util.AttributeSet;
import android.webkit.WebView;


public class MyWebView extends WebView 
{
	public MyWebView(Context ctx)
	{
		super(ctx);
	}
	
	public MyWebView(Context ctx, AttributeSet attrs)
	{
		super(ctx,attrs);
	}
	
	public MyWebView(Context ctx, AttributeSet attrs, int defStyle)
	{
		super(ctx,attrs,defStyle);
	}
	
	protected int computeVerticalScrollExtent ()
	{
		 float density = getResources().getDisplayMetrics().density;
		 return super.computeVerticalScrollExtent()+(int)(60*density);
	}
	
	protected int computeVerticalScrollRange() {
        float density = getResources().getDisplayMetrics().density;
        return super.computeVerticalScrollRange()+(int)(60*density);
   }
	
	public void	 onScrollChanged(int l, int t, int oldl, int oldt)
	{
		super.onScrollChanged(l, t, oldl, oldt);
		//Log.d(LOGTAG,"++++++++scroll changed+++++++"+ "horizon:"+l+", Vertical:"+t);
	}
}
package mobi.cloudymail.mailclient.net;

import java.io.Serializable;

import org.simpleframework.xml.Attribute;

public class Account implements Serializable
{
	/**
	 * 
	 */
	private static final long serialVersionUID = -8600595852655158891L;
	public static final int pop3DefaultPort = 110;
	public static final int imapDefaultPort = 143;
	public static final int smtpDefaultPort = 25;
	
	//[SoapIgnore]
	public int id = 0;
	/// <summary>
	/// the complete email name of this account, like 'liu_lele@126.com'
	/// </summary>
	@Attribute
	public String name;

	/// <summary>
	/// login name used by authentication. for example, liu_lele is the 
	/// loginName for above email
	/// </summary>
	@Attribute
	public String loginName;

	/// <summary>
	/// address of receiver server, can be domain name or IP of pop3 or imap
	/// </summary>
	@Attribute
	public String mailServer;
	@Attribute
	public String smtpServer;
	@Attribute
	public String serverType = "pop3"; //pop3 or imap

	//TODO: make sure _mailPort is serialized as getMailPort()'s return value
	@Attribute(name="mailPort")
	private int _mailPort = 0;
//	[XmlAttribute(AttributeName = "mailPort")]
	public int getMailPort()
	{
			if(_mailPort == 0)
			{
				if(serverType == "pop3")
				{
					return pop3DefaultPort;
				}
				else if(serverType == "imap")
				{
					return imapDefaultPort;
				}
			}
			return _mailPort;
	}
	
	public void setMailPort(int value)
	{
		_mailPort = value;
	}
	
	@Attribute
	public int smtpPort = 25;
	@Attribute
	public boolean useSSL;
	@Attribute
	public String password;
	
	public boolean promptForPOPIMAP = false;
	
	public boolean isPromptForPOPIMAP()
	{
		return promptForPOPIMAP;
	}

	public void setPromptForPOPIMAP(boolean promptForPOPIMAP)
	{
		this.promptForPOPIMAP = promptForPOPIMAP;
	}

	public String toString() 
	{
		return name;
	}
	
	public String getHostName()
	{
		if(name == null)
			return "";
		int pos = name.indexOf('@');
		if(pos == -1)
			return "";
		return name.substring(pos+1);
	}
	
	
	public boolean isValid()
	{
		if(name == null || this.loginName == null || this.mailServer == null || this.serverType == null ||
				this.mailServer == null || this.smtpServer == null )
			return false;
		if(name.equals("") || loginName.equals("") || mailServer.equals("") || (!serverType.equals("pop3")&&!serverType.equals("imap")) ||
				mailServer.equals("") || smtpServer.equals(""))
			return false;
		if(!isPortValid(smtpPort))
			return false;
		if(_mailPort != 0 && !isPortValid(_mailPort))
			return false;
		return true;
	}
	
	public static boolean isPortValid(int portNum)
	{
		if(portNum <= 0 || portNum > 65535)
			return false;
		return true;
	}
	
	public void clear()
	{
		name = null;
		loginName = null;
		mailServer = null;
		mailServer = null;
		smtpServer = null;
	}
	
	public String toXmlString()
	{
		StringBuilder sb = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n").append("<account ");
		sb.append("name='");
		sb.append("' password='").append(password);
		sb.append("' loginName='").append(loginName);
		sb.append("' mailServer='").append(mailServer);
		sb.append("' smtpServer='").append(smtpServer);
		sb.append("' serverType='").append(serverType);
		sb.append("' smtpPort='").append(smtpPort);
		sb.append("' useSSL='").append(useSSL);
		sb.append("' mailPort='").append(getMailPort());
		sb.append("'/>");
		return sb.toString();
	}
	
	public void setDefault()
	{
		smtpPort = smtpDefaultPort;
		_mailPort = pop3DefaultPort;
		useSSL = false;
		if(name == null)
			return;
		int pos = name.indexOf("@");
		if(pos<1)
			return;
		serverType = "pop3";
		String domain = name.substring(pos+1);
		loginName = name.substring(0, pos);		
		mailServer = "pop3."+domain;
		smtpServer = "smtp."+domain;		
	}

	public int getIdleRefreshMinutes()
	{
		return 20;
	}
	
	public boolean isImap()
	{
		return "imap".equalsIgnoreCase(serverType);
	}
}

package mobi.cloudymail.mailclient.net;

import java.io.File;
import java.io.Serializable;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.mailclient.R;

import org.simpleframework.xml.Attribute;
import org.simpleframework.xml.Element;
import org.simpleframework.xml.Transient;

import android.os.Parcel;
import android.os.Parcelable;


	public class AttachmentInfo implements Serializable, Parcelable
	{
		/**
		 * 
		 */
		@Transient
		private static final long serialVersionUID = -3505454732504893305L;
		@Transient
		public static final int LOCAL_ATTACH_INDEX = -1;
		@Transient
		public static final int ALL_REFATTACH_INDEX = -2;
		
		@Element
		public String fileName="";
		
		//only for local attachment.
		@Transient
		public String fullFilePath;
		@Element
		public int index = -1; //index of this attachment in its container mail, 
							   //-1 means its from local
							   //-2 means all original attachments from referenced mail
								
		@Element
	//	public byte[] body; //body of the attachment, used to upload local created attachment to server
		public String body="";
		//		@Attribute(required=false)
		@Attribute
		public String size; //size in string, may 100Bytes, 10K, 1M, etc
		@Attribute(required=false)
		public boolean canPreview;
		@Transient
		public String fileType;
		
		@Transient
		MailInfo mailInfo;
		
		
		@Transient
		public String getFileType() {
			return fileType;
		}
		@Transient
		public void setFileType(String fileType) {
			this.fileType = fileType;
		}
		@Transient
		
		
		public AttachmentInfo(MailInfo mail)
		{
			mailInfo = mail;
		}
		
		public AttachmentInfo(MailInfo mail, int index)
		{
			mailInfo = mail;
			this.index = index;
		}
		
		
		
		@Transient
		public String getAttachSize() {
			return size;
		}
		@Transient
		public void setAttachSize(String attachSize) {
			this.size = attachSize;
		}
		@Transient
		public int getAttachIndx() {
			return index;
		}
		@Transient
		public void setAttachIndx(int attachIndx) {
			this.index = attachIndx;
		}
		@Transient
		public String getMailUid()
		{
			return mailInfo.getUid();
		}
		@Transient
		public int getAccountId()
		{
			return mailInfo.getAccountId();
		}
		@Override
		public int describeContents() {
			return 0;
		}
		@Override
		public void writeToParcel(Parcel dest, int flags) {
			dest.writeSerializable(this);
			
		}
		
		public static final Parcelable.Creator<AttachmentInfo> CREATOR = new Parcelable.Creator<AttachmentInfo>() {
		    public AttachmentInfo createFromParcel(Parcel in) {
		    	return (AttachmentInfo) in.readSerializable();
		    }
		
		    public AttachmentInfo[] newArray(int size) {
		        return new AttachmentInfo[size];
		    }
};
		@Transient
		public Date getMailDate() {
			// TODO Auto-generated method stub
			return mailInfo.getDate();
		}
		@Transient
		public MailInfo getMailInfo() {
			// TODO Auto-generated method stub
			return mailInfo;
		}
		
		public boolean isFilePathValid()
		{
			if(fullFilePath == null || fullFilePath.equals(""))
				return false;
			return new File(fullFilePath).exists();
		}
	}
package mobi.cloudymail.mailclient.net;

import java.util.List;

import org.simpleframework.xml.Attribute;
import org.simpleframework.xml.Element;
import org.simpleframework.xml.ElementList;



public class DataPacket 
{
	private static final long serialVersionUID = -8601295852655158891L;
	//type in mail server.
	public static final String NEWMAIL_TYPE = "newMail";
	public static final String REPLYMAIL_TYPE = "replyMail";
	public static final String FORWARDMAIL_TYPE = "forwardMail";

	@Attribute
	public String packetType = NEWMAIL_TYPE;
	@Element
	public String subject = null;
	@Element
	public String toList = null;
	@Element
	public String ccList = null;
	@Element
	public String bccList = null;
	@Element
	public String bodyText = null;
	@Attribute
	public String refMailId = "";
	@Attribute
	public String refMailFolder="";
	@Attribute
	public boolean quoteOld = false;
	@Attribute
	public boolean forwardAttach = false;
	@ElementList(type=AttachmentInfo.class)
	public List<AttachmentInfo> attachments;
}package mobi.cloudymail.mailclient.net;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.util.Iterator;

import mobi.cloudymail.mailclient.AccountManager;
import mobi.cloudymail.mailclient.MailViewer;
import mobi.cloudymail.mailclient.R;
import mobi.cloudymail.util.DialogUtils;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import net.fortuna.ical4j.data.CalendarBuilder;
import net.fortuna.ical4j.data.ParserException;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.Component;
import net.fortuna.ical4j.model.Date;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.Property;
import net.fortuna.ical4j.model.parameter.Value;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.HttpGet;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.ContentValues;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Environment;
import android.os.Handler;
import android.util.Log;
import android.widget.Toast;


public class DownloadAttaTask extends AsyncTask<String, Integer, String>
{
	private Resources res = MyApp.instance().getResources();
	private ProgressDialog prgDialog = null;//new ProgressDialog(MailViewer.this);
	private File storeFile;
	private int attachIndex;
	//file in rar/zip will have this property.
	private String internalPath=null;
	private String sid = null;
	private String mailUid = null;
	private String mailFolder=null;
	private int accountId=0;
	private Handler handler = null;
	private AttachmentInfo attachInfo;
	private boolean _isCalendarImport; 
	
	private static String calendarURIBase = "";
	
	static {
		if (Integer.parseInt(Build.VERSION.SDK) >= 8) {
			calendarURIBase = "content://com.android.calendar";
		} else {
			calendarURIBase = "content://calendar";
		}
	}
	
	public DownloadAttaTask(AttachmentInfo attachInfo,String internalPath, boolean isCalendarImport)
	{
		this.attachInfo = attachInfo;
		this.attachIndex = attachInfo.getAttachIndx();
		prgDialog = new ProgressDialog(MyApp.getCurrentActivity());
		this.internalPath = internalPath;
		this.mailFolder=attachInfo.getMailInfo().getFolder();
		this.mailUid = attachInfo.getMailUid();
		this.accountId = attachInfo.getAccountId();
		this._isCalendarImport = isCalendarImport;
	}
	
	public void setHandler(Handler hd)
	{
		handler = hd;
	}
	
	@Override
	protected String doInBackground(String... fileNames)
	{
		if(sid == null)
			return res.getString(R.string.failLogin);
		// int count = attaInfos.length;
//		AttachmentInfo attInfo = _attachments.get(selectedIdx);// MailClient.curMailInfo.getAttachment(selectedIdx);
		String fileName = fileNames[0];
		String errStr = "";
		HttpGet req = null;

		try
		{
			String reqUrl = ServerAgent.getUrlBase()
							+ "/DownloadPart?uid="
							+ java.net.URLEncoder.encode(mailUid)
							+ "&folderName="
							+ java.net.URLEncoder.encode(mailFolder)
							+"&index=" + attachIndex+"&sid="+java.net.URLEncoder.encode(sid);
			if(internalPath!=null && !internalPath.equals(""))
				reqUrl += "&internalPath="+java.net.URLEncoder.encode(internalPath);
			req = new HttpGet(reqUrl);
     //			File sdCardDir = Environment.getExternalStorageDirectory();
			
			storeFile = new File(fileName);
	//		Log.d(LOGTAG, "AsyncTask:get attachment:" + reqUrl);
	//		Log.d(LOGTAG, "AsyncTask:save to:" + storeFile.toString());
			HttpResponse rsp = ServerAgent.execute(req);
			if (HttpStatus.SC_OK == rsp.getStatusLine().getStatusCode())
			{
				HttpEntity entity = rsp.getEntity();
				if (entity == null)
					return "No content downloaded";
				Log.d(LOGTAG, "attach:" + fileName + " "
								+ entity.getContentType().getName());
				Log.d(	LOGTAG,
						"attach:" + fileName + " "
								+ String.valueOf(entity.isStreaming()));
				String state = Environment.getExternalStorageState();
				if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state))
				{
					return res.getString(R.string.atta_sdcardReadOnly);
				}
				else if (!Environment.MEDIA_MOUNTED.equals(state))
				{
					return res.getString(R.string.atta_sdcardNotAvailable);
				}

				FileOutputStream outStream = new FileOutputStream(storeFile);
				InputStream input = entity.getContent();
				byte b[] = new byte[1024];
				int j = 0;
				while ((j = input.read(b)) != -1)
				{
					outStream.write(b, 0, j);
				}
				outStream.flush();
				outStream.close();
				if (entity != null)
				{
					entity.consumeContent();
				}
			}
			// publishProgress(result);
		}
		catch (Exception e)
		{
			e.printStackTrace();
			return e.getMessage();
		}
		return errStr;
	}

	@Override
	protected void onPreExecute()
	{
		Account a = AccountManager.getAccount(accountId);
		sid=MyApp.getAgent(a).getSessionId(true, true, true);
		if(sid == null)
			return;
		prgDialog.setMessage(res.getString(R.string.atta_downloading));
		prgDialog.show();
	}

	@Override
	protected void onProgressUpdate(Integer... progress)
	{
		// setProgressPercent(progress[0]);
	}

	@Override
	protected void onPostExecute(String result)
	{
		if(sid == null)
			return;
		prgDialog.dismiss();
		if(result == null)
			result = "下载附件失败";
		if (result.equals(""))
		{
			String path = "";
			try
			{
				path = storeFile.getCanonicalPath();
			}
			catch (Exception e)
			{
				path = storeFile.getAbsolutePath();
			}
			//if it's a internal file in rar/zip attachment,ignore it
			if (internalPath == null || internalPath.equals(""))
			{
				// update attachmentInfo table.
				if (NewDbHelper.getInstance()
						.updateAttachFilePath(accountId, mailUid,mailFolder, attachIndex,path))
					attachInfo.fullFilePath = path;
			}
			Toast.makeText(MyApp.getCurrentActivity(),
							res.getString(R.string.atta_fileSaved)+path,
							Toast.LENGTH_SHORT).show();
			//send sessage to attached activity
			if(handler!=null)
				handler.sendEmptyMessage(1);
			
			if(this._isCalendarImport) {
				try {
					importCalendarEvents(storeFile);
				} catch (ParseException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		else
		{
			Log.d("download failed:", result);
			// MessageBox.show(AttachmentList.this,result,
			// getResources().getString(R.string.error));
			DialogUtils.showMsgBox(	MyApp.getCurrentActivity(), result,
			                       	MyApp.getCurrentActivity().getResources()
											.getString(R.string.error));
		}
	}
	
	public static void importCalendarEvents(File calendarFile) throws ParseException 
	{
		FileInputStream fin = null;
		try {
			fin = new FileInputStream(calendarFile);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		CalendarBuilder builder = new CalendarBuilder();
		
		Calendar calendar = null;
		try {
			calendar = builder.build(fin);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ParserException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		for (Iterator i = calendar.getComponents().iterator(); i.hasNext();) {
			Component component = (Component) i.next();
			System.out.println("Component [" + component.getName() + "]");
				
			ContentValues event = new ContentValues(); 
			Property property = null;
			String value = null;
			
			//insert description
			property = component.getProperty(Property.SUMMARY);
			if(property!=null) {
				value = property.getValue();
				event.put("description", value); 
			}
			
			//insert event time zone
			property = component.getProperty(Property.TZNAME);
			if(property!=null) {
				value = property.getValue();
				event.put("eventTimezone", value); 
			}
			
			//insert event location
			property = component.getProperty(Property.LOCATION);
			if(property!=null) {
				value = property.getValue();
				event.put("eventLocation", value); 
			}
			
			//insert event title
			property = component.getProperty(Property.NAME);
			if(property!=null) {
				value = property.getValue();
				event.put("title", value);
			}
			
			//insert event rrule
			property = component.getProperty(Property.RRULE);
			if(property!=null) {
				value = property.getValue();
				event.put("rrule", value);
			}
			
			//insert start time
			property = component.getProperty(Property.DTSTART);
			if(property!=null) {
				value = property.getValue();
	
				if(property.getParameter("VALUE") == Value.DATE)
				{
					Date dt = new Date(value);
					event.put("allDay", "1");
					long beginTime = dt.getTime();
					event.put("dtstart", beginTime);
				}
				else
				{
					DateTime dt = new DateTime(value);
					event.put("allDay", "0");
					long beginTime = dt.getTime();
					event.put("dtstart", beginTime);
				}
			}
			
			//insert end time
			property = component.getProperty(Property.DTEND);
			if(property!=null) {
				value = property.getValue();
	
				if(property.getParameter("VALUE") == Value.DATE)
				{
					Date dte = new Date(value);
					long endTime = dte.getTime();
					event.put("dtend", endTime);
				}
				else
				{
					DateTime dte = new DateTime(value);
					long endTime = dte.getTime();
					event.put("dtend", endTime);
				}
			}			
						
			event.put("selfAttendeeStatus", 1); 
			event.put("eventStatus", 1);
			event.put("visibility", 0);
			event.put("transparency", 0);
			event.put("hasAlarm", 1); // 0 for false, 1 for true 
			
			event.put("calendar_id", 0);
		    Uri eventsUri = Uri.parse(calendarURIBase + "/events"); 
		    Uri insert_event = MyApp.instance().getContentResolver().insert(eventsUri, event);  
		    
		    String eventID = insert_event.getLastPathSegment(); 
		    ContentValues values = new ContentValues(); 
			values.put("event_id", eventID); 
	        values.put("method", 1); 
	        values.put("minutes", 20);
	        Uri REMINDERS_URI = Uri.parse(calendarURIBase + "/reminders"); 
	        MyApp.instance().getContentResolver().insert(REMINDERS_URI, values);  	        
		}		
		Toast.makeText(MyApp.getCurrentActivity(), calendarFile.getName() + MyApp.instance().getResources().getString(R.string.atta_import), Toast.LENGTH_SHORT).show();
	}
}
package mobi.cloudymail.mailclient.net;

import java.io.IOException;
import java.io.InputStream;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import mobi.cloudymail.util.Utils;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

public class Result 
{
	public static final int FAIL = 1;
	public static final int SUCCESSED = 0;
	public static final int AUTH_FAIL = 2;
	public static final int MSGSEND_FAIL = 3;
	public static final int NEEDLOGIN_FAIL = 4;
	public boolean hasContent = false;
	public Element xmlReader;
	private InputStream httpStream;
	private String contentType;
	public int mailCount=0;
	public Result()
	{
		status = SUCCESSED;
	}
	
	public Result(java.io.InputStream stream)
	{
		initXmlFromStream(stream);
	}

	private void initXmlFromStream(java.io.InputStream stream)
	{
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
     
		DocumentBuilder builder;
		try
		{
			builder = factory.newDocumentBuilder();
			Document dom = builder.parse(stream);
			Element root = dom.getDocumentElement();
			/*
			 * <Result>
			 * 		<status code="1" reason="NEED_LOGIN"/>
			 * 		<content>
			 * 			<mail uid="aaa" subject="bbb" />
			 * 		</content>
			 * </Result>
			 */
			NodeList l = root.getElementsByTagName("status");
			Utils.ASSERT(l.getLength() == 1);
			Element status = (Element) l.item(0);
			this.status = Integer.parseInt(status.getAttribute("code"));
			failReason = status.getAttribute("reason");
			NodeList items = root.getElementsByTagName("content");
	
	        if(items.getLength() > 0)
	        	xmlReader = (Element) items.item(0);
			
		}
		catch (ParserConfigurationException e)
		{
			e.printStackTrace();
		}
		catch (SAXException e)
		{
			e.printStackTrace();
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}

	public Result(java.io.InputStream stream, boolean useRawStream)
	{
		if(useRawStream)
			this.httpStream= stream;
		else
			initXmlFromStream(stream);
	}
	
	public InputStream getInputStream()
	{
		return httpStream;
	}
	public boolean isSuccessed()
	{
		
			return status == 0;
		
	}
	
	
	/**
	 * status of a net call. 0 for successful, other for failure
	 * for nonzero, status is the error code
	 */
	public int status;

	/**
	 * A string describe reason for failure. if status is scucessed, this is null;
	 */
	public String failReason;
	public void setContentType(String contentType)
	{
		this.contentType = contentType;
		
	}
	public String getContentType()
	{
		return contentType;
		
	}
	
	public boolean isXMLConent()
	{
		return contentType.startsWith("text/xml");
	}
}package mobi.cloudymail.mailclient.net;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Vector;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicBoolean;

import mobi.cloudymail.mailclient.PasswordDialog;
import mobi.cloudymail.mailclient.R;
import mobi.cloudymail.util.BreakbleMessageLoop;
import mobi.cloudymail.util.DialogResult;
import mobi.cloudymail.util.MessageBox;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.HttpVersion;
import org.apache.http.NameValuePair;
import org.apache.http.client.CookieStore;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.methods.HttpRequestBase;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.params.ConnManagerParams;
import org.apache.http.conn.params.ConnPerRoute;
import org.apache.http.conn.params.ConnPerRouteBean;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.cookie.Cookie;
import org.apache.http.cookie.CookieSpec;
import org.apache.http.cookie.CookieSpecFactory;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.impl.cookie.BrowserCompatSpec;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;
import org.simpleframework.xml.Serializer;
import org.simpleframework.xml.core.Persister;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.res.Resources;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.util.Log;

/*
 * 
 *CookieSpecFactory csf = new CookieSpecFactory() {
 public CookieSpec newInstance(HttpParams params) {
 return new BrowserCompatSpec() {   
 @Override
 public void validate(Cookie cookie, CookieOrigin origin)
 throws MalformedCookieException {
 // Oh, I am easy
 }
 };
 }
 };

 DefaultHttpClient httpclient = new DefaultHttpClient();
 httpclient.getCookieSpecs().register("easy", csf);
 httpclient.getParams().setParameter(
 ClientPNames.COOKIE_POLICY, "easy");
 */
public class ServerAgent
{
	public static final String HEADER_MAIL_CLIENT = "MailClient"; // this header
	public static final String HEADER_OS_VERSION = "OSVer"; //this header is Android system version

	public static final String AGENT_ID = "CloudMail1.2";
	public static final String OS_VERSION = android.os.Build.VERSION.RELEASE;
	
	public static final String PUSH_MAIL_SERVER = "push.cloudymail.mobi";
	public static final int PUSH_MAIL_PORT = 10099;

//	public static final String urlBase = "http://"+_serverAddText+":8088/MailProxy";
//	public static final String loginUrlBase = "http://"+SettingPage._serverAddText+":8088/MailProxy";
//	public static final String urlBase = "http://cloudymail.mobi:8088/MailProxy";
//	public static final String loginUrlBase = "http://cloudymail.mobi:8088/MailProxy";//"https://cloudymail.mobi:8443/MailProxy";
	// public static final String urlBase = SettingPage._serverAddText;
	// public static final String loginUrlBase=SettingPage._serverAddText;
	private LoginSemaphore loginSemaphore = new LoginSemaphore();
	public Account account = null;
	private int loginStatus = LOGIN_FAIL;

	private String cookie = null;
	private String sessionId = null;
	// private int accountIdOfCurrentSession = -1;

	private static Timer timer = new Timer();

	private int loginFailCode = 0;
	private String loginFailMsg = "";
	private boolean receiving;
	
	private final static int LOGIN_OK = 1;
	private final static int LOGIN_FAIL = 2;
	private final static int LOGIN_CANCELED = 3;
	private final static int LOGIN_NETWORK_FAIL = 4;
	private static final DefaultHttpClient sClient;
	private HttpPost loginRequest;
	private static interface LoginCallback
	{
		void loginFinished(boolean successed);
	}
	private static class LoginSemaphore{
		public Vector<LoginCallback> loginListener = new Vector<LoginCallback>();
		private Semaphore sema = null;
		private boolean loginGoing = false;
		public void addListener(LoginCallback callback)
		{
			loginListener.add(callback);
		}
//		public void acquire() throws InterruptedException
//		{
//			sema.acquire();
//		}
		public void release(boolean loginOK)
		{
			sema.release(Integer.MAX_VALUE);
			loginGoing = false;
			for(LoginCallback cbk:loginListener)
			{
				try
				{
					cbk.loginFinished(loginOK);
				}
				catch(Throwable t)
				{
					t.printStackTrace();
				}
			}
		}
	}
	static
	{

		// Set basic data
		HttpParams params = new BasicHttpParams();
		HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
		HttpProtocolParams.setContentCharset(params, "UTF-8");
		HttpProtocolParams.setUseExpectContinue(params, true);
		HttpProtocolParams.setUserAgent(params, AGENT_ID);

		// Make pool
		ConnPerRoute connPerRoute = new ConnPerRouteBean(12);
		ConnManagerParams.setMaxConnectionsPerRoute(params, connPerRoute);
		ConnManagerParams.setMaxTotalConnections(params, 20);
		
		// Set timeout
		HttpConnectionParams.setStaleCheckingEnabled(params, false);
		HttpConnectionParams.setConnectionTimeout(params, 60 * 1000);
		HttpConnectionParams.setSoTimeout(params, 60 * 1000);
		HttpConnectionParams.setSocketBufferSize(params, 8192);

		// Some client params
		HttpClientParams.setRedirecting(params, false);

		// Register http/s shemas!
		SchemeRegistry schReg = new SchemeRegistry();
		schReg.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 80));
		try
		{
			schReg.register(new Scheme("https", TrustAllSSLSocketFactory.getDefault(), 443));
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}

		ClientConnectionManager conMgr = new ThreadSafeClientConnManager(params, schReg);
		sClient = new DefaultHttpClient(conMgr, params);

		// method 1, for cookie enable
		// CookieHandler h = CookieHandler.getDefault();
		// sClient.getParams().setParameter(
		// ClientPNames.COOKIE_POLICY, CookiePolicy.RFC_2965);
		// sClient.getCookieSpecs().register("def", new RFC2965SpecFactory());

		// method 2
		CookieSpecFactory csf = new CookieSpecFactory() {
			@Override
			public CookieSpec newInstance(HttpParams params)
			{
				return new BrowserCompatSpec() {
					@Override
					public boolean match(Cookie cookie, org.apache.http.cookie.CookieOrigin origin)
					{
						boolean b = super.match(cookie, origin);
						b = cookie.getDomain().equals(origin.getHost());
						return b;
					}
				};
			}
		};

		sClient.getCookieSpecs().register("easy", csf);
		sClient.getParams().setParameter(ClientPNames.COOKIE_POLICY, "easy");
	}

	public static DefaultHttpClient getHttpClient()
	{
		return sClient;
	}

	public static String getUrlBase()
	{
		return "http://" + MyApp.userSetting._serverAddText + ":8088/MailProxy2";
	}

	public static String getLoginUrlBase()
	{
		return "https://" + MyApp.userSetting._serverAddText + ":8443/MailProxy2";
	}

	public static String getPushServer()
	{
		if(Utils.isEmpty(MyApp.userSetting._serverAddText))
		{
			return PUSH_MAIL_SERVER;
		}
		return MyApp.userSetting._serverAddText;
	}
	// public static HttpResponse execute(HttpHead head) throws IOException {
	// return sClient.execute(head);
	// }
	//
	// public static HttpResponse execute(HttpHost host, HttpGet get)
	// throws IOException {
	// return sClient.execute(host, get);
	// }
	public static Result doHttpPost(String url,String accountName,String password,Context context, String progressBarTitle)
	{
		final HttpPost httpPost=new HttpPost(url);
		ArrayList<NameValuePair> params =new ArrayList<NameValuePair>();
		params.add(new BasicNameValuePair("account",accountName));
		params.add(new BasicNameValuePair("password",password));
		try
		{
			httpPost.setEntity((HttpEntity) new  UrlEncodedFormEntity(params, HTTP.UTF_8));
		}
		catch (UnsupportedEncodingException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}  
		final BreakbleMessageLoop myloop = new BreakbleMessageLoop();
		final Result[] result = new Result[] { null };
		Thread newThread = new Thread() {

			@Override
			public void run()
			{

				try
				{

					HttpResponse rsp = sClient.execute(httpPost);
					result[0] = new Result(rsp.getEntity().getContent()); //so we will skip set session ID on error

				}
				catch (Exception ex)
				{
					ex.printStackTrace();
				}

				myloop.breakLoop();
			}
		};
		ProgressDialog prgDialog = new ProgressDialog(context);
		prgDialog.setMessage(progressBarTitle);
		prgDialog.setOnCancelListener(new OnCancelListener() {

			@Override
			public void onCancel(DialogInterface arg0)
			{
				httpPost.abort();
			}
		});
		prgDialog.show();

		newThread.start();

		myloop.loop();
		prgDialog.dismiss();
		return result[0];
	
		
	}
	
	/**
	 * A general HTTP post method.
	 * This method run in block mode, i.e. function not return to caller untill network post complete.
	 * Server may reutnr result as 1) standard XML, which can be represented in a Result object
	 * 2) General stream
	 * 
	 * For caller, should process result differently for this two situation. for example
	 *       Result r = MyApp.getAgent().doHttpPost( .... );
	 *       if(r.isSuccessed())
	 *       {
	 *       	if(r.isXMLConent())
	 *      	 {
	 *        	  //deal with XML
	 *     		  }
	 *      	 else
	 *       	{
	 *       		is = r.getInputStream();
	 *          	//deal with input stream
	 *       	}
	 *       }
	 * @param url
	 * @param parameters
	 * @param progressBarTitle
	 * @param showProgressBar
	 * @param askPassword
	 * @param promptOnFail
	 * @return
	 */
	
	public Result doHttpPost(String url, HashMap<String, String> parameters, String progressBarTitle, final boolean showProgressBar, final boolean askPassword, final boolean promptOnFail)
	{
		return doHttpRequest(url, true, parameters, progressBarTitle, showProgressBar, askPassword,  promptOnFail);
	}
	private Result doHttpRequest(String url, boolean doPost, HashMap<String, String> parameters, String progressBarTitle, final boolean showProgressBar, final boolean askPassword, final boolean promptOnFail )
	{
		Result r= new Result();
		if(getSessionId(showProgressBar, askPassword, promptOnFail) == null)
		{
			r.status = Result.AUTH_FAIL;
			return r;
		}
		HttpRequestBase httpReq=null;
		if(doPost)
		{
			httpReq = new HttpPost(url);
			ArrayList<NameValuePair> params =new ArrayList<NameValuePair>();
			for( Map.Entry<String,String> e : parameters.entrySet())
			{
				params.add(new BasicNameValuePair(e.getKey(),e.getValue()));
			}
			
			try
			{
				((HttpPost)httpReq).setEntity((HttpEntity) new  UrlEncodedFormEntity(params, HTTP.UTF_8));
			}
			catch (UnsupportedEncodingException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}  
		}
		else
		{
			httpReq = new HttpGet(url);

		}
		final BreakbleMessageLoop myloop = new BreakbleMessageLoop();
		final Result[] result = new Result[] { null };
		final HttpRequestBase httpPost = httpReq;
		Thread newThread = new Thread() {

			@Override
			public void run()
			{

				try
				{

					HttpResponse rsp = sClient.execute(httpPost);
					//Though we have call getSessionId previously, that session may be a cached and has been invalid.
					//if this true, we will get NEED_LOGIN error
					if(rsp.getStatusLine().getStatusCode()== HttpStatus.SC_NON_AUTHORITATIVE_INFORMATION)
					{
						//clear cached session first
						
						//re login
						if(MyApp.getAgent().getSessionId(showProgressBar, askPassword, promptOnFail) == null) //try do login again
						{
							return;
						}
						rsp = sClient.execute(httpPost);
					}
					
					Header[] headers = rsp.getHeaders("Content-Type");
					String contentType = null;
					if(headers != null && headers.length == 0  )
						contentType = headers[0].getValue();
					if(contentType != null && contentType.startsWith("text/xml"))
					{
						result[0] = new Result(rsp.getEntity().getContent());
					}
					else
					{
						result[0] = new Result(rsp.getEntity().getContent(), true);
						
					}
					result[0].setContentType(contentType);
				}
				catch (Exception ex)
				{
					ex.printStackTrace();
					result[0] = new Result(); 
					result[0].status=Result.FAIL;
				}

				myloop.breakLoop();
			}
		};
		ProgressDialog prgDialog = new ProgressDialog(MyApp.getCurrentActivity());
		prgDialog.setMessage(progressBarTitle);
		prgDialog.setOnCancelListener(new OnCancelListener() {

			@Override
			public void onCancel(DialogInterface arg0)
			{
				httpPost.abort();
			}
		});
		prgDialog.show();

		newThread.start();

		myloop.loop();
		prgDialog.dismiss();
		return result[0];
	
		
	}
	

	public static HttpResponse execute(HttpGet get) throws IOException
	{
		get.setHeader(HEADER_MAIL_CLIENT, AGENT_ID);
		get.setHeader(HEADER_OS_VERSION, OS_VERSION);
		return sClient.execute(get);
	}

	public static HttpResponse execute(HttpPost post) throws IOException
	{
		post.setHeader(HEADER_MAIL_CLIENT, AGENT_ID);
		post.setHeader(HEADER_OS_VERSION, OS_VERSION);
		return sClient.execute(post);
	}

	public static synchronized CookieStore getCookieStore()
	{
		return sClient.getCookieStore();
	}

	public ServerAgent(Account account)
	{
		this.account = account;
	}

	public static void dumpResponseHeads(HttpResponse rsp)
	{
		Header[] headers = rsp.getAllHeaders();
		for (int tmpI = 0; tmpI < headers.length; ++tmpI)
		{
			Header header = headers[tmpI];
			Log.d(LOGTAG, "login's reponse" + header.toString());
		}
	}



	public boolean isLogin()
	{
		return sessionId != null;
	}
	
	/**
	 * do login. ask user password and show progress bar according input parameters
	 * this function can be called in either UI thread or background thread
	 * @param showProgressBar
	 * @param askPassword
	 * @param promptOnFail
	 * @return
	 */
	public boolean interactiveLogin(final boolean showProgressBar, final boolean askPassword, final boolean promptOnFail)
	{
		synchronized(this)
		{
			if(!loginSemaphore.loginGoing)
			{//if no login process, start one
				loginSemaphore.sema = new Semaphore(-1); 
				loginSemaphore.loginGoing = true;
				Thread backThread = new Thread()
				{
					@Override
					public void run()
					{
						interactiveLoginInBackground(showProgressBar, askPassword, promptOnFail);;
					}
				};
				backThread.setName("Login");
				backThread.start();
			}
		}
		//wait login to complete. use two different waiting method for UI thread and background thread
		waitingLogin(showProgressBar, promptOnFail);
		return loginStatus == LOGIN_OK;
			
	}
	// ask user to input password if user has not inputted, or password wrong
	private boolean interactiveLoginInBackground(boolean showProgressBar, boolean askPassword, boolean promptOnFail)
	{
		
			 
		Resources res = MyApp.instance().getResources();
		try
		{
tryLogin:
			for (int i = 0; i < 3; i++)
			{// try 3 times for user to input password and login
				getCurrentPassword(askPassword);
				if (!Utils.isEmpty(account.password))
				{
					// int returnStatus = LOGIN_OK;
					loginStatus = LOGIN_FAIL;
					loginRequest = new HttpPost(getLoginUrlBase() + "/Login?account="
																+ java.net.URLEncoder.encode(account.name));

					
					blockingLogin(loginRequest);
							// 登录可以以四种状态结束
							// 1. 成功登录 2. 密码错误 3. 网络错误 4. 用户取消
					switch (loginStatus)
					{
					case LOGIN_OK:
						return true;
					case LOGIN_CANCELED:
						return false;
					case LOGIN_NETWORK_FAIL:
						break tryLogin;
					default:
						if (loginFailCode == Result.AUTH_FAIL)
						{ // failed because of wrong password
							clearPassword();
						}
						else
							break tryLogin; // some other reason fail, don't
											// retry
					}
				}
				else
				{// user has cancled input password, break;
					return false;
				}
			}
		
			if(promptOnFail && loginStatus != LOGIN_CANCELED)
			{
				Utils.runOnUiThreadAndBlock(new Runnable() {
					
					@Override
					public void run()
					{
						if (loginFailCode == Result.AUTH_FAIL)
						{
							MessageBox.show(MyApp.getCurrentActivity(), MyApp.instance().getString(R.string.fl_checkSetting),
							                MyApp.instance().getString(R.string.failLogin));
						}
						else
							MessageBox.show(MyApp.getCurrentActivity(), MyApp.instance().getString(R.string.fl_cannotConnectServer)
														+ loginFailMsg, MyApp.instance().getString(R.string.failLogin));

					}
				});
			}
		}
		catch (Exception ex)
		{
			if(promptOnFail)
			{
				MessageBox.show(MyApp.getCurrentActivity(), ex.getMessage(), res.getString(R.string.failLogin));
			}
			ex.printStackTrace();
		}
		finally
		{
			synchronized(this)
			{
				loginSemaphore.release(loginStatus == LOGIN_OK);
			}
		}
		return false;
	}
	public void cancelLogin()
	{
		loginRequest.abort();
		loginStatus = LOGIN_CANCELED ;
	}
	//suppose we are running in background thread
	private boolean waitingLogin(boolean showProgressBar, boolean promptOnFail)
	{
		
		
		
		final ProgressDialog[] dlgRef = new ProgressDialog[1];
		final AtomicBoolean userCancel = new AtomicBoolean(false);
		if(showProgressBar)
		{
			
			MyApp.getCurrentActivity().runOnUiThread(new Runnable() {
				
				@Override
				public void run()
				{
					ProgressDialog prgDialog = dlgRef[0] = new ProgressDialog(MyApp.getCurrentActivity());
					Resources res = MyApp.instance().getResources();
					prgDialog.setMessage(res.getString(R.string.logining));
					prgDialog.setOnCancelListener(new OnCancelListener() {

						@Override
						public void onCancel(DialogInterface arg0)
						{
							userCancel.set(true);
							cancelLogin();
						}
					});
					prgDialog.show();
					
				}
			});
			

		}
		
		if(Utils.inUiThread())
		{
			
			final BreakbleMessageLoop myloop = new BreakbleMessageLoop();
			loginSemaphore.addListener(new LoginCallback() {
				
				@Override
				public void loginFinished(boolean successed)
				{
					myloop.breakLoop();
					
				}
			});
			myloop.loop();
			
		}
		else
			try
			{
				loginSemaphore.sema.acquire();
			}
			catch (InterruptedException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		
		
		if(showProgressBar)
		{
			MyApp.getCurrentActivity().runOnUiThread(new Runnable() {
				
				@Override
				public void run()
				{
					dlgRef[0].dismiss();
				}
			});
			
		}
		
		if(userCancel.get())
			return false;
		if(promptOnFail && loginStatus != LOGIN_OK)
		{
			MyApp.getCurrentActivity().runOnUiThread(new Runnable() {
				
				@Override
				public void run()
				{
					MyApp res = MyApp.instance();
					if (loginFailCode == Result.AUTH_FAIL)
					{
						MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.fl_checkSetting),
										res.getString(R.string.failLogin));
					}
					else
						MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.fl_cannotConnectServer)
													+ loginFailMsg, res.getString(R.string.failLogin));

				}
			});
		}
		return loginStatus == LOGIN_OK;
	}

	private void clearPassword()
	{
		account.password = null;
		Log.d(LOGTAG, "Clear password" + "account name = " + account.name);
		// DbHelper.getInstance().updateAccountPassword("", account.id);
		NewDbHelper.getInstance().updateAccountPassword("", account.id);
	}

	public String getCurrentPassword(boolean askInputOnNeed)
	{
		if (account != null)
		{
			if (Utils.isEmpty(account.password) && askInputOnNeed)
			{
				Utils.runOnUiThreadAndBlock(new Runnable() {
					
					@Override
					public void run()
					{
						PasswordDialog dlg = new PasswordDialog(MyApp.getCurrentActivity(), account.name,
																loginFailCode == Result.AUTH_FAIL);
						if (dlg.showDialog() == DialogResult.OK)
						{
							account.password = dlg.getPassword();
							if ("".equals(account.password))
								account.password = null;
							if (dlg.needSavePassword())
								NewDbHelper.getInstance().updateAccountPassword(account.password,
																				account.id);
						}
						else
							account.password = null;
					}
				});
				

			}
			return account.password;
		}
		return null;
	}



	public static boolean hasNetworkConnection()
	{
		ConnectivityManager cm = (ConnectivityManager) MyApp.instance()
				.getSystemService(Context.CONNECTIVITY_SERVICE);
		NetworkInfo[] netInfo = cm.getAllNetworkInfo();
		for (NetworkInfo ni : netInfo)
		{
			if (ni.isConnected())
				return true;
		}
		return false;
	}

	public String getSessionId(boolean showProgressBar, boolean askPassword, boolean promptOnFail)
	{
		// first check whether phone connects with network.
		// ConnectivityManager cwjManager = (ConnectivityManager) ctx
		// .getSystemService(Context.CONNECTIVITY_SERVICE);
		// NetworkInfo nwInfo = cwjManager.getActiveNetworkInfo();
		// if (nwInfo == null || !nwInfo.isAvailable())
		if (!hasNetworkConnection())
		{
			if( promptOnFail)
			{
				Utils.runOnUiThreadAndBlock(new Runnable() {
					
					@Override
					public void run()
					{
						Resources res = MyApp.getCurrentActivity().getResources();
						MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.err_notConnected),
										res.getString(R.string.error));
	
						
					}
				});
			}
			return null;
		}

		// since one account has its own ServerAgent object, there's no need to
		// store the
		// accountIdOfCurrentSession
		if (sessionId == null )
		{
			if (interactiveLogin( showProgressBar,  askPassword,  promptOnFail))
			{
				//schedule a task to clear session ID after 29 minutes
				TimerTask task = new TimerTask() 
				{
					@Override
					public void run()
					{
						sessionId = null;
						
					}
				};
				timer.schedule(task, 29*60*1000);
			}

		}
		return sessionId;
	}

	private void blockingLogin(final HttpPost loginRequest)
	{
		Log.d(LOGTAG, "Login" + "Start Login");
		loginFailCode = 0;
		String password = account.password;
		if (password == null)
		{
			Utils.ASSERT(false);
			loginStatus = LOGIN_CANCELED;
		}
		HttpResponse rsp = null;

		// MailClient.mainWindow.showStatus("建立网络连接...");
		// MessageBox.Show("正在登录。\n如需要中止，请点击“确定”。", "请稍候",
		// MessageBoxButtons.OK, MessageBoxIcon.None,
		// MessageBoxDefaultButton.Button1);
		loginFailMsg = "";

		try
		{
			sClient.getCookieStore().clear();
			Serializer serializer = new Persister();
			ByteArrayOutputStream out = new ByteArrayOutputStream(512);
			serializer.write(account, out);
			loginRequest.setEntity(new ByteArrayEntity(out.toByteArray()));
			loginRequest.setHeader("Cache-Control", "no-cache");
			Log.d(LOGTAG, "Login" + "Start HTTP execute");
			rsp = execute(loginRequest);
			Log.d(LOGTAG, "Login" + "End HTTP execute");
			// dumpResponseHeads(rsp);


			Result rst = new Result(rsp.getEntity().getContent()); //so we will skip set session ID on error
			

			if (!rst.isSuccessed())
			{
				loginFailCode = rst.status;
				loginStatus = LOGIN_FAIL;
				loginFailMsg = rst.failReason;
				sessionId = null;
				cookie = null;
			}
			else
			{
				loginStatus = LOGIN_OK;
				if (rst.xmlReader != null)
				{
					NewDbHelper.getInstance().insertFoldersToDb(rst.xmlReader, account.id);
				}
				if (rsp.getFirstHeader("Set-Cookie") != null)
				{
					cookie = rsp.getFirstHeader("Set-Cookie").getValue();
					int semiPos = cookie.indexOf(';');
					if (semiPos > 0)
						cookie = cookie.substring(0, semiPos);
					int equPos = cookie.indexOf('=');
					sessionId = cookie.substring(equPos + 1);
					// accountIdOfCurrentSession =
					// MailClient.currentAccount.id;
				}

			}

		}
		catch (java.net.UnknownHostException ex1)
		{
			loginFailMsg = MyApp.instance().getResources()
					.getString(R.string.networkProblem);
			// Log.d("UnknownHostException", ex1.getMessage());
			ex1.printStackTrace();
			loginStatus = LOGIN_NETWORK_FAIL;// LOGIN_FAIL;
		}
		catch (java.net.SocketTimeoutException ex2)
		{
			loginFailMsg = MyApp.instance().getResources()
					.getString(R.string.networkProblem);
			// Log.d("SocketTimeoutException", ex2.getMessage());
			ex2.printStackTrace();
			loginStatus = LOGIN_NETWORK_FAIL;// LOGIN_FAIL;
		}
		catch (Exception ex)
		{
			if (loginStatus != LOGIN_CANCELED)
			{
				loginFailMsg = ex.getClass().getName() + ":" + ex.getMessage();
				ex.printStackTrace();
				loginStatus = LOGIN_FAIL;
			}
		}
		// 登录可以以四种状态结束
		// 1. 成功登录 2. 密码错误 3. 网络错误 4. 用户取消
	}

	public boolean isReceiving()
	{
		
		return receiving;
	}
	public void setReceiving(boolean receiving)
	{
		this.receiving = receiving;
	}
	public void clearSessionId()
	{
		this.sessionId=null;
	}
}
package mobi.cloudymail.mailclient.net;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.X509TrustManager;

public class TrustAllManager implements X509TrustManager {
	public void checkClientTrusted(X509Certificate[] cert, String authType)
			throws CertificateException {
	}

	public void checkServerTrusted(X509Certificate[] cert, String authType)
			throws CertificateException {
	}

	public X509Certificate[] getAcceptedIssuers() {
		return null;
	}
}

package mobi.cloudymail.mailclient.net;


import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;

import org.apache.http.conn.scheme.SocketFactory;
import org.apache.http.conn.ssl.AllowAllHostnameVerifier;
import org.apache.http.conn.ssl.SSLSocketFactory;

public class TrustAllSSLSocketFactory extends SSLSocketFactory {
	private javax.net.ssl.SSLSocketFactory factory;

	public TrustAllSSLSocketFactory() throws KeyManagementException,
			NoSuchAlgorithmException, KeyStoreException,
			UnrecoverableKeyException {
		super(null);
		try {
			SSLContext sslcontext = SSLContext.getInstance("TLS");
			sslcontext.init(null, new TrustManager[] { new TrustAllManager() },
					null);
			factory = sslcontext.getSocketFactory();
			setHostnameVerifier(new AllowAllHostnameVerifier());
		} catch (Exception ex) {
		}
	}

	public static SocketFactory getDefault() throws KeyManagementException,
			NoSuchAlgorithmException, KeyStoreException,
			UnrecoverableKeyException {
		return new TrustAllSSLSocketFactory();
	}

	@Override
	public Socket createSocket() throws IOException {
		return factory.createSocket();
	}

	@Override
	public Socket createSocket(Socket socket, String s, int i, boolean flag)
			throws IOException {
		return factory.createSocket(socket, s, i, flag);
	}

	public Socket createSocket(InetAddress inaddr, int i, InetAddress inaddr1,
			int j) throws IOException {
		return factory.createSocket(inaddr, i, inaddr1, j);
	}

	public Socket createSocket(InetAddress inaddr, int i) throws IOException {
		return factory.createSocket(inaddr, i);
	}

	public Socket createSocket(String s, int i, InetAddress inaddr, int j)
			throws IOException {
		return factory.createSocket(s, i, inaddr, j);
	}

	public Socket createSocket(String s, int i) throws IOException {
		return factory.createSocket(s, i);
	}

	public String[] getDefaultCipherSuites() {
		return factory.getDefaultCipherSuites();
	}

	public String[] getSupportedCipherSuites() {
		return factory.getSupportedCipherSuites();
	}
}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.File;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import com.umeng.analytics.MobclickAgent;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.AttachmentInfo;
import mobi.cloudymail.mailclient.net.DownloadAttaTask;
import mobi.cloudymail.util.MessageBox;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import android.app.ListActivity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.Button;
import android.widget.CompoundButton;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.TextView;
import android.widget.AdapterView.OnItemClickListener;

public class NewAttachmentManager extends ListActivity 
					implements android.view.View.OnClickListener,
					CompoundButton.OnCheckedChangeListener,
					OnItemClickListener
{
	private ListView _attListView=null;
	private List<AttachmentInfo> _attachInfos=new ArrayList<AttachmentInfo>();
	private AttachmentListAdapter _adapter=null;
	private LinearLayout _botBtnLayout=null;
	private Button _openBtn=null;
	private Button _downloadBtn = null;
	private Button _previewBtn = null;
	private int _curSelectedPos = -1;
	
	private final String[][] MIME_MapTable={ 
	                                        //{suffix，MIME type} 
	                                        {".3gp",    "video/3gpp"}, 
	                                        {".apk",    "application/vnd.android.package-archive"}, 
	                                        {".asf",    "video/x-ms-asf"}, 
	                                        {".avi",    "video/x-msvideo"}, 
	                                        {".bin",    "application/octet-stream"}, 
	                                        {".bmp",    "image/bmp"}, 
	                                        {".c",  "text/plain"}, 
	                                        {".class",  "application/octet-stream"}, 
	                                        {".conf",   "text/plain"}, 
	                                        {".cpp",    "text/plain"}, 
	                                        {".doc",    "application/msword"}, 
	                                        {".docx",   "application/vnd.openxmlformats-officedocument.wordprocessingml.document"}, 
	                                        {".xls",    "application/vnd.ms-excel"},  
	                                        {".xlsx",   "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}, 
	                                        {".exe",    "application/octet-stream"}, 
	                                        {".gif",    "image/gif"}, 
	                                        {".gtar",   "application/x-gtar"}, 
	                                        {".gz", "application/x-gzip"}, 
	                                        {".h",  "text/plain"}, 
	                                        {".htm",    "text/html"}, 
	                                        {".html",   "text/html"}, 
	                                        {".jar",    "application/java-archive"}, 
	                                        {".java",   "text/plain"}, 
	                                        {".jpeg",   "image/jpeg"}, 
	                                        {".jpg",    "image/jpeg"}, 
	                                        {".js", "application/x-javascript"}, 
	                                        {".log",    "text/plain"}, 
	                                        {".m3u",    "audio/x-mpegurl"}, 
	                                        {".m4a",    "audio/mp4a-latm"}, 
	                                        {".m4b",    "audio/mp4a-latm"}, 
	                                        {".m4p",    "audio/mp4a-latm"}, 
	                                        {".m4u",    "video/vnd.mpegurl"}, 
	                                        {".m4v",    "video/x-m4v"},  
	                                        {".mov",    "video/quicktime"}, 
	                                        {".mp2",    "audio/x-mpeg"}, 
	                                        {".mp3",    "audio/x-mpeg"}, 
	                                        {".mp4",    "video/mp4"}, 
	                                        {".mpc",    "application/vnd.mpohun.certificate"},        
	                                        {".mpe",    "video/mpeg"},   
	                                        {".mpeg",   "video/mpeg"},   
	                                        {".mpg",    "video/mpeg"},   
	                                        {".mpg4",   "video/mp4"},    
	                                        {".mpga",   "audio/mpeg"}, 
	                                        {".msg",    "application/vnd.ms-outlook"}, 
	                                        {".ogg",    "audio/ogg"}, 
	                                        {".pdf",    "application/pdf"}, 
	                                        {".png",    "image/png"}, 
	                                        {".pps",    "application/vnd.ms-powerpoint"}, 
	                                        {".ppt",    "application/vnd.ms-powerpoint"}, 
	                                        {".pptx",   "application/vnd.openxmlformats-officedocument.presentationml.presentation"}, 
	                                        {".prop",   "text/plain"}, 
	                                        {".rc", "text/plain"}, 
	                                        {".rmvb",   "audio/x-pn-realaudio"}, 
	                                        {".rtf",    "application/rtf"}, 
	                                        {".sh", "text/plain"}, 
	                                        {".tar",    "application/x-tar"},    
	                                        {".tgz",    "application/x-compressed"},  
	                                        {".txt",    "text/plain"}, 
	                                        {".wav",    "audio/x-wav"}, 
	                                        {".wma",    "audio/x-ms-wma"}, 
	                                        {".wmv",    "audio/x-ms-wmv"}, 
	                                        {".wps",    "application/vnd.ms-works"}, 
	                                        {".xml",    "text/plain"}, 
	                                        {".z",  "application/x-compress"}, 
	                                        {".zip",    "application/x-zip-compressed"}, 
	                                        {".ics",	"text/plain"},
	                                        {"",        "*/*"}   
	                                    };
	
	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		MyApp.setCurrentActivity(this);
		requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);
		setContentView(R.layout.new_attachment_list);
		//win.setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, R.drawable.cloudymail);
		getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.attachment_manager_titlebar);
		
		_attListView = getListView();
		_botBtnLayout = (LinearLayout)findViewById(R.id.newAttachOpLayout);
		_openBtn = (Button)findViewById(R.id.newOpenAttachBtn);
		_downloadBtn = (Button)findViewById(R.id.newDownladAttachBtn);
		_previewBtn = (Button)findViewById(R.id.previewAttachBtn);
		_openBtn.setOnClickListener(this);
		_downloadBtn.setOnClickListener(this);
		_previewBtn.setOnClickListener(this);
		_botBtnLayout.setVisibility(View.GONE);
		_attListView.setOnItemClickListener(this);
	}
	
	@Override
	protected void onStart()
	{
		super.onStart();
		updateAttachList();
	}
	
	@Override
	protected void onResume()
	{
		super.onResume();
		MobclickAgent.onResume(this);
		MyApp.setCurrentActivity(this);
	}
	
	private void updateAttachList()
	{
		_attachInfos = NewDbHelper.getInstance().getAttachmentInfo("");
		if(_adapter == null)
		{
			_adapter = new AttachmentListAdapter(_attachInfos,this);
			_attListView.setAdapter(_adapter);
		}
		else
			_adapter.setAttachList(_attachInfos);
	}
	
	
	static class AttachmentListAdapter extends BaseAdapter
	{
		private List<AttachmentInfo> _attachInfos;
	//	private MailFolderActivity _ctx;
		private NewAttachmentManager _ctx;
		private List<RadioButton> _radBtns = new LinkedList<RadioButton>();
		private int curPos=-1;

		static class ViewHolder
		{
			TextView fromTextView;
			TextView dateTextView;
			TextView attachTextView;
			TextView filePathView;
			RadioButton attaRadioBtn;
//			Button downloadBtn;
//			Button openBtn;
//			Button previewBtn;
		}

		public AttachmentListAdapter(List<AttachmentInfo> attachInfos,
				NewAttachmentManager ctx)
		{
			_attachInfos = attachInfos;
			_ctx = ctx;
		}

		public void setAttachList(List<AttachmentInfo> attachInfos)
		{
			_attachInfos = attachInfos;
			notifyDataSetChanged();
		}

		@Override
		public int getCount()
		{
			return _attachInfos.size();
		}

		@Override
		public Object getItem(int position)
		{
			return _attachInfos.get(position);
		}

		@Override
		public long getItemId(int position)
		{
			return position;
		}

		@Override
		public int getItemViewType(int position)
		{
			/*MailInfo mail = _ctx.getMail(position);
			if ((mail.getState() & MailStatus.FLAG_HAS_MORE_PLACEHOLD) != 0)
			{
				return 1; // this is a place holder for display more mails
			}*/
			return 0;
		}

		@Override
		public int getViewTypeCount()
		{
			return 1;//2;
		}

		@Override
		public View getView(final int position, View convertView,
				ViewGroup parent)
		{
			AttachmentInfo attaInfo = _attachInfos.get(position);

			// else, this is a normal mail

			// A ViewHolder keeps references to children views to avoid
			// unnecessary calls to findViewById() on each row.
			final ViewHolder holder;

			if (convertView == null)
			{
				convertView = _ctx.getLayoutInflater()
						.inflate(R.layout.new_attachment_list_item, null);
				holder = new ViewHolder();
				holder.attachTextView = (TextView) convertView
						.findViewById(R.id.newAttachInfoText);
				holder.filePathView = (TextView) convertView
						.findViewById(R.id.newAttachPath);
				holder.fromTextView = (TextView) convertView
						.findViewById(R.id.newAttachFromTxt);
				holder.dateTextView = (TextView) convertView
						.findViewById(R.id.newAttachdateTxt);
				holder.attaRadioBtn = (RadioButton) convertView
						.findViewById(R.id.newAttachRadio);
				_radBtns.add(holder.attaRadioBtn);
				holder.attaRadioBtn.setOnCheckedChangeListener(_ctx);
				convertView.setPadding(0, 2, 0, 2);
				convertView.setTag(holder);
				convertView.setBackgroundResource(R.drawable.mail_unread_bg);	
			}
			else
			{
				// Get the ViewHolder back to get fast access to the TextView
				// and the ImageView.
				holder = (ViewHolder) convertView.getTag();
			}
			holder.attachTextView.setText(attaInfo.fileName+"("+attaInfo.size+")");
			if(attaInfo.isFilePathValid())
			{
				holder.filePathView.setText(attaInfo.fullFilePath);
				holder.filePathView.setVisibility(View.VISIBLE);
			}
			else
			{
				holder.filePathView.setText("");
				holder.filePathView.setVisibility(View.GONE);
			}
			holder.fromTextView.setText(new EmailAddress(attaInfo.getMailInfo().getFrom()).getName());
			holder.dateTextView.setText(attaInfo.getMailDate().toLocaleString());
			holder.attaRadioBtn.setTag(position);
			holder.attaRadioBtn.setOnCheckedChangeListener(null);
			holder.attaRadioBtn.setChecked(position==curPos);
			holder.attaRadioBtn.setOnCheckedChangeListener(_ctx);
			return convertView;
		}
		
		public void updateRadBtns(int selectedPos)
		{
			curPos = selectedPos;
			for ( RadioButton btn: _radBtns)
			{
				int pos = (Integer)btn.getTag();
				btn.setChecked(pos==selectedPos);
			}
		}
	}


	@Override
	public void onClick(View view)
	{
		switch(view.getId())
		{
		case R.id.newOpenAttachBtn:
			openAttachment();
			break;
		case R.id.newDownladAttachBtn:
			downloadAttachment();
			break;
		case R.id.previewAttachBtn:
			previewAttachment();
			break;
		}	
	}
	
	private void previewAttachment()
	{
		if (_curSelectedPos < 0 || _curSelectedPos >= _attachInfos.size())
			return;
		AttachmentInfo attach = _attachInfos.get(_curSelectedPos);
//		MyApp.curMailInfo = attach.getMailInfo();
		MyApp.setCurrentMailInfo(attach.getMailInfo());
		if (MyApp.getAgent(	AccountManager.getAccount(MyApp.curMailInfo
									.getAccountId())).getSessionId(true,true,true) == null)
		{
			MessageBox.show(this, "Internal error, need login", "Error");
			return;
		}		
		Intent intent = new Intent(this, AttachmentViewer.class);
		intent.putExtra(AttachmentViewer.ATTACHMENT_INFO, (Parcelable)attach);
		startActivity(intent);
	}
	
	private void openAttachment()
	{
		if (_curSelectedPos < 0 || _curSelectedPos >= _attachInfos.size())
			return;
		AttachmentInfo attach = _attachInfos.get(_curSelectedPos);
		if (!attach.isFilePathValid())
			return;
		File file = new File(attach.fullFilePath);
		Intent intent = new Intent();
		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		intent.setAction(android.content.Intent.ACTION_VIEW);

		String type = getMIMEType(file);
		intent.setDataAndType(Uri.fromFile(file), type);
		try
		{
			startActivity(intent);
		}
		catch(ActivityNotFoundException ex)
		{
			type = "*/*";
			intent.setDataAndType(Uri.fromFile(file), type);
			startActivity(intent);
		}
	}
	
	private void downloadAttachment()
	{
		if (!MailViewer.isSdCardAvailable(this))
			return;
		System.out.println("start downloadAttachment()");
		if (_curSelectedPos < 0 || _curSelectedPos >= _attachInfos.size())
			return;
		AttachmentInfo atta = _attachInfos.get(_curSelectedPos);
		// update current mailinfo
//		MyApp.curMailInfo = atta.getMailInfo();
		MyApp.setCurrentMailInfo(atta.getMailInfo());
		String sdcFilePath = MailViewer
				.getAvailableFilePathToSave(atta.fileName);
		
		Handler mHandler = new Handler(){
			public void handleMessage(Message msg) 
			{ 
		//		System.out.println("handleMessage "+msg.what);
				_adapter.notifyDataSetChanged();
				doOnCheckedChanged();
			}
		};
		DownloadAttaTask downloadTask = new DownloadAttaTask(atta, null, false);
		downloadTask.setHandler(mHandler);
		downloadTask.execute(sdcFilePath);
	}

	private String getMIMEType(File f)
	{
		String type = "*/*";
		String fName = f.getName();
		int idx = fName.lastIndexOf(".");
		if(idx < 1)
			return type;
		String end = fName.substring(idx, fName.length()).toLowerCase();

		if(end.equals(""))
			return type;
		//get the mime type based on file suffix
	    for(int i=0;i<MIME_MapTable.length;i++)
	    { 
	        if(end.equals(MIME_MapTable[i][0]))
	            return MIME_MapTable[i][1];
	    }        
	    return type;
	}

	@Override
	public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
	{
		if(!isChecked)
			return;
		_curSelectedPos = (Integer) buttonView.getTag();
		doOnCheckedChanged();
	}
	
	private void doOnCheckedChanged()
	{
		//update the layout of bottom layout.
		AttachmentInfo attach = _attachInfos.get(_curSelectedPos);
		//check whether this attachment has been download before.
		if(attach.isFilePathValid())
		{
			_downloadBtn.setVisibility(View.GONE);
			_openBtn.setVisibility(View.VISIBLE);
		}
		else
		{
			_downloadBtn.setVisibility(View.VISIBLE);
			_openBtn.setVisibility(View.GONE);
		}
		_previewBtn.setVisibility(attach.canPreview?View.VISIBLE:View.GONE);
		_botBtnLayout.setVisibility(View.VISIBLE);
		//update selection status of radio button.
		_adapter.updateRadBtns(_curSelectedPos);
	}

	@Override
	public void onItemClick(AdapterView<?> parent, View view, int position, long id)
	{
		// TODO Auto-generated method stub
		if(position < 0 || position >= _attachInfos.size())
			return;
		//update current mail info.
		MailInfo mailInfo = _attachInfos.get(position).getMailInfo();
		Account acct = AccountManager.getAccount(mailInfo.getAccountId());
		if (mailInfo.getState() != MailStatus.MAIL_READED)
		{
			String sid = MyApp.getAgent(acct).getSessionId(true,true,true); //Is Bug? current account may not the account this mail
															  //No, in GlobalInBoxActivity.beforeOpenMail, currentAccount has been switched
			if (sid == null)
			{
				Log.d(LOGTAG,"openMail:"+ "session id is null");
				return;
			}
		}
//		MyApp.curMailInfo = mailInfo;
		MyApp.setCurrentMailInfo(mailInfo);
		Intent intent = new Intent(this, MailViewer.class);
		intent.putExtra(MailViewer.PREVIOUS_MAIL,false);
		intent.putExtra(MailViewer.NEXT_MAIL,false);
		intent.putExtra(MailViewer.DEL_MAIL,false);
		startActivityForResult(intent, R.layout.mail_viewer);
	}
	
	@Override
	protected void onActivityResult(int reqCode, int rstCode, Intent intent)
	{
		MyApp.setCurrentActivity(this);
		switch (reqCode)
		{
		case R.layout.mail_viewer:
		{
			if (MyApp.curMailInfo.getState() == MailStatus.MAIL_NEW)
			{
				String cmd = "update mail set state=? where accountId=? and uid=? and folder='"+MyApp.curMailInfo.getFolder()+"'";
				String[] args = { MailStatus.MAIL_READED + "",
									MyApp.currentAccount.id + "",
									MyApp.curMailInfo.getUid() };
				NewDbHelper.getInstance().execSQL(cmd, args);
				MyApp.curMailInfo.setState(MailStatus.MAIL_READED);
//				MyApp.curMailInfo = null;
				MyApp.setCurrentMailInfo(null);
			}
		}
			break;
		default:
			break;
		}
	}
}
package mobi.cloudymail.mailclient;

import java.util.Iterator;
import java.util.Set;
import java.util.Vector;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.data.OutMailInfo;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.view.View;


public  class OutBoxActivity extends MailFolderActivity
{
//	public static  boolean contentState;
	public static boolean contentState;
	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		//This activity can only be started from folder manager.
		super.onCreate(savedInstanceState);
		
		_markUnreadBtn.setVisibility(View.GONE);
		_markReadBtn.setVisibility(View.GONE);
		try
		{
			updateMail();
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		
		contentState=false;
		updateMailView();
	}
	
	@Override
	protected void initBaseTitle()
	{
		Intent intent = getIntent();
		_baseWinTitle = intent.getStringExtra(FolderNames.DAT_FOLDER_DESCRIPTION);
		this.folderName = intent.getStringExtra(FolderNames.DAT_FOLDER_NAME);
	}
	
	@Override
	protected void openMail(MailInfo mailInfo)
	{//open composer
//		MyApp.curMailInfo = getMail(selectedIdx+1);
		MyApp.setCurrentMailInfo(mailInfo);
		Intent intent = new Intent(this,Composer.class);
		intent.putExtra("composer_type", Composer.COMPOSER_EDIT_MAIL);
		startActivity(intent);
	}

	@Override
	protected int getUnreadMailcount(boolean query)
	{
		return -1;
	}
	
	@Override
	protected int getTotalMailCount(boolean query)
	{
		if (query)
		{
			totalMailCount = NewDbHelper.getInstance()
					.getOutMailCount(getCurrentAccountId(),
					                 folderName,
					                 new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED});
		}
		return totalMailCount;
	}
	
	@Override
	protected Cursor doQueryMail(int index)
	{
		return NewDbHelper.getInstance().getOutMails(getCurrentAccountId(),
		                                             Math.min(mailCountPerScreen, mails.length),
		                                             index,orderType,folderName);
	}
	
//	@Override
//	protected boolean doCreateOptionsMenu(Menu menu)
//	{
//		//hide account manager.
//		MenuItem accountItem = menu.findItem(R.id.accountMenu);
//		accountItem.setVisible(false);
//		return true;
//	}

	@Override
	protected MailInfo newMailInfo(Cursor cursor)
	{
		// TODO Auto-generated method stub
		return new OutMailInfo(cursor);
	}

	@Override
	protected MailInfo[] newMailInfoArray(int count)
	{
		// TODO Auto-generated method stub
		return new OutMailInfo[count];
	}

	protected void doUpdateAsteriskStates(MailInfo mailInfo,
			int asteriskState)
	{
		
			
			
			  NewDbHelper.getInstance().updateOutAsteriskstatu(mailInfo.getAccountId(), asteriskState, mailInfo.getUidx());
		
	}

	@Override
	protected String doUpdateMailStates(Iterator<MailInfo> mails, int state)
	{
		// update mail status
		Vector<Integer> ids = new Vector<Integer>();
		Vector<Integer> accountIds = new Vector<Integer>();
		Vector<String> folders= new Vector<String>();
		int i = 0;
		while (mails.hasNext())
		{
			MailInfo mailInfo = mails.next();
			if ((mailInfo.getState() & MailStatus.FLAG_HAS_MORE_PLACEHOLD)==0)
			{
				mailInfo.setState(state);
				ids.add(mailInfo.getUidx());
				accountIds.add(mailInfo.getAccountId());
				folders.add(mailInfo.getFolder());
				
			}
		}
		return  NewDbHelper.getInstance().updateOutMailStatus(accountIds, ids, state);
	}

	
	
	protected void updateMailItemView(MailInfo mailInfo, ViewHolder holder, View convertView)
	{
		holder.draftTxt.setVisibility(FolderNames.FOLDER_SENT.equals(mailInfo.getFolder())  ? View.GONE : View.VISIBLE);
		
	}

	@Override
	protected int getTotalGroupCount(boolean query) {
		return 0;
	}

	@Override
	protected Cursor doQueryGroup(int index) {
		return null;
	}

	@Override
	protected MailGroup newMailGroup(Cursor cursor) {
		return new MailGroup(cursor);
	}

	@Override
	protected Vector<MailGroup> newMailGroupArray(int count) {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	protected boolean inGroupMode()
	{
		return false;
	}

	/* (non-Javadoc)
	 * @see mobi.cloudymail.mailclient.MailFolderActivity#inReceiving()
	 */
	@Override
	protected boolean inReceiving()
	{
		// TODO Auto-generated method stub
		return false;
	}
}package mobi.cloudymail.mailclient;

import mobi.cloudymail.util.DialogResult;
import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.text.method.PasswordTransformationMethod;
import android.view.KeyEvent;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.TextView;

public class PasswordDialog extends Dialog
{
	int dialogResult;
	Handler mHandler ;
	public static PasswordDialog instence=null;
	public PasswordDialog(Context context, String mailName, boolean retry)
	{
		
		super(context);
//		setOwnerActivity(context);
		onCreate();
		TextView promptLbl = (TextView) findViewById(R.id.promptLbl);
		if(retry)
			promptLbl.setText("密码错误!"+"  "+"请重输以下邮箱的密码\n"+ mailName);
		else
			promptLbl.setText("请输入下面邮箱的密码\n" + mailName);

	}

	public String getPassword()
	{
		return ((EditText)findViewById(R.id.passwordTxt)).getText().toString();
	}
	
	public boolean needSavePassword()
	{
		return ((CheckBox)findViewById(R.id.savePasswordChk)).isChecked();
	}
	public int getDialogResult()
	{
		return dialogResult;
	}
	public void setDialogResult(int dialogResult)
	{
		this.dialogResult = dialogResult;
	}
	/** Called when the activity is first created. */
	
	public void onCreate() {
		
		instence=PasswordDialog.this;
		setContentView(R.layout.password_dialog);
		EditText et=(EditText) findViewById(R.id.passwordTxt);
		
		

		PasswordDialog.instence.setOnKeyListener(new OnKeyListener(){
	          @Override
	          public boolean onKey(DialogInterface arg0, int arg1, KeyEvent arg2) {
	           // TODO Auto-generated method stub        
	           if ((arg1 == KeyEvent.KEYCODE_ENTER && arg2.getAction() == KeyEvent.ACTION_DOWN ))
	           {  
	        	   PasswordDialog.instence.endDialog(DialogResult.OK);
	           }
	           return false;
	          }
	          
	         });
		
		findViewById(R.id.cancelBtn).setOnClickListener(new android.view.View.OnClickListener() {
			
			@Override
			public void onClick(View paramView)
			{
				endDialog(DialogResult.CANCEL);
			}

			});
		findViewById(R.id.okBtn).setOnClickListener(new android.view.View.OnClickListener() {
			
			@Override
			public void onClick(View paramView)
			{
				endDialog(DialogResult.OK);
			}

			});
		findViewById(R.id.showPasswordChk).setOnClickListener(new android.view.View.OnClickListener() {
			
			@Override
			public void onClick(View paramView)
			{
				if(				((CheckBox)paramView).isChecked())
				{
					((EditText)findViewById(R.id.passwordTxt)).setTransformationMethod(null);
				}
				else
					((EditText)findViewById(R.id.passwordTxt)).setTransformationMethod(PasswordTransformationMethod.getInstance());
				
			}
		});
	}
	
	public void endDialog(int result)
	{
		setDialogResult(result);
		Message m = mHandler.obtainMessage();
		mHandler.sendMessage(m);
		dismiss();
	}
	
	public int showDialog()
	{
		mHandler = new Handler(Looper.myLooper()) {
			@Override
			public void handleMessage(Message mesg) {
				// process incoming messages here
				//super.handleMessage(msg);
				throw new RuntimeException();
              }
		};
		super.show();
		try {
			Looper.loop();
		}
		catch(Throwable e2)
		{
		}
		return dialogResult;
	}
	
}
package mobi.cloudymail.mailclient;


import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.AttributeSet;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.LinearInterpolator;
import android.view.animation.RotateAnimation;
import android.widget.AbsListView;
import android.widget.AbsListView.OnScrollListener;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.RelativeLayout;
import android.widget.TextView;

public class PullToRefreshListView extends ExpandableListView implements OnScrollListener {

    private static final int TAP_TO_REFRESH = 1;
    private static final int PULL_TO_REFRESH = 2;
    private static final int RELEASE_TO_REFRESH = 3;
    private static final int REFRESHING = 4;

    private static final String TAG = "PullToRefreshListView";

    private OnRefreshListener mOnRefreshListener;

    /**
     * Listener that will receive notifications every time the list scrolls.
     */
    private OnScrollListener mOnScrollListener;
    private LayoutInflater mInflater;

    private RelativeLayout mRefreshView;
    private TextView mRefreshViewText;
    private ImageView mRefreshViewImage;
    private ProgressBar mRefreshViewProgress;
    private TextView mRefreshViewLastUpdated;

    private int mCurrentScrollState;
    private int mRefreshState;

    private RotateAnimation mFlipAnimation;
    private RotateAnimation mReverseFlipAnimation;

    private int mRefreshViewHeight;
    private int mRefreshOriginalTopPadding;
    private int mLastMotionY;

    private boolean mBounceHack;

    public PullToRefreshListView(Context context) {
        super(context);
        init(context);
    }

    public PullToRefreshListView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public PullToRefreshListView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(context);
    }
	Handler mHandler;
	boolean pullEnabled = true;
	
    private void init(Context context) {
        // Load all of the animations we need in code rather than through XML
        mFlipAnimation = new RotateAnimation(0, -180,
                RotateAnimation.RELATIVE_TO_SELF, 0.5f,
                RotateAnimation.RELATIVE_TO_SELF, 0.5f);
        mFlipAnimation.setInterpolator(new LinearInterpolator());
        mFlipAnimation.setDuration(250);
        mFlipAnimation.setFillAfter(true);
        mReverseFlipAnimation = new RotateAnimation(-180, 0,
                RotateAnimation.RELATIVE_TO_SELF, 0.5f,
                RotateAnimation.RELATIVE_TO_SELF, 0.5f);
        mReverseFlipAnimation.setInterpolator(new LinearInterpolator());
        mReverseFlipAnimation.setDuration(250);
        mReverseFlipAnimation.setFillAfter(true);

        mInflater = (LayoutInflater) context.getSystemService(
                Context.LAYOUT_INFLATER_SERVICE);

		mRefreshView = (RelativeLayout) mInflater.inflate(
				R.layout.pull_to_refresh_header, this, false);
        mRefreshViewText =
            (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_text);
        mRefreshViewImage =
            (ImageView) mRefreshView.findViewById(R.id.pull_to_refresh_image);
        mRefreshViewProgress =
            (ProgressBar) mRefreshView.findViewById(R.id.pull_to_refresh_progress);
        mRefreshViewLastUpdated =
            (TextView) mRefreshView.findViewById(R.id.pull_to_refresh_updated_at);

        mRefreshViewImage.setMinimumHeight(50);
        mRefreshView.setOnClickListener(new OnClickRefreshListener());
        mRefreshOriginalTopPadding = mRefreshView.getPaddingTop();

        mRefreshState = TAP_TO_REFRESH;
         
        if(context instanceof OutBoxActivity)
        	pullEnabled = false;
        if(pullEnabled)
        {
	        addHeaderView(mRefreshView);
	//        setOverscrollHeader(mRefreshView);
	        super.setOnScrollListener(this);
	
	        measureHeader();
	    }
        mHandler = new Handler() {
    		@Override
    		public void handleMessage(Message mesg)
    		{
    			// process incoming messages here
    			// super.handleMessage(msg);
    			throw new RuntimeException();
    		}
    	};
    }

	public void measureHeader()
	{
		measureView(mRefreshView);
        mRefreshViewHeight = mRefreshView.getMeasuredHeight();
	}

    @Override
    protected void onAttachedToWindow() {
    	if(!pullEnabled)
    		return;
//    	setSelectionFromTop(1,0);
    	setSelectionTo1();

    }
    private Runnable runable = new Runnable() {
		
		@Override
		public void run()
		{
			setSelectionFromTop(1, 10);
//			setSelectionFromTop(1, 0);
//			scrollTo(0, 0);
		}
	};
private Runnable runable2 = new Runnable() {
		
		@Override
		public void run()
		{
			clearChoices();
			
		}
	};
    private void setSelectionTo1()
    {
		mHandler.postDelayed(runable, 200);
		mHandler.postDelayed(runable2, 500);
    }
    
    @Override
    public void setAdapter(ListAdapter adapter) {
        super.setAdapter(adapter);
        if(!pullEnabled)
    		return;
        measureHeader();
        setSelectionTo1();
    }
    
    

    /**
     * Set the listener that will receive notifications every time the list
     * scrolls.
     * 
     * @param l The scroll listener. 
     */
    @Override
    public void setOnScrollListener(AbsListView.OnScrollListener l) {
        mOnScrollListener = l;
    }

    /**
     * Register a callback to be invoked when this list should be refreshed.
     * 
     * @param onRefreshListener The callback to run.
     */
    public void setOnRefreshListener(OnRefreshListener onRefreshListener) {
        mOnRefreshListener = onRefreshListener;
    }

    /**
     * Set a text to represent when the list was last updated. 
     * @param lastUpdated Last updated at.
     */
    public void setLastUpdated(CharSequence lastUpdated) {
        if (lastUpdated != null) {
            mRefreshViewLastUpdated.setVisibility(View.VISIBLE);
            mRefreshViewLastUpdated.setText(lastUpdated);
        } else {
            mRefreshViewLastUpdated.setVisibility(View.GONE);
        }
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        final int y = (int) event.getY();
        if(pullEnabled)
        {
	        mBounceHack = false;
	        
	        switch (event.getAction()) {
	            case MotionEvent.ACTION_UP:
	                if (!isVerticalScrollBarEnabled()) {
	                    setVerticalScrollBarEnabled(true);
	                }
	                if (getFirstVisiblePosition() == 0 && mRefreshState != REFRESHING) {
	                    if ((mRefreshView.getBottom() >= mRefreshViewHeight+50
	                           )
	                            && mRefreshState == RELEASE_TO_REFRESH) {
	                        // Initiate the refresh
	                        mRefreshState = REFRESHING;
	                        prepareForRefresh();
	                        onRefresh();
	                    } else if (mRefreshView.getBottom() < mRefreshViewHeight+50
	                           ) {
	                        // Abort refresh and scroll down below the refresh view
	                        resetHeader();
	                        setSelectionTo1();
	                    }
	                }
	                break;
	            case MotionEvent.ACTION_DOWN:
	                mLastMotionY = y;
	                break;
	            case MotionEvent.ACTION_MOVE:
	                applyHeaderPadding(event);
	                break;
	        }
        }
        return super.onTouchEvent(event);
    }

    private void applyHeaderPadding(MotionEvent ev) {
        // getHistorySize has been available since API 1
        int pointerCount = ev.getHistorySize();

        for (int p = 0; p < pointerCount; p++) {
            if (mRefreshState == RELEASE_TO_REFRESH||mRefreshState==PULL_TO_REFRESH) {
                if (isVerticalFadingEdgeEnabled()) {
                    setVerticalScrollBarEnabled(false);
                }

                int historicalY = (int) ev.getHistoricalY(p);

                // Calculate the padding to apply, we divide by 1.7 to
                // simulate a more resistant effect during pull.
                int topPadding = (int) (((historicalY - mLastMotionY)
                        - mRefreshViewHeight) / 1.7);

                mRefreshView.setPadding(
                        mRefreshView.getPaddingLeft(),
                        topPadding,
                        mRefreshView.getPaddingRight(),
                        mRefreshView.getPaddingBottom());
            }
        }
    }

    /**
     * Sets the header padding back to original size.
     */
    private void resetHeaderPadding() {
        mRefreshView.setPadding(
                mRefreshView.getPaddingLeft(),
                mRefreshOriginalTopPadding,
                mRefreshView.getPaddingRight(),
                mRefreshView.getPaddingBottom());
    }

    /**
     * Resets the header to the original state.
     */
    private void resetHeader() {
        if (mRefreshState != TAP_TO_REFRESH) {
            mRefreshState = TAP_TO_REFRESH;

            resetHeaderPadding();

            // Set refresh view text to the pull label
            mRefreshViewText.setText(R.string.pull_to_refresh_tap_label);
            // Replace refresh drawable with arrow drawable
            mRefreshViewImage.setImageResource(R.drawable.ic_pulltorefresh_arrow);
            // Clear the full rotation animation
            mRefreshViewImage.clearAnimation();
            // Hide progress bar and arrow.
            mRefreshViewImage.setVisibility(View.GONE);
            mRefreshViewProgress.setVisibility(View.GONE);
        }
    }

    private void measureView(View child) {
        ViewGroup.LayoutParams p = child.getLayoutParams();
        if (p == null) {
            p = new ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.FILL_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT);
        }

        int childWidthSpec = ViewGroup.getChildMeasureSpec(0,
                0 + 0, p.width);
        int lpHeight = p.height;
        int childHeightSpec;
        if (lpHeight > 0) {
            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);
        } else {
            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
        }
        child.measure(childWidthSpec, childHeightSpec);
    }

    @Override
	public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
			int totalItemCount)
	{

		// When the refresh view is completely visible, change the text to say
		// "Release to refresh..." and flip the arrow drawable.
		if (mCurrentScrollState == SCROLL_STATE_TOUCH_SCROLL && mRefreshState != REFRESHING)
		{
			if (firstVisibleItem == 0)
			{
				mRefreshViewImage.setVisibility(View.VISIBLE);
				if (mRefreshView.getBottom() < mRefreshViewHeight + 50
					&& mRefreshState != PULL_TO_REFRESH)
				{
					mRefreshViewText.setText(R.string.pull_to_refresh_pull_label);
					if (mRefreshState != TAP_TO_REFRESH)
					{
						mRefreshViewImage.clearAnimation();
						mRefreshViewImage.startAnimation(mReverseFlipAnimation);
					}
					mRefreshState = PULL_TO_REFRESH;
				}
				else if ((mRefreshView.getBottom() >= mRefreshViewHeight + 50)
							&& mRefreshState != RELEASE_TO_REFRESH)
				{
					mRefreshViewText.setText(R.string.pull_to_refresh_release_label);
					mRefreshViewImage.clearAnimation();
					mRefreshViewImage.startAnimation(mFlipAnimation);
					mRefreshState = RELEASE_TO_REFRESH;
				}
			}
			else
			{
				mRefreshViewImage.setVisibility(View.GONE);
				resetHeader();
			}
		}
		else if (mCurrentScrollState == SCROLL_STATE_FLING && firstVisibleItem == 0
					&& mRefreshState != REFRESHING)
		{
			setSelectionTo1();
			mBounceHack = true;
		}
		else if (mBounceHack && mCurrentScrollState == SCROLL_STATE_FLING)
		{
			setSelectionTo1();
		}

		// if (mOnScrollListener != null) {
		// mOnScrollListener.onScroll(view, firstVisibleItem,
		// visibleItemCount, totalItemCount);
		// }
	}

    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
    	
    	mCurrentScrollState = scrollState;
        
        if (mCurrentScrollState == SCROLL_STATE_IDLE) {
            mBounceHack = false;
        }

//        if (mOnScrollListener != null) {
//            mOnScrollListener.onScrollStateChanged(view, scrollState);
//        }
    }

    public void prepareForRefresh() {
        resetHeaderPadding();

        mRefreshViewImage.setVisibility(View.GONE);
        // We need this hack, otherwise it will keep the previous drawable.
        mRefreshViewImage.setImageDrawable(null);
        mRefreshViewProgress.setVisibility(View.VISIBLE);
        
        // Set refresh view text to the refreshing label
        mRefreshViewText.setText(R.string.pull_to_refresh_refreshing_label);

        mRefreshState = REFRESHING;
    }

    public void onRefresh() {
        Log.d(TAG, "onRefresh");

        if (mOnRefreshListener != null) {
            mOnRefreshListener.onRefresh();
        }
    }

    /**
     * Resets the list to a normal state after a refresh.
     * @param lastUpdated Last updated at.
     */
    public void onRefreshComplete(CharSequence lastUpdated) {
        setLastUpdated(lastUpdated);
        onRefreshComplete(true);
    }

    /**
     * Resets the list to a normal state after a refresh.
     */
    public void onRefreshComplete(boolean scrollViewToTop) {        
        Log.d(TAG, "onRefreshComplete");

        resetHeader();

        // If refresh view is visible when loading completes, scroll down to
        // the next item.
        if (mRefreshView.getBottom() > 0) {
            invalidateViews();
            if(scrollViewToTop)
            {
            	 setSelectionTo1();
            }
        }
    }

    /**
     * Invoked when the refresh view is clicked on. This is mainly used when
     * there's only a few items in the list and it's not possible to drag the
     * list.
     */
    private class OnClickRefreshListener implements OnClickListener {

        @Override
        public void onClick(View v) {
            if (mRefreshState != REFRESHING) {
                prepareForRefresh();
                onRefresh();
            }
        }

    }

    /**
     * Interface definition for a callback to be invoked when list should be
     * refreshed.
     */
    public interface OnRefreshListener {
        /**
         * Called when the list should be refreshed.
         * <p>
         * A call to {@link PullToRefreshListView #onRefreshComplete()} is
         * expected to indicate that the refresh has completed.
         */
        public void onRefresh();
    }
    
    public void enforceToRefreshState()
    {
    	prepareForRefresh();
    	Runnable runable = new Runnable() {
    			
    			@Override
    			public void run()
    			{
    				setSelectionFromTop(0, 0);
    			}
    		};
    	   
    		mHandler.postDelayed(runable, 1);
    	   

    }
}
package mobi.cloudymail.mailclient;

import mobi.cloudymail.util.MyApp;
import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

public class PushMailService extends Service
{
	
	@Override
	public IBinder onBind(Intent arg0)
	{
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public int onStartCommand(Intent intent, int flags, int startId)
	{
		if(!MyApp.enableService)
			return START_NOT_STICKY ;
		PushManager.getInstance().start();
		// We want this servie to continue running until it is explicitly
		// stopped, so return sticky.
		return START_STICKY;
	}



}
package mobi.cloudymail.mailclient;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Inet4Address;
import java.net.Socket;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;


import mobi.cloudymail.mailclient.AccountManager.AccountChangeListener;
import mobi.cloudymail.mailclient.ReceiveMailService.SyncRequest;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.protocol.imap.Folder;
import mobi.cloudymail.protocol.imap.ImapStore;
import mobi.cloudymail.protocol.imap.K9;
import mobi.cloudymail.protocol.imap.PushReceiver;
import mobi.cloudymail.protocol.imap.Pusher;
import mobi.cloudymail.protocol.imap.TracingPowerManager.TracingWakeLock;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.Utils;
import android.content.Context;
import android.util.Log;

public class PushManager extends Thread
{
	public static final String TAG="CloudMailPush";
	public static final int PACKET_TYPE_PUSHREQUEST = 1;
	private Socket socket;
	private OutputStream outputStream;
	private InputStream inputStream;
	private static PushManager instance;
	
	public static PushManager getInstance()
	{
		if(instance == null || !instance.isAlive())
			instance = new PushManager();
		return instance;
		
	}
	@Override
	public void run()
	{
		setName("PushManager");
//		try {
	
		Log.d(TAG, "start");
		Utils.log("PushManager thread start run");
		while(true)
		{
			
			StringBuilder sb  = new StringBuilder(512);
			
			for(Account a:AccountManager.getAccounts())
			{
				String sid = MyApp.getAgent(a).getSessionId(false,false, false);
				if(sid != null)
				{
					sb.append(sid).append(" ");
				}
			}
			
			String s = sb.toString();
			if(s.length() == 0)
			{
				try
				{
					Thread.sleep(60*1000);
				}
				catch (InterruptedException e)
				{
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				continue;
			}
			Log.d(TAG, "Send request:"+s);
			byte[] buf = s.getBytes();
			
			try
			{
				if(socket == null || socket.isClosed())
				{
					socket = new Socket(Inet4Address.getByName(ServerAgent.getPushServer()), ServerAgent.PUSH_MAIL_PORT);
					socket.setSoTimeout(29*60*1000);//time out in 29 minutes
					outputStream = socket.getOutputStream();
					inputStream = socket.getInputStream();
				}
				byte[] header = new byte[3];
				header[0] = PACKET_TYPE_PUSHREQUEST;
				header[1] = (byte)(buf.length&0xff);
				header[2] = (byte)((buf.length >> 8)&0xff);
				
				outputStream.write(header);
				outputStream.write(buf);
				outputStream.flush();			
								
				int bytesWant = 3;
//				socket.setSoTimeout(0);//time out in 29 minutes

				int len = readBytes(inputStream, buf, 0, bytesWant);
				Log.d(TAG, "Get data from server");
				if(len < bytesWant)
					continue;
				bytesWant = intFromBytes(buf[2], buf[1]);
				len = readBytes(inputStream, buf, 0, bytesWant);
				if(len < bytesWant)
					continue;
				String account = new String(buf,0,len, "UTF-8");
				if(!account.startsWith("OK "))
					continue;
				account=account.substring(3);
				Log.d(TAG, "new mail pushed for:"+account);
				Account a = AccountManager.getAccount(account);
				if(a == null)
					continue;
				SyncRequest r = new SyncRequest();
				Vector v = new Vector();
				v.add(a);
				r.setAccountsToSync(v);
				ReceiveMailService.addToSyncQueue(r);
			}
			catch (Exception e)
			{
				
				e.printStackTrace();
				try
				{
					Thread.sleep(60*1000);
				}
				catch (InterruptedException e1)
				{
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			}
		
			
		}
//	}
//	catch(NullPointerException ex)
//	{
//		ex.printStackTrace();
//	}
	}
	synchronized int readBytes(InputStream inputStream, byte[] buf, int offset, int lenRequested) throws IOException
    {
        int cnt = 0;
     	try
    	{
	    	while (cnt < lenRequested)
	        {
	    		
	    		int r = inputStream.read(buf, offset, lenRequested - cnt);
	    		if(r == -1)
	    			return cnt;
	    		offset += r;
	        	cnt += r;
	        }
	        return cnt;
    	}
    	finally
    	{
    		
    	}
    }
	
	public static int intFromBytes(byte h, byte l)
	{
		return (((h&0x000000ff) << 8) | (l&0x000000ff))&0xffff;
	}
	
	public void restart() 
	{
		Utils.log("PushManager restart");
		if(isAlive())
		{
			try
			{
				if(socket != null && socket.isConnected())
					socket.close();
			}
			catch (IOException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		else
		{
			Utils.log("Push thread not running, restart it");
			
			start();
		}
	}
	
	@Override 
	public void start()
	{
		super.start();
	}
}
package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.LinkedBlockingQueue;

import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.Result;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Intent;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.util.Log;

public class ReceiveMailService extends Service
{
	public static final String PUSH_STRING = "PushFrequency";

	// key is account id, value is session id.
	private Map<Integer, SessionTime> idMap = new HashMap<Integer, SessionTime>();
	private Thread _thread = null;
	private Handler _handler = null;
	private NotificationManager mNM = null;
	private Notification _notification = null;
	private PendingIntent _ntfIntent = null;
	public final static int HOLDON_MINUTES = 30;
	public static ReceiveMailService _instance = null;
	
	public static class SyncRequest
	{
		private Iterable<Account> accountsToSync;
		public void setAccountsToSync(Iterable<Account> accounts)
		{
			accountsToSync = accounts;
		}
	}
	private static LinkedBlockingQueue<SyncRequest> accountToSync = new LinkedBlockingQueue<SyncRequest>();
	
	private class SessionTime
	{
		public String _sessionId = null;
		public long _loginTime = 0;
	}

	private long getHoldonTime()// in ms unit
	{
		return HOLDON_MINUTES * 60000;
	}

	private long getIntervalMs()
	{
		return MyApp.userSetting.getPushFrequency() * 60000;
	}

	@Override
	public IBinder onBind(Intent arg0)
	{
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void onCreate()
	{
		Log.d(LOGTAG, "ReceiveMailService" + "onCreate");
		mNM = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		// showNotification(1);
		super.onCreate();
		_instance = this;
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId)
	{
		if(!MyApp.enableService)
			return START_NOT_STICKY ;
		Log.d(LOGTAG, "ReceiveMailService" + "Received start id " + startId + ": " + intent);
		if(intent.getIntExtra(BootReceiver.CONNECTIVITY_ACTION, -1) == 1)
		{
			//connection changed, restart push service
			PushManager.getInstance().restart();
			return START_REDELIVER_INTENT;
		}
		
		PushManager.getInstance().restart();

		idMap.clear();
		if (MyApp.userSetting.getPushFrequency() <= 0)
		{
			return START_REDELIVER_INTENT;
		}
		if (_thread != null && _thread.isAlive())
		{
			_thread.interrupt();
			try
			{
				_thread.join();
				Log.d(LOGTAG, "Service restart");
			}
			catch (InterruptedException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		// start check new mail in background task.
		startBackgroundTask();

		// We want this servie to continue running until it is explicitly
		// stopped, so return sticky.
		return START_REDELIVER_INTENT;
	}

	private void sendUpdataData()
	{
		Intent intent = new Intent();
		intent.setAction("mobi.cloudymail.mailclient.ReceiveMailService");
		Log.d(LOGTAG, "<<<<<<<start sendBroadCast>>>>>>");
		sendBroadcast(intent);

	}

	@Override
	public void onDestroy()
	{
		// _handler.removeCallbacks(_runnable);
		Log.d(LOGTAG, "ReceiveMailService" + "try to cancel notification");
		idMap.clear();
		if (_thread != null)
		{
			_thread.interrupt();
		}
		mNM.cancel(R.string.ntf_new_mail_name);
		super.onDestroy();
		_instance = null;
		MyApp.finishAllActivities();
		// android.os.Process.killProcess(android.os.Process.myPid());
		System.exit(0);
	}

	private class MyHandler extends Handler
	{
		public void handleMessage(Message msg)
		{
			showNotification(msg.what);
			super.handleMessage(msg);
		}
	}

	private void startBackgroundTask()
	{
		if (_thread == null || !_thread.isInterrupted())
		{
			_handler = new MyHandler();
			_thread = new Thread() {

				@Override
				public void run()
				{
					try
					{

						while(true)
						{
							SyncRequest req = accountToSync.take();
							if (!ServerAgent.hasNetworkConnection())
							{
								Log.d(LOGTAG, "ReceiveMailService" + "network is not available");
								continue;
							}

							// receive mails for all accounts;
							DefaultHttpClient sClient = ServerAgent.getHttpClient();
							int mailCount = 0;
							
							
							for (mobi.cloudymail.mailclient.net.Account a : req.accountsToSync)
							{
								if (a.password == null || a.password.equals(""))
									continue;

								mailCount += syncMail(sClient, a);
							}// for

							// if has new mail, notify user.
							if (mailCount > 0)
							{
								Log.d(LOGTAG, "ReceiveMailServer" + "send empty message to handler");
								sendUpdataData();
								_handler.sendEmptyMessage(mailCount);
							}
						}// while
					}
					catch (InterruptedException e)
					{
						Log.d(LOGTAG, "ReceiveMailService" + "receive InterruptedException");
					}
					finally
					{
						Log.d(LOGTAG, "ReceiveMailService" + "Exite thread");
					}
				}

				private int syncMail(DefaultHttpClient sClient,  Account a)
				{
					int mailCount = 0;
					try
					{
						HttpResponse rsp = null;
						String sessionId = null;
						// check whether need to login at first.
						SessionTime sti = idMap.get(a.id);
						// if not login yet or timeout.
						if (sti == null
							|| (System.nanoTime() / 1000000 - sti._loginTime) > getHoldonTime())
						{
							sClient.getCookieStore().clear();
							ServerAgent ag = MyApp.getAgent(a);
							sessionId = ag.getSessionId(false, false, false);
							if (Utils.isEmpty(sessionId))
							{
								Log.d(LOGTAG, "ReceiveMailServer" + "login " + a.name
												+ " failed");
								return mailCount;
							}

							// save login time and session id;
							sti = new SessionTime();
							sti._loginTime = System.nanoTime() / 1000000;
							sti._sessionId = sessionId;
							idMap.put(a.id, sti);
						}
						else
						{
							sessionId = sti._sessionId;
							Log.d(LOGTAG, "ReceiveMailService" + "use last login for "
											+ a.name);
						}
						String sql = "select max(uidx) from mail where accountId="
										+ a.id + " and state!="
										+ MailStatus.MAIL_DELETED;
						int normalMaxIdx = NewDbHelper.getInstance()
								.executScalar(sql, null);
						int deleteMaxIdx = NewDbHelper
								.getInstance()
								.executScalar(	"select max(uidx) from mail where accountId="
														+ a.id
														+ " and state="
														+ MailStatus.MAIL_DELETED, null);
						HttpGet req = new HttpGet(
													ServerAgent.getUrlBase()
															+ "/SyncupMail?nm="
															+ normalMaxIdx
															+ "&dm="
															+ deleteMaxIdx
															+ "&cn=1"
															+ (MyApp.userSetting.countPerReception > 0	? ("&mc=" + MyApp.userSetting.countPerReception)
																										: "")
															+ "&sid="
															+ java.net.URLEncoder
																	.encode(sessionId));
						rsp = ServerAgent.execute(req);
						Result rst = new Result(rsp.getEntity().getContent());
						if (!rst.isSuccessed())
							return mailCount;
						mailCount += NewDbHelper.getInstance()
								.insertMailsToDb(rst.xmlReader, a.id);
						NewDbHelper.getInstance().updateMailGroupState();
						Log.d(LOGTAG, "ReceiveMailServer" + "receive " + mailCount
										+ " mails");

					}
					catch (Exception ex)
					{
						Log.d(LOGTAG, "ReceiveMailServer" + "login/receive mail "
										+ a.name + " exception");
						ex.printStackTrace();
					}
					return mailCount;
				}
			};
		}
		else
			_thread.interrupt();
		try
		{
			_thread.start();
		}
		catch (IllegalThreadStateException ex)
		{
			ex.printStackTrace();
			Log.d(LOGTAG, "ReceiveMailService" + "Failed to start receive mail thread");
		}
	}

	/**
	 * Show a notification while this service is running.
	 */
	private void showNotification(int newMailCount)
	{

		Log.d(LOGTAG, "ReceiveMailServer" + "now notify user in status bar");
		// Set the icon, scrolling text and timestamp
		Resources res = getResources();
		if (_notification == null)
		{
			_notification = new Notification(R.drawable.cloudymail,
												res.getString(R.string.ntf_new_mail_name),
												System.currentTimeMillis());
			// The PendingIntent to launch our activity if the user selects this
			// notification
			Intent intent = new Intent(this, GlobalInBoxActivity.class);
			intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
			intent.putExtra(MailFolderActivity.CLIENT_OPEN_MODE,
							MailFolderActivity.OPEN_FROM_STATUS_BAR);
			_ntfIntent = PendingIntent.getActivity(this, 0, intent, 0);
		}
		else
			_notification.when = System.currentTimeMillis();
		_notification.number = newMailCount;

		// reset flag;
		_notification.flags = Notification.FLAG_AUTO_CANCEL;
		_notification.defaults = 0;
		if (MyApp.userSetting._ledFlag)
		{
			// _notification.defaults |= Notification.DEFAULT_LIGHTS;
			Log.d(LOGTAG, "ReceiveMailService" + "led flag on");
			// _notification.flags |= Notification.FLAG_SHOW_LIGHTS;

			_notification.ledARGB = 0x00FF00;// Color.RED;
			_notification.ledOffMS = 100;
			_notification.ledOnMS = 100;
			_notification.flags |= Notification.FLAG_SHOW_LIGHTS;

		}
		if (MyApp.userSetting._vibrateFlag)
		{
			_notification.defaults |= Notification.DEFAULT_VIBRATE;
			Log.d(LOGTAG, "ReceiveMailService" + "vibrate on");
		}
		// if(!MailClient.userSetting._ringtone.equals(""))
		_notification.sound = Uri.parse(MyApp.userSetting._ringtone);
		Log.d(LOGTAG, "ReceiveMailService" + "ringtone:" + MyApp.userSetting._ringtone);

		// _notification.flags |= Notification.FLAG_AUTO_CANCEL;

		// Set the info for the views that show in the notification panel.
		_notification.setLatestEventInfo(this, res.getString(R.string.appName), 
		                                 res.getString(R.string.ntf_new_mail_title, newMailCount),
		                                 _ntfIntent);

		// Send the notification.
		// We use a layout id because it is a unique number. We use it later to
		// cancel.
		mNM.notify(R.string.ntf_new_mail_name, _notification);
	}

	public static void addToSyncQueue(SyncRequest r)
	{
		accountToSync.offer(r);
	}
}
package mobi.cloudymail.mailclient;

import java.util.Date;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.Result;
import mobi.cloudymail.mailclient.net.ServerAgent;
import mobi.cloudymail.util.MessageBox;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

import org.apache.http.Header;
import org.apache.http.HttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

import android.content.res.Resources;
import android.os.AsyncTask;
import android.util.Log;
import android.util.Xml;

class ReceiveMailTask extends AsyncTask<Boolean, Void, Result>
	{
		/**
		 * 
		 */
		public static interface ReceiveMailCallback
		{
			void receiveFinished(int status);
		}
		private HttpGet req = null;
		private int mailUidxCeil = -1;
		int mailCount = 0;
		private String errorMsg;
		InBoxActivity _mainWnd;
		private boolean receiveAll = false;
		private String folderName;
		boolean beQuiet= false;
		private ReceiveMailCallback onFinishCallBack;
		boolean scrollViewToTop = true;
		private String accountName=null;
		/**
		 * use this constructor to ask this task work on 'get more mail' mode.
		 * in this mode, task try to download mails whose uidx is not great than
		 * mailUidxCeil
		 * 
		 * @param mailUidxCeil
		 * @param inBoxActivity 
		 */
		public ReceiveMailTask(int mailUidxCeil,InBoxActivity mainWnd, boolean receiveAll, boolean quiet, boolean scrollViewToTop)
		{
			
			this( mailUidxCeil, mainWnd,  receiveAll,  quiet, scrollViewToTop, null);
		}
		public ReceiveMailTask(int mailUidxCeil,InBoxActivity mainWnd, boolean receiveAll, boolean quiet, boolean scrollViewToTop, ReceiveMailCallback onFinish)
		{
			this.mailUidxCeil = mailUidxCeil;
			this.receiveAll = receiveAll;
			_mainWnd = mainWnd;
			folderName = mainWnd.folderName;
			this.beQuiet = quiet;
			this.scrollViewToTop = scrollViewToTop;
			this.onFinishCallBack = onFinish;
			
		}

		
		public void abort()
		{
			this._mainWnd.setProgressBarVisible(false);
			cancel(true);
			if(req !=null)
				req.abort();
			((PullToRefreshListView)this._mainWnd.getExpandableListView()).onRefreshComplete(scrollViewToTop);
		}
		
//		@Override
//		public void onCancelled(Result o)
//		{
//			
//		}
		@Override
		protected Result doInBackground(Boolean... checkNewMail)
		{
			if(isCancelled())
				return null;
			Result rst = new Result();
			if(receiveAll)
			{
				for(int i=0;i<AccountManager.getCount();i++)
				 {
					if(isCancelled())
						return null;
					Account a = AccountManager.getByIndex(i);
					Result r = doReceiveOnce(a, checkNewMail);
					if(r==null)
						return null;
					else if(r.mailCount>0) 
						rst=r;
				 }
				return rst;
			}
			else
			{	
				accountName=MyApp.currentAccount.name;
				return doReceiveOnce(MyApp.currentAccount, checkNewMail);
			}
		
				
		}
       /**
        * insert mailInfo into group tables
        * 
        * tables column
        * [accoundId  Id  suffix]
        *  Id & groupId 映射
        * 
        * @param a
        * @param checkNewMail
        * @return
        */
		private Result doReceiveOnce(final Account a, Boolean... checkNewMail)
		{
			Log.d(Utils.LOGTAG, "Start doReceiveOnce");
			ServerAgent agent = MyApp.getAgent(a);
			int status=Result.FAIL;
			Result result = null;
			try
			{
				agent.setReceiving(true);
				if(Utils.isEmpty(agent.getSessionId(false, !beQuiet, !beQuiet)))
					return null;
				if(isCancelled())
					return null;
				boolean doLogin = false;
				_mainWnd.stoppedByUser = false;
				boolean checkNew = checkNewMail[0].booleanValue();
				if(mailUidxCeil != 0)
					checkNew = false;
				
receiveMailLoop:
				while (!_mainWnd.stoppedByUser)
				{
					if (doLogin)
					{
						if(!agent.interactiveLogin(false,!beQuiet, !beQuiet))
							return null;
						doLogin = false;
					}//-----------------------end if
					if(isCancelled())
						return null;
					String sql = "select max(uidx) from mail where accountId="+ a.id
									+ " and state in (" + MailStatus.MAIL_NEW
									+","+MailStatus.MAIL_READED
									+","+MailStatus.MAIL_LOCAL_DELETED
									+","+MailStatus.MAIL_DELETE_FOREVER
									+ ") and folder='"+folderName+"'";
					if (mailUidxCeil > 0)
					{
						sql += " and uidx < " + mailUidxCeil;
					}

					int normalMaxIdx = NewDbHelper.getInstance()
							.executScalar(sql, null);
					int deleteMaxIdx = NewDbHelper
							.getInstance()
							.executScalar(	"select max(uidx) from mail where accountId="
													//+ MyApp.currentAccount.id
													+ a.id
													+ " and state=" + MailStatus.MAIL_DELETED
													+ " and folder='"+folderName+"'",
											null);
					
					
					errorMsg = null;

					try
					{
						//ServerAgent agent = MyApp.getAgent();
						
						String sid = agent.getSessionId(false,!beQuiet,!beQuiet);
						if(sid == null)
							return null;
						if(isCancelled())
							return null;
						req = new HttpGet(
											ServerAgent.getUrlBase()
													+ "/SyncupMail?nm="
													+ normalMaxIdx
													+ "&foldername="
													+ java.net.URLEncoder.encode(folderName, "UTF-8")
													+ "&dm="
													+ deleteMaxIdx
													+ (checkNew ? "&cn=1" : "")
													+ ((mailUidxCeil > 0)	? ("&LE=" + mailUidxCeil)
																			: "")
													+ (MyApp.userSetting.countPerReception > 0	? ("&mc=" + MyApp.userSetting.countPerReception)
																									: "")
													+ "&sid=" + java.net.URLEncoder.encode(sid));
						Log.d(Utils.LOGTAG, "To run Http execute");
						HttpResponse rsp = ServerAgent.execute(req);
						Log.d(Utils.LOGTAG, "Finish Http execute");
						Header[] headers = rsp.getHeaders("Content-Type");
						if(headers == null || headers.length == 0 || !headers[0].getValue().startsWith("text/xml") )
						{
							return null;
						}
						//server doesn't set Content-Length in header
//						headers = rsp.getHeaders("Content-Length");
//						if(headers == null || headers.length == 0 || Integer.parseInt(headers[0].getValue()) <=0 )
//						{
//							return null;
//						}
						
//						/*
//						 * <Result>
//						 * 		<status code="1" reason="NEED_LOGIN"/>
//						 * 		<content>
//						 * 			<mail uid="aaa" subject="bbb" />
//						 * 		</content>
//						 * </Result>
//						 */
						///////////////////////////////////
						XmlPullParser parser=Xml.newPullParser();
						parser.setInput(rsp.getEntity().getContent(), "UTF-8");
						int eventType=parser.getEventType();
						String tagName=null;
						
						
						while(eventType!=XmlPullParser.END_DOCUMENT)
						{
							
							if(eventType==XmlPullParser.START_TAG)
							{
								tagName=parser.getName();
								if(tagName.equalsIgnoreCase("status"))
								{
									status=Integer.parseInt(parser.getAttributeValue(null, "code"));
									if (status == Result.NEEDLOGIN_FAIL)
									{
										doLogin = true;
										continue receiveMailLoop;
									}
									result = new Result();
									result.status = status;
								}
//									if(tagName.equalsIgnoreCase("content"))
//									{
//										hasMore =parser.getAttributeValue(null, "hasMore");
//										
//									}
								if (tagName.equalsIgnoreCase("mail"))
								{
								    
									if (status == Result.SUCCESSED)
									{
										int attachmentFlag=0;
										MailInfo mailInfo=new MailInfo();
										mailInfo.setUid(parser.getAttributeValue(0));
										mailInfo.setSubject(parser.getAttributeValue(1));
										String date=parser.getAttributeValue(2);
										if(Utils.isEmpty(date))
											break;
										mailInfo.setDate(Utils.netDateFormater.parse(date));
										mailInfo.setFrom(parser.getAttributeValue(3));
									    mailInfo.setUidx(Integer.parseInt(parser.getAttributeValue(5)));
									    mailInfo.setState(Integer.parseInt(parser.getAttributeValue(6)));
									    if((mailInfo.getState() & MailStatus.FLAG_HAS_MORE_PLACEHOLD)!=0)
									    {
									    	byte[] b = {(byte) 0xff};
									    	String s = new String(b);
									    	mailInfo.setSubject(s);
									    	mailInfo.setFrom(s);
									    }
									
									    mailInfo.setTo(parser.getAttributeValue(7));
									    mailInfo.setCc(parser.getAttributeValue(8));
									    
									    attachmentFlag=Integer.parseInt(parser.getAttributeValue(9));
									    mailInfo.setFolder(parser.getAttributeValue(10));
									 // mailInfo.setHasAttachment(attachmentFlag==0?false:true,false);
									    mailInfo.setAttachmentFlag(attachmentFlag);
									    mailInfo.setAccountId(a.id);
									    NewDbHelper.getInstance().insertMailsToDb(mailInfo,a.id);
									    if(mailInfo.getState()==MailStatus.MAIL_NEW)
									    	mailCount++;
										
									}
								}
							}
							//--------------------START_TAG
							try {
								eventType=parser.next();
							} catch (Exception e) {
								e.printStackTrace();
							}
							
						}//end while
						Log.d(Utils.LOGTAG, "To updateMailGroupState");
						NewDbHelper.getInstance().updateMailGroupState();
						result.mailCount=mailCount;
						try
						{
							publishProgress(new Void[0]);
						}
						catch(Throwable t)
						{
							t.printStackTrace();
						}
						Log.d(Utils.LOGTAG, "Finish doReceiveOnce");
						return result;//strange, this line is not executed, but the latest return at end of this function is executed
						
						
					}//--------------------end try req
					catch (XmlPullParserException e)
					{
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					catch (Exception ex)
					{
						errorMsg = ex.getMessage();
						ex.printStackTrace();
						throw new Exception(errorMsg); // user stopped or other
														// error
					}
					finally
					{
						
					}
				}//--------------------end while(stopbyuser)
			}//--------------end try 
			catch (Exception ex)
			{// receive terminate abnormal, stopped by user or other condition
				if (!_mainWnd.stoppedByUser)
					errorMsg = ex.getMessage();
			}
			finally
			{
				agent.setReceiving(false);
				if (!_mainWnd.stoppedByUser)
				{
					if (req != null)
					{
						req.abort();
						req = null;
					}
				}
				try {
					if(onFinishCallBack!=null)
						onFinishCallBack.receiveFinished(status);
				}
				catch(Throwable t) 
				{
					t.printStackTrace();
				}
			}
			return result;
		}

		@Override
		protected void onPostExecute(Result result)
		{
			Log.d(Utils.LOGTAG, "onPostexecute");
			String accountMsg="";
			if(!beQuiet)
			{
				if(!receiveAll)
					accountMsg="账号"+accountName+"\r\n";
				Resources res = MyApp.instance().getResources();
				if (errorMsg != null && result == null)
					MessageBox.show(_mainWnd,accountMsg +errorMsg,
									res.getString(R.string.error));
//				prgDialog.hide();
				if (result != null && result.mailCount < 1)
					MessageBox.show(_mainWnd,
					                accountMsg+res.getString(R.string.noNewMail),
									res.getString(R.string.receiveMail));
			}
			this._mainWnd.setProgressBarVisible(false);
			((PullToRefreshListView)this._mainWnd.getExpandableListView()).onRefreshComplete(scrollViewToTop);
			// MailClient.this.totalMailCount += mailCount;
			// MailClient.this.setTitle(PRODUCT_NAME + "(" + mailCount + ")");
			Log.d(Utils.LOGTAG, "onPostexecute complete");
		}

		@Override
		protected void onPreExecute()
		{
			if (!ServerAgent.hasNetworkConnection() && !beQuiet)
			{
				this.cancel(true);
				this._mainWnd.setProgressBarVisible(false);
			    ((PullToRefreshListView) this._mainWnd.getExpandableListView()).onRefreshComplete(true);
			    Resources res = MyApp.getCurrentActivity().getResources();
				MessageBox.show(MyApp.getCurrentActivity(), res.getString(R.string.err_notConnected),
								res.getString(R.string.error));
			}
			else
			{
				this._mainWnd.setProgressBarVisible(true);
			}
		
		}

		@Override
		protected void onProgressUpdate(Void... values)
		{
			try 
			{
				_mainWnd.updateMail();
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}
	}package mobi.cloudymail.mailclient;

import mobi.cloudymail.util.Utils;
import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.ViewGroup;
import android.widget.Scroller;

/**
 * 浠Launcher涓WorkSapce锛浠ュ乏虫ㄥ㈠骞锟? * 
 * @author Yao.GUET blog: http://blog.csdn.net/Yao_GUET date: 2011-05-04
 */
public class ScrollLayout extends ViewGroup {

	private Scroller mScroller;
	private VelocityTracker mVelocityTracker;

	private int mCurScreen;
	private int mDefaultScreen = 0;

	private static final int TOUCH_STATE_REST = 0;
	private static final int TOUCH_STATE_SCROLLING = 1;

	private static final int SNAP_VELOCITY = 600;

	private int mTouchState = TOUCH_STATE_REST;
	private int mTouchSlop;
	private float mLastMotionX;
//	private float mLastMotionY;

	private PageListener pageListener;

	public ScrollLayout(Context context, AttributeSet attrs) {
		this(context, attrs, 0);
	}

	public ScrollLayout(Context context, AttributeSet attrs, int defStyle) {
		super(context, attrs, defStyle);
		mScroller = new Scroller(context);

		mCurScreen = mDefaultScreen;
		mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();
	}

	@Override
	protected void onLayout(boolean changed, int l, int t, int r, int b) {
		int childLeft = 0;
		final int childCount = getChildCount();

		for (int i = 0; i < childCount; i++) {
			final View childView = getChildAt(i);
			if (childView.getVisibility() != View.GONE) {
				final int childWidth = childView.getMeasuredWidth();
				childView.layout(childLeft, 0, childLeft + childWidth, childView.getMeasuredHeight());
				childLeft += childWidth;
			}
		}
	}

	@Override
	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		super.onMeasure(widthMeasureSpec, heightMeasureSpec);

		final int width = MeasureSpec.getSize(widthMeasureSpec);
		final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
		if (widthMode != MeasureSpec.EXACTLY) {
			throw new IllegalStateException("ScrollLayout only canmCurScreen run at EXACTLY mode!");
		}

		/**
		 * wrap_content 浼杩荤AT_MOST 哄帮拷?fill_parent 浼ョ妯″EXACTLY
		 */
		final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
		if (heightMode != MeasureSpec.EXACTLY) {
			throw new IllegalStateException("ScrollLayout only can run at EXACTLY mode!");
		}

		// The children are given the same width and height as the scrollLayout
		final int count = getChildCount();
		for (int i = 0; i < count; i++) {
			getChildAt(i).measure(widthMeasureSpec, heightMeasureSpec);
		
		}
		scrollTo(mCurScreen * width, 0);
		/**
		int count=getChildCount();
		Log.d(Utils.LOGTAG, "onMeasure start.....");
		for(int i=0;i<count;i++)
		{
			View child=getChildAt(i);
			LayoutParams lp=(LayoutParams)child.getLayoutParams();
			int cHeight = lp.height;
			int cWidth=lp.width;
			int cHeightSpec=MeasureSpec.makeMeasureSpec(cHeight,MeasureSpec.EXACTLY);
			int cWidthSpec=MeasureSpec.makeMeasureSpec(cWidth,MeasureSpec.EXACTLY);
			child.measure(cWidthSpec, cHeightSpec);
		}
		*/
	}

	/**
	 * According to the position of current layout scroll to the destination
	 * page.
	 */
	public void snapToDestination() {
		final int screenWidth = getWidth();
		final int destScreen = (getScrollX() + screenWidth / 2) / screenWidth;
		snapToScreen(destScreen);
	}

	public void snapToScreen(int whichScreen) {
		// get the valid layout page
		whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));
		if (getScrollX() != (whichScreen * getWidth())) {
			
			final int delta = whichScreen * getWidth() - getScrollX();
			mScroller.startScroll(getScrollX(), 0, delta, 0, Math.abs(delta) * 2);
			mCurScreen = whichScreen;
			if(mCurScreen>Configure.curentPage){
				Configure.curentPage = whichScreen;
				pageListener.page(Configure.curentPage);
			}else if(mCurScreen<Configure.curentPage){
				Configure.curentPage = whichScreen;
				pageListener.page(Configure.curentPage);
			}
			invalidate(); // Redraw the layout
		}
	}

	public void setToScreen(int whichScreen) {
		whichScreen = Math.max(0, Math.min(whichScreen, getChildCount() - 1));
		mCurScreen = whichScreen;
		scrollTo(whichScreen * getWidth(), 0);
	}

	/**
	 * 峰褰椤电
	 */
	public int getCurScreen() {
		return mCurScreen;
	}

	/**
	 * 褰婊ㄥ褰椤碉?	 */ 
	public int getPage() {
		return Configure.curentPage;
	}

	@Override
	public void computeScroll() {
		if (mScroller.computeScrollOffset()) {
			scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
			postInvalidate();
		}
	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {

		if (mVelocityTracker == null) {
			mVelocityTracker = VelocityTracker.obtain();
		}
		mVelocityTracker.addMovement(event);

		final int action = event.getAction();
		final float x = event.getX();
	//	final float y = event.getY();

		switch (action) {
		case MotionEvent.ACTION_DOWN:
			if (!mScroller.isFinished()) {
				mScroller.abortAnimation();
			}
			mLastMotionX = x;
			break;
		case MotionEvent.ACTION_MOVE:
			int deltaX = (int) (mLastMotionX - x);
			mLastMotionX = x;
			scrollBy(deltaX, 0);
			break;
		case MotionEvent.ACTION_UP:
			final VelocityTracker velocityTracker = mVelocityTracker;
			velocityTracker.computeCurrentVelocity(1000);
			int velocityX = (int) velocityTracker.getXVelocity();

			if (velocityX > SNAP_VELOCITY && mCurScreen > 0) {
				// Fling enough to move left
				snapToScreen(mCurScreen - 1);
				
			} else if (velocityX < -SNAP_VELOCITY && mCurScreen < getChildCount() - 1) {
				// Fling enough to move right
				snapToScreen(mCurScreen + 1);
			} else {
				snapToDestination();
			}
			if (mVelocityTracker != null) {
				mVelocityTracker.recycle();
				mVelocityTracker = null;
			}
			mTouchState = TOUCH_STATE_REST;
			break;
		case MotionEvent.ACTION_CANCEL:
			mTouchState = TOUCH_STATE_REST;
			break;
		}
		return true;
	}

	@Override
	public boolean onInterceptTouchEvent(MotionEvent ev) {
		if(Configure.isMove)	return false;//缁瀛т欢
		final int action = ev.getAction();
		if ((action == MotionEvent.ACTION_MOVE) && (mTouchState != TOUCH_STATE_REST)) {
			return true;
		}

		final float x = ev.getX();
	//	final float y = ev.getY();

		switch (action) {
		case MotionEvent.ACTION_MOVE:
			final int xDiff = (int) Math.abs(mLastMotionX - x);
			if (xDiff > mTouchSlop) {
				mTouchState = TOUCH_STATE_SCROLLING;
			}
			break;
		case MotionEvent.ACTION_DOWN:
			mLastMotionX = x;
	//	mLastMotionY = y;
			mTouchState = mScroller.isFinished() ? TOUCH_STATE_REST : TOUCH_STATE_SCROLLING;
			break;

		case MotionEvent.ACTION_CANCEL:
		case MotionEvent.ACTION_UP:
			mTouchState = TOUCH_STATE_REST;
			break;
		}
		return mTouchState != TOUCH_STATE_REST;
	}

	public void setPageListener(PageListener pageListener) {
		this.pageListener = pageListener;
	}

	public interface PageListener {
		void page(int page);
	}
}package mobi.cloudymail.mailclient;
import static mobi.cloudymail.util.Utils.LOGTAG;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import android.content.Context;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.Filter;
import android.widget.Filterable;
import android.widget.TextView;

public class SearchEmailBookAdapter<T> extends BaseAdapter implements
		Filterable

{

	private static final String tag = "SearchEmailBookAdapter";
	private List<T> mObjects;
	private final Object mLock = new Object();
	private int mResource;
	private int mDropDownResource;
	private int mFieldId = 0;
	private boolean mNotifyOnChange = true;
	private Context mContext;
	private ArrayList<T> mOriginalValues;
	private EmailBookArrayFilter mFilter;
	private LayoutInflater mInflater;

	public SearchEmailBookAdapter(Context context, int textViewResourceId)
	{
		init(context, textViewResourceId, 0, new ArrayList<T>());
	}



	public void add(T object)
	{
		if (mOriginalValues != null)
		{
			synchronized (mLock)
			{
				mOriginalValues.add(object);
				if (mNotifyOnChange)
					notifyDataSetChanged();
			}
		}
		else
		{
			mObjects.add(object);
			if (mNotifyOnChange)
				notifyDataSetChanged();
		}
	}

	public void addAll(Collection<? extends T> collection)
	{
		if (mOriginalValues != null)
		{
			synchronized (mLock)
			{
				mOriginalValues.addAll(collection);
				if (mNotifyOnChange)
					notifyDataSetChanged();
			}
		}
		else
		{
			mObjects.addAll(collection);
			if (mNotifyOnChange)
				notifyDataSetChanged();
		}
	}

	public void addAll(T... items)
	{
		if (mOriginalValues != null)
		{
			synchronized (mLock)
			{
				for (T item : items)
				{
					mOriginalValues.add(item);
				}
				if (mNotifyOnChange)
					notifyDataSetChanged();
			}
		}
		else
		{
			for (T item : items)
			{
				mObjects.add(item);
			}
			if (mNotifyOnChange)
				notifyDataSetChanged();
		}
	}

	public void insert(T object, int index)
	{
		if (mOriginalValues != null)
		{
			synchronized (mLock)
			{
				mOriginalValues.add(index, object);
				if (mNotifyOnChange)
					notifyDataSetChanged();
			}
		}
		else
		{
			mObjects.add(index, object);
			if (mNotifyOnChange)
				notifyDataSetChanged();
		}
	}

	public void remove(T object)
	{
		if (mOriginalValues != null)
		{
			synchronized (mLock)
			{
				mOriginalValues.remove(object);
			}
		}
		else
		{
			mObjects.remove(object);
		}
		if (mNotifyOnChange)
			notifyDataSetChanged();
	}

	public void clear()
	{
		if (mOriginalValues != null)
		{
			synchronized (mLock)
			{
				mOriginalValues.clear();
			}
		}
		else
		{
			mObjects.clear();
		}
		if (mNotifyOnChange)
			notifyDataSetChanged();
	}

	public void sort(Comparator<? super T> comparator)
	{
		Collections.sort(mObjects, comparator);
		if (mNotifyOnChange)
			notifyDataSetChanged();
	}

	@Override
	public void notifyDataSetChanged()
	{
		// TODO Auto-generated method stub
		super.notifyDataSetChanged();
		mNotifyOnChange = true;
	}

	public void setNotifyOnChange(boolean notifyOnChange)
	{
		mNotifyOnChange = notifyOnChange;
	}

	private void init(Context context, int resource, int textViewResourceId,
			List<T> objects)
	{
		mContext = context;
		mInflater = (LayoutInflater) context
				.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		mResource = mDropDownResource = resource;
		mObjects = objects;
		mFieldId = textViewResourceId;
		for (T t : objects)
		{
			Log.i(LOGTAG, ">>>>>>>>>>>>> t = " + t);
		}
	}

	public Context getContext()
	{
		return mContext;
	}

	@Override
	public int getCount()
	{
		return mObjects.size();
	}

	@Override
	public Object getItem(int position)
	{
		return mObjects.get(position);
	}

	public int getPosition(T item)
	{
		return mObjects.indexOf(item);
	}

	@Override
	public long getItemId(int position)
	{
		return position;
	}

	@Override
	public View getView(int position, View convertView, ViewGroup parent)
	{
		return createViewFromResource(position, convertView, parent, mResource);
	}

	private View createViewFromResource(int position, View convertView,
			ViewGroup parent, int resource)
	{
		View view;
		TextView text;
		if (convertView == null)
		{
			view = mInflater.inflate(resource, parent, false);
		}
		else
		{
			view = convertView;
		}
		try
		{
			if (mFieldId == 0)
			{
				// If no custom field is assigned, assume the whole resource is
				// a TextView
				text = (TextView) view;
			}
			else
			{
				// Otherwise, find the TextView field within the layout
				text = (TextView) view.findViewById(mFieldId);
			}
		}
		catch (ClassCastException e)
		{
			Log.e(LOGTAG,"SearchCityAdapter"+
					"You must supply a resource ID for a TextView");
			throw new IllegalStateException(
											"SearchCityAdapter requires the resource ID to be a TextView",
											e);
		}
		T item = (T) getItem(position);
		Log.i(LOGTAG, ">>>>>>>>>>>>>> position = " + position + " item = " + item);
		if (item instanceof CharSequence)
		{
			text.setText((CharSequence) item);
		}
		else
		{
			text.setText(item.toString());
		}
		return view;
	}

	public void setDropDownViewResource(int resource)
	{
		this.mDropDownResource = resource;
	}

	@Override
	public View getDropDownView(int position, View convertView, ViewGroup parent)
	{
		return createViewFromResource(	position, convertView, parent,
										mDropDownResource);
	}

	@Override
	public Filter getFilter()
	{
		if (mFilter == null)
		{
			mFilter = new EmailBookArrayFilter();
		}
		return mFilter;
	}

	private class EmailBookArrayFilter extends Filter
	{
		/**
		 * prefix:监听用户输入的字符
		 */
		@Override
		protected FilterResults performFiltering(CharSequence prefix)
		{
			Log.i(LOGTAG, "MailArrayFilter : performFiltering >>>>>>> prefix="
						+ prefix);
			FilterResults results = new FilterResults();
			// if (mOriginalValues == null)
			// {
			// synchronized (mLock)
			// {
			// mOriginalValues = new ArrayList<T>(mObjects);
			// }
			// }
			// if (prefix == null || prefix.length() == 0)
			// {
			// synchronized (mLock)
			// {
			// ArrayList<T> list = new ArrayList<T>(mOriginalValues);
			// results.values = list;
			// results.count = list.size();
			// }
			// }
			// else
			// {


			final ArrayList<T> newValues = new ArrayList<T>();
			if (prefix != null)
			{
				
				
				String prefixString = prefix.toString().toLowerCase();
				ArrayList<EmailAddress> addArry = AddressBook
						.getEmailAddresses();

				String[] array = new String[addArry.size()];
				for (int i = 0; i < addArry.size(); i++)
				{
					array[i] = addArry.get(i).toString();
					String[] split = array[i].split("<");
					if ((split[0]).contains(prefixString)||(split[1]).contains(prefixString))
					{
						newValues.add((T) array[i]);
                       
					}
					else if ((array[i]).startsWith(prefixString))
					{
						newValues.add((T) array[i]);
					}

				}
				// }
				// String key;
				// String[] keyPart;
				//
				// while(enumeration.hasMoreElements()) {
				// key = (String)enumeration.nextElement();
				// keyPart = key.split("-");
				// Log.i(tag,
				// ">>>>>>>>>>>>>>>>>>> prefixString = "+prefixString+" key = "+key);
				// if(prefixString.length() == 1 &&
				// keyPart[1].startsWith(prefixString)) {
				// newValues.add((T)Composer.ht.get(key));
				// } else if (prefixString.length() == 2) {
				// if(keyPart[2].equals(prefixString)) {
				// newValues.add((T)Composer.ht.get(key));
				// }
				// if(newValues.size() == 0 &&
				// keyPart[1].startsWith(prefixString)) {
				// newValues.add((T)Composer.ht.get(key));
				// }
				// } else if (prefixString.length() == 3) {
				// if(keyPart[0].equals(prefixString)) {
				// newValues.add((T)Composer.ht.get(key));
				// }
				// if(newValues.size() == 0 &&
				// keyPart[1].startsWith(prefixString)) {
				// newValues.add((T)Composer.ht.get(key));
				// }
				// }
				// }
				// for (int i = 0; i < count; i++) {
				// final T value = values.get(i);
				// final String valueText = value.toString().toLowerCase();
				// // First match against the whole, non-splitted value
				// if (valueText.startsWith(prefixString)) {
				// newValues.add(value);
				// }else {
				// final String[] words = valueText.split(" ");
				// final int wordCount = words.length;
				// for (int k = 0; k < wordCount; k++) {
				// if (words[k].startsWith(prefixString)) {
				// newValues.add(value);
				// break;
				// }
				// }
				// }
				// }
			}
			results.values = newValues;
			results.count = newValues.size();
			return results;
		}

		@Override
		protected void publishResults(CharSequence constraint,
				FilterResults results)
		{
			Log.i(	LOGTAG,
					"CityArrayFilter : publishResults >>>>>>>>>>> results.values = "
							+ results.values);
			mObjects = (List<T>) results.values;
			if (results.count > 0)
			{
				notifyDataSetChanged();
			}
			else
			{
				notifyDataSetInvalidated();
			}
		}

	}
}
package mobi.cloudymail.mailclient;

import android.content.SearchRecentSuggestionsProvider;

public class SearchSuggestionSampleProvider extends
		SearchRecentSuggestionsProvider {

	final static String AUTHORITY="mobi.cloudymail.mailclient.SearchSuggestionSampleProvider";
	final static int MODE=DATABASE_MODE_QUERIES;
	
	public SearchSuggestionSampleProvider(){
		super();
		setupSuggestions(AUTHORITY, MODE);
	}
}
package mobi.cloudymail.mailclient;

//public class RfcTokenizer implements MultiAutoCompleteTextView.Tokenizer
//{
//	
//}
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import java.util.ArrayList;
import java.util.Collection;

import android.text.util.Rfc822Token;
import android.widget.MultiAutoCompleteTextView;

/**
 * This class works as a Tokenizer for MultiAutoCompleteTextView for
 * address list fields, and also provides a method for converting
 * a string of addresses (such as might be typed into such a field)
 * into a series of Rfc822Tokens.
 */
public class SemicolonTokenizer implements 
        MultiAutoCompleteTextView.Tokenizer {

    /**
     * This constructor will try to take a string like
     * "Foo Bar (something) &lt;foo\@google.com&gt;,
     * blah\@google.com (something)"
     * and convert it into one or more Rfc822Tokens, output into the supplied
     * collection.
     *
     * It does *not* decode MIME encoded-words; charset conversion
     * must already have taken place if necessary.
     * It will try to be tolerant of broken syntax instead of
     * returning an error.
     *
     * @hide
     */
    public static void tokenize(CharSequence text,
            Collection<Rfc822Token> out) {
        StringBuilder name = new StringBuilder();
        StringBuilder address = new StringBuilder();
        StringBuilder comment = new StringBuilder();

        int i = 0;
        int cursor = text.length();

        while (i < cursor) {
            char c = text.charAt(i);

//            if (c == ',' || c == ';') {
            	if (c == ';') {
            
                i++;

                while (i < cursor && text.charAt(i) == ' ') {
                    i++;
                }

                crunch(name);

                if (address.length() > 0) {
                    out.add(new Rfc822Token(name.toString(), address
                            .toString(), comment.toString()));
                } else if (name.length() > 0) {
                    out.add(new Rfc822Token(null, name.toString(),
                            comment.toString()));
                }

                name.setLength(0);
                address.setLength(0);
                address.setLength(0);
            } else if (c == '"') {
                i++;

                while (i < cursor) {
                    c = text.charAt(i);

                    if (c == '"') {
                        i++;
                        break;
                    } else if (c == '\\') {
                        name.append(text.charAt(i + 1));
                        i += 2;
                    } else {
                        name.append(c);
                        i++;
                    }
                }
            } else if (c == '(') {
                int level = 1;
                i++;

                while (i < cursor && level > 0) {
                    c = text.charAt(i);

                    if (c == ')') {
                        if (level > 1) {
                            comment.append(c);
                        }

                        level--;
                        i++;
                    } else if (c == '(') {
                        comment.append(c);
                        level++;
                        i++;
                    } else if (c == '\\') {
                        comment.append(text.charAt(i + 1));
                        i += 2;
                    } else {
                        comment.append(c);
                        i++;
                    }
                }
            } else if (c == '<') {
                i++;

                while (i < cursor) {
                    c = text.charAt(i);

                    if (c == '>') {
                        i++;
                        break;
                    } else {
                        address.append(c);
                        i++;
                    }
                }
            } else if (c == ' ') {
                name.append('\0');
                i++;
            } else {
                name.append(c);
                i++;
            }
        }

        crunch(name);

        if (address.length() > 0) {
            out.add(new Rfc822Token(name.toString(),
                    address.toString(), comment.toString()));
        } else if (name.length() > 0) {
            out.add(new Rfc822Token(null, name.toString(), comment
                    .toString()));
        }
    }

    /**
     * This method will try to take a string like
     * "Foo Bar (something) &lt;foo\@google.com&gt;,
     * blah\@google.com (something)"
     * and convert it into one or more Rfc822Tokens.
     * It does *not* decode MIME encoded-words; charset conversion
     * must already have taken place if necessary.
     * It will try to be tolerant of broken syntax instead of
     * returning an error.
     */
    public static Rfc822Token[] tokenize(CharSequence text) {
        ArrayList<Rfc822Token> out = new ArrayList<Rfc822Token>();
        tokenize(text, out);
        return out.toArray(new Rfc822Token[out.size()]);
    }

    private static void crunch(StringBuilder sb) {
        int i = 0;
        int len = sb.length();

        while (i < len) {
            char c = sb.charAt(i);

            if (c == '\0') {
                if (i == 0 || i == len - 1 || sb.charAt(i - 1) == ' '
                        || sb.charAt(i - 1) == '\0'
                        || sb.charAt(i + 1) == ' '
                        || sb.charAt(i + 1) == '\0') {
                    sb.deleteCharAt(i);
                    len--;
                } else {
                    i++;
                }
            } else {
                i++;
            }
        }

        for (i = 0; i < len; i++) {
            if (sb.charAt(i) == '\0') {
                sb.setCharAt(i, ' ');
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    public int findTokenStart(CharSequence text, int cursor) {
        /*
         * It's hard to search backward, so search forward until
         * we reach the cursor.
         */

        int best = 0;
        int i = 0;

        while (i < cursor) {
            i = findTokenEnd(text, i);

            if (i < cursor) {
                i++; // Skip terminating punctuation

                while (i < cursor && text.charAt(i) == ' ') {
                    i++;
                }

                if (i < cursor) {
                    best = i;
                }
            }
        }

        return best;
    }

    /**
     * {@inheritDoc}
     */
    public int findTokenEnd(CharSequence text, int cursor) {
        int len = text.length();
        int i = cursor;

        while (i < len) {
            char c = text.charAt(i);

//            if (c == ',' || c == ';') {
        	if (c == ';') {
                return i;
            } else if (c == '"') {
                i++;

                while (i < len) {
                    c = text.charAt(i);

                    if (c == '"') {
                        i++;
                        break;
                    } else if (c == '\\') {
                        i += 2;
                    } else {
                        i++;
                    }
                }
            } else if (c == '(') {
                int level = 1;
                i++;

                while (i < len && level > 0) {
                    c = text.charAt(i);

                    if (c == ')') {
                        level--;
                        i++;
                    } else if (c == '(') {
                        level++;
                        i++;
                    } else if (c == '\\') {
                        i += 2;
                    } else {
                        i++;
                    }
                }
            } else if (c == '<') {
                i++;

                while (i < len) {
                    c = text.charAt(i);

                    if (c == '>') {
                        i++;
                        break;
                    } else {
                        i++;
                    }
                }
            } else {
                i++;
            }
        }

        return i;
    }

    /**
     * Terminates the specified address with a comma and space.
     * This assumes that the specified text already has valid syntax.
     * The Adapter subclass's convertToString() method must make that
     * guarantee.
     */
    public CharSequence terminateToken(CharSequence text) {
        return text + "; ";
    }
}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.media.Ringtone;
import android.media.RingtoneManager;
import android.net.Uri;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.Preference.OnPreferenceClickListener;
import android.preference.PreferenceActivity;
import android.preference.RingtonePreference;
import android.util.Log;


public class SettingPage extends PreferenceActivity implements
		OnPreferenceChangeListener
{
	private String _signature_content = null;
	// private String _multiPageKey = null;
	private String _mailCountKey = null;
	private String _characterSignatureKey = null;
	private String _syncFreqKey = null;
	private String _syncLedKey = null;
	private String _syncShakeKey = null;
	private String _ringtoneKey = null;
	private String _serverAddressKey = null;
	private String _signature_textKey = null;
	private String _clear_historyKey = null;
	private String _clear_passwordKey = null;
	private String _clear_cacheKey = null;
	private String _key_mute_time = null;
    
//	CheckBoxPreference _multiPagePref;
	ListPreference _mailCountPref;
	EditTextPreference _signaturePref;
	EditTextPreference _serverAddressPref;

	// public static String _serverAddText=null;

	ListPreference _syncFreqPref;
	CheckBoxPreference _syncLedPref;
	CheckBoxPreference _syncShakePref;
	RingtonePreference _ringtonePref;
	Preference _clearhistoryPref;
	private CharSequence summaryHostoryId = null;
	private CharSequence summaryPossowordId = null;
	private CharSequence summaryCacheId = null;
	Preference _clearPassword;
	Preference _clearCache;
	private String newSignature;
	Preference _mutetimePref;
	
	@Override
	public void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		this.getPreferenceManager()
				.setSharedPreferencesName(MyApp.SHARED_SETTING);
		// 所的的值将会自动保存到SharePreferences
		addPreferencesFromResource(R.xml.setting);

		Resources res = getResources();
		summaryHostoryId = res.getString(R.string.click_clear_hostoryId);
		summaryPossowordId = res.getString(R.string.click_clear_posswordId);
		summaryCacheId = res.getString(R.string.click_clear_cacheId);
		_mailCountKey = res.getString(R.string.key_mail_number);
		_syncFreqKey = res.getString(R.string.key_sync_frequency);
		_syncLedKey = res.getString(R.string.key_new_mail_led);
		_syncShakeKey = res.getString(R.string.key_new_mail_vibrate);
		_ringtoneKey = res.getString(R.string.key_new_mail_ringtone);
		_clear_historyKey = res.getString(R.string.key_clear_history);
		_clear_passwordKey = res.getString(R.string.key_clear_password);
		_clear_cacheKey = res.getString(R.string.key_clear_cache);

		_mailCountPref = (ListPreference) findPreference(_mailCountKey);
		_mailCountPref.setOnPreferenceChangeListener(this);
		_mailCountPref.setSummary(_mailCountPref.getEntry());

		_characterSignatureKey = res.getString(R.string.key_mail_signature);
		_signaturePref = (EditTextPreference) findPreference(_characterSignatureKey);
		_signaturePref.setOnPreferenceChangeListener(this);
		_signature_textKey = MyApp.userSetting.getSignature();
		_signaturePref.setText(_signature_textKey);

		_key_mute_time=res.getString(R.string.key_mute_time);
		_mutetimePref=findPreference(_key_mute_time);
		_mutetimePref.setOnPreferenceChangeListener(this);
		
		_serverAddressKey = res.getString(R.string.key_server_address);
		_serverAddressPref = (EditTextPreference) findPreference(_serverAddressKey);
		if(_serverAddressPref != null)
		{//we have no server address preference in release build
			_serverAddressPref.setOnPreferenceChangeListener(this);
		}
		_clearPassword = findPreference(_clear_passwordKey);
		_clearCache = findPreference(_clear_cacheKey);

		_clearPassword.setSummary(summaryPossowordId);
		_clearCache.setSummary(summaryCacheId);

		_clearPassword
				.setOnPreferenceClickListener(new OnPreferenceClickListener() {

					@Override
					public boolean onPreferenceClick(Preference preference)
					{
						Builder dialog = new AlertDialog.Builder(
																	SettingPage.this)
								.setTitle(R.string.string_clear_password_title)
								.setMessage(R.string.stirng_confirm_clear_password)
								.setPositiveButton(	R.string.stirng_confirm_clear,
													new DialogInterface.OnClickListener() {

														@Override
														public void onClick(
																DialogInterface dialog,
																int which)
														{
															NewDbHelper
																	.getInstance()
																	.execSQL(	"update account set password=null",
																				new Object[] {});
														}
													})
								.setNegativeButton(	R.string.stirng_cancel_clear,
													new DialogInterface.OnClickListener() {

														@Override
														public void onClick(
																DialogInterface dialog,
																int which)
														{
															// TODO
															// Auto-generated
															// method stub
															return;
														}
													});
						dialog.show();
						return false;
					}

				});
		_clearCache
				.setOnPreferenceClickListener(new OnPreferenceClickListener() {

					@Override
					public boolean onPreferenceClick(Preference preference)
					{
						Builder dialog = new AlertDialog.Builder(
																	SettingPage.this)
								.setTitle(R.string.string_clear_cache_title)
								.setMessage(R.string.string_confirm_clear_cache)
								.setPositiveButton(	R.string.stirng_confirm_clear,
													new DialogInterface.OnClickListener() {

														@Override
														public void onClick(
																DialogInterface dialog,
																int which)
														{
															// NewDbHelper.getInstance()
															// .query("update mail set body=null;",
															// null);
															NewDbHelper
																	.getInstance()
																	.execSQL(	"update mail set body=null",
																				new Object[] {});
														}
													})
								.setNegativeButton(	R.string.stirng_cancel_clear,
													new DialogInterface.OnClickListener() {

														@Override
														public void onClick(
																DialogInterface dialog,
																int which)
														{
															// TODO
															// Auto-generated
															// method stub
															return;
														}
													});
						dialog.show();
						// NewDbHelper.getInstance().updateMailBody(inMailInfo);
						// NewDbHelper.getInstance()
						// .query("update mail set body=null;", null);
						return false;
					}
				});

		/*
		 * private void clearSearchHistory() { SearchRecentSuggestions
		 * suggestions =new SearchRecentSuggestions(this,
		 * SearchSuggestionSampleProvider.AUTHORITY,
		 * SearchSuggestionSampleProvider.MODE); suggestions.clearHistory(); }
		 */
		_clearhistoryPref = findPreference(_clear_historyKey);
		// _mailCountPref.setSummary(_mailCountPref.getEntry());
		_clearhistoryPref.setSummary(summaryHostoryId);
		_clearhistoryPref
				.setOnPreferenceClickListener(new OnPreferenceClickListener() {

					@Override
					public boolean onPreferenceClick(Preference preference)
					{
						MailFolderActivity.clearSearchHistory();
						return false;
					}
				});

		// try
		// {
		// InetAddress addr = InetAddress.getLocalHost();
		// _serverAddress=addr.getHostAddress().toString();
		// }
		// catch (UnknownHostException e)
		// {
		// e.printStackTrace();
		// }

		String countPerReception = _mailCountPref.getValue();
		if (countPerReception == null)// first time
		{
			_mailCountPref.setValue(MyApp.userSetting.countPerReception + "");
//			_multiPagePref.setChecked(MyApp.userSetting.showMultipage);
		}
		else
		{
			MyApp.userSetting.countPerReception = Integer
					.parseInt(countPerReception);
//			MyApp.userSetting.showMultipage = _multiPagePref.isChecked();
		}
		_mailCountPref.setSummary(_mailCountPref.getEntry());

		_syncFreqPref = (ListPreference) findPreference(_syncFreqKey);
		_syncLedPref = (CheckBoxPreference) findPreference(_syncLedKey);
		_syncShakePref = (CheckBoxPreference) findPreference(_syncShakeKey);
		_ringtonePref = (RingtonePreference) findPreference(_ringtoneKey);

		_syncFreqPref.setOnPreferenceChangeListener(this);
		_syncLedPref.setOnPreferenceChangeListener(this);
		_syncShakePref.setOnPreferenceChangeListener(this);
		_syncFreqPref.setSummary(_syncFreqPref.getEntry());
		_ringtonePref.setOnPreferenceChangeListener(this);

		
		String synFreq = _syncFreqPref.getValue();
		if (synFreq == null)// first time
		{
			_syncFreqPref.setValue(MyApp.userSetting.getPushFrequency() + "");
			_syncLedPref.setChecked(MyApp.userSetting._ledFlag);
			_syncShakePref.setChecked(MyApp.userSetting._vibrateFlag);
			// _ringtonePref.setDefaultValue(defaultValue)
//			if(MyApp.userSetting.getSignature().toString()!=""&&MyApp.userSetting.getSignature()!=null)
//			{
//				_signaturePref.setText(MyApp.userSetting.getSignature());	
//			}
			
			
		}
		else
		{
			int synFreqValue = Integer.parseInt(synFreq);
			MyApp.userSetting.setPushFrequency(synFreqValue);
			MyApp.userSetting._ledFlag = _syncLedPref.isChecked();
			MyApp.userSetting._vibrateFlag = _syncShakePref.isChecked();
			updateLedShakeEnableStatus(synFreqValue);
		}

		_syncFreqPref.setSummary(_syncFreqPref.getEntry());
		//_ringtonePref.setSummary(MyApp.userSetting._ringtone);
		updateRingtoneSummary(_ringtonePref, Uri.parse(MyApp.userSetting._ringtone));

		// Log.d("multiplage mail",
		// MailClient.userSetting.showMultipage?"true":"false");
		// Log.d("mail count per reception", countPerReception);
	}

	// since when onPreferenceChanged invoked, the returned entry is the
	// previous changed value.
	String getCurrentEntry(ListPreference preference, String newValue)
	{
		CharSequence[] entries = preference.getEntries();
		CharSequence[] entryValues = preference.getEntryValues();
		for (int i = 0; i < entryValues.length; i++)
		{
			if (newValue.equals((String) entryValues[i]))
				return (String) entries[i];
		}
		return "";
	}
	
	@Override
	public boolean onPreferenceChange(Preference preference, Object newValue)
	{
		// TODO Auto-generated method stub
		Log.d(LOGTAG, "SystemSetting" + "preference is changed");
		// Log.d("Key_SystemSetting", preference.getKey());
		// 判断是哪个Preference改变了
		String keyName = preference.getKey();
		if (keyName.equals(_mailCountKey))
		{
			String countPerReception = newValue.toString();// ((ListPreference)preference).getValue();
			MyApp.userSetting.countPerReception = Integer
					.parseInt(countPerReception);
			_mailCountPref
					.setSummary(getCurrentEntry((ListPreference) preference,
												countPerReception));
			Log.d(LOGTAG, "mail count per reception" + countPerReception);
		}
		else if (preference.getKey().equals(_characterSignatureKey))
		{
		    newSignature = newValue.toString();
			MyApp.userSetting.setSignatrue(newSignature);
//			_signaturePref.setText(newSignature);
			
			/*_signaturePref.setText(_signature_textKey);*/
			Log.d(LOGTAG, "Character signature" + newSignature);
//			return false;
		}
		else if (preference.getKey().equals(_serverAddressKey))
		{
			String newServerAdd = newValue.toString();
			// _serverAddText=newServerAdd;
			// _serverAddressPref.setText(_serverAddText);
			MyApp.userSetting._serverAddText = newServerAdd;
			Log.d(LOGTAG, "serverAddress" + newServerAdd);
		}
		else if (keyName.equals(_syncFreqKey))
		{
			int synFreqValue = Integer.parseInt(newValue.toString());
			MyApp.userSetting.setPushFrequency(synFreqValue);
			_syncFreqPref
					.setSummary(getCurrentEntry((ListPreference) preference,
												newValue.toString()));
			// _syncFreqPref.setSummary(((ListPreference)
			// preference).getEntry());
		
			//stopService(MailFolderActivity._pushIntent);
			updateLedShakeEnableStatus(synFreqValue);
			MyApp.instance().setPollInterval(synFreqValue);
			Log.d(LOGTAG, "synchronous frequency" + synFreqValue + " minutes");
		}
		else if (keyName.equals(_syncLedKey))
		{
			boolean showLed = ((Boolean) newValue).booleanValue();
			MyApp.userSetting._ledFlag = showLed;
			Log.d(LOGTAG, "flick led" + (showLed ? "true" : "false"));
		}
		else if (keyName.equals(_syncShakeKey))
		{
			boolean shake = ((Boolean) newValue).booleanValue();
			MyApp.userSetting._vibrateFlag = shake;
			Log.d(LOGTAG, "shake phone" + (shake ? "true" : "false"));
		}
		else if (keyName.equals(_ringtoneKey))
		{
			String ringtone = newValue.toString();
			MyApp.userSetting._ringtone = ringtone;
			updateRingtoneSummary((RingtonePreference) preference, Uri.parse((String) newValue));
		}
		else if (keyName.equals(_key_mute_time))
		{
			String storeString = TimePickerPreference.storeString;
			MyApp.userSetting.muteTimeValue=storeString;
			_mutetimePref.setSummary(storeString);
		}
		
		else
		{
			return false;
		}
		return true;
	}

	

	private void updateLedShakeEnableStatus(int syncFreq)
	{
		boolean value = (syncFreq >= 0);
		_syncLedPref.setEnabled(value);
		_syncShakePref.setEnabled(value);
		_ringtonePref.setEnabled(value);
	}
	
	private void updateRingtoneSummary(RingtonePreference preference, Uri ringtoneUri){
	    Ringtone ringtone = RingtoneManager.getRingtone(this, ringtoneUri);
	    if (ringtone != null)
	        preference.setSummary(ringtone.getTitle(this));
	    else
	        preference.setSummary(R.string.silent);
	}
	
}
package mobi.cloudymail.mailclient;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.ImageView;

public class SplashActivity extends Activity {
   private Handler mHandler=new Handler();
   private ImageView startLogo;
   int alpha=255;
   int b=0;


	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
				WindowManager.LayoutParams.FLAG_FULLSCREEN);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.splash);
		startLogo = (ImageView) findViewById(R.id.startLogo);
		startLogo.setAlpha(alpha);

		new Thread(new Runnable() {

			@Override
			public void run() {
				while (b < 2) {
					try {
						if (b == 0) {
							Thread.sleep(200);
							b = 1;
						} else {
							Thread.sleep(35);
						}
						updateApp();
					} catch (Exception e) {
						e.printStackTrace();
					}
				}

			}

		}).start();

		mHandler = new Handler() {
			public void handleMessage(Message msg) {
				super.handleMessage(msg);
				startLogo.setAlpha(alpha);
				startLogo.invalidate();
			}
		};
	}

	private void updateApp() {
		alpha -= 50;
		if (alpha <= 0) {
			b = 2;
			Intent in = new Intent(this, GlobalInBoxActivity.class);
			startActivity(in);
			SplashActivity.this.finish();
		}
//		mHandler.sendMessage(mHandler.obtainMessage());
	}
}
package mobi.cloudymail.mailclient;
import static mobi.cloudymail.util.Utils.LOGTAG;
import mobi.cloudymail.util.MyApp;
import android.app.TimePickerDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnDismissListener;
import android.preference.Preference;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.TextView;
import android.widget.TimePicker;

public class TimePickerPreference extends Preference 
{
	private Context context=this.getContext();
    private TimePickerDialog startTimePickerDialog=null;
    private TimePickerDialog endTimePickerDialog=null;
    private CheckBox interruptCheBox;
    private int startHour;
    private int startMinute;
    private int endHour;
    private int endMinute;
    private String interruptTime;
	private boolean muteEnabled;
    public static int INTERRUPT_TIME_SLOT;
    public static int START_INTERRUPT_TIME;
    public static boolean IS_MUTE_FLAG=false;
    public static  String storeString=null;
    public static boolean checkBoxStatue;
	private OnCheckedChangeListener checkBoxListener;
	private OnClickListener startTimeBtnOnClickListener;
	private OnClickListener endTimeSetBtnOnClickListener;
	private OnDismissListener startTimeDismissListener;
	private OnDismissListener endTimeDismissListenere;
	private OnClickListener viewOnClickListener;
	private View view;
	private CharSequence summary; 
    
	public TimePickerPreference(Context context, AttributeSet attrs)
	{
		super(context, attrs);
		setPersistent(true);
		initTimePickerDialog();
	}
	@Override
    protected void onBindView(View view) {
        super.onBindView(view);
        this.view = view;
//      view.inflate(context, R.layout.custom_timepicker_preference, null);
        interruptCheBox=(CheckBox) view.findViewById(R.id.timePickerCheckBox);
        interruptTime="6:00-7:00-false";
        interruptTime=MyApp.userSetting.getMuteTimeValue();
		String[] timeValue = interruptTime.split("-");
		
		String[] startTime = timeValue[0].split(":");
		startHour = Integer.parseInt(startTime[0]);
		startMinute = Integer.parseInt(startTime[1]);
		
		String[] endTime = timeValue[1].split(":");
		endHour = Integer.parseInt(endTime[0]);
		endMinute =Integer.parseInt(endTime[1]);
		
		muteEnabled = Boolean.parseBoolean(timeValue[2]);
//		setSummary(interruptTime);
	}
	
	
    /**
     * Init timePickerDialog
     */
	private void initTimePickerDialog()
	{
		
		    TimePickerDialog.OnTimeSetListener startOnTimeSetList=new TimePickerDialog.OnTimeSetListener(){  
	            public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
	            	startHour=hourOfDay;
	            	startMinute=minute;
	            }   
	        };  
	        
	        TimePickerDialog.OnTimeSetListener endOnTimeSetList=new TimePickerDialog.OnTimeSetListener(){  
	        	public void onTimeSet(TimePicker view, int hourOfDay, int minute) {
	        		endHour=hourOfDay;
	        		endMinute=minute;
	        	}   
	        };  
	        
	        startTimePickerDialog=new TimePickerDialog(context, startOnTimeSetList, startHour, startMinute, true);
            endTimePickerDialog=new TimePickerDialog(context,endOnTimeSetList,endHour,endMinute,true);
	}
	/* (non-Javadoc)
	 * @see mobi.cloudymail.mailclient.startTimeSetListener#getView(android.view.View, android.view.ViewGroup)
	 */
	@Override
	public View  getView(View convertView, ViewGroup parent)
	{
		View v = super.getView(convertView, parent);
		if(v == convertView)
			return v;
		TextView startMuteText=(TextView) v.findViewById(R.id.muteStartText);
		String startTempString=String.valueOf(startMinute);
		String endTempString=String.valueOf(endMinute);
		if(startTempString.length()==1)
		{
			startMuteText.setText(startHour+":"+"0"+startMinute);
		}
		else
		{
			startMuteText.setText(startHour+":"+startMinute);	
		}
		
		TextView endMuteText=(TextView) v.findViewById(R.id.muteEndText);
		if(endTempString.length()==1)
		{
			endMuteText.setText(endHour+":"+"0"+endMinute);
		}
		else
		{
			endMuteText.setText(endHour+":"+endMinute);
		}
		
	    interruptCheBox = (CheckBox) v.findViewById(R.id.timePickerCheckBox);
	    if(muteEnabled)
		{
			interruptCheBox.setChecked(true);
		}
		else
		{
			interruptCheBox.setChecked(false);
		}
	    /**
	     * view listener
	     */
	    
	    if(viewOnClickListener==null)
	    viewOnClickListener=new OnClickListener(){

			@Override
			public void onClick(View v)
			{
				muteEnabled=!muteEnabled;
				interruptCheBox.setChecked(muteEnabled);
			}};
	    v.setOnClickListener(viewOnClickListener);
	    
	    /**
	     * muteCheckBox listener
	     */
		if(checkBoxListener == null)
			checkBoxListener = new OnCheckedChangeListener()
			{
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked)
				{
					// Set muteEnabled
					muteEnabled = interruptCheBox.isChecked();
					MyApp.userSetting.muteEnabled = muteEnabled;
					storeString = startHour + ":" + startMinute + "-" + endHour + ":" + endMinute + "-" + muteEnabled;
					MyApp.userSetting.setMuteTimeValue(storeString);
					persistString(storeString);
					callChangeListener(storeString);
				}
				
			};
		interruptCheBox.setOnCheckedChangeListener(checkBoxListener);
	    /**
	     * startTimeBtn listerer
	     */
	    Button startTimeSetBtn=(Button) v.findViewById(R.id.startTimePickerBtn);
	    if(startTimeBtnOnClickListener==null)
	    startTimeBtnOnClickListener=new View.OnClickListener() {
			
			@Override
			public void onClick(View v)
			{
                startTimePickerDialog.updateTime(startHour, startMinute);
                startTimePickerDialog.show();
               
			}
		};
	    startTimeSetBtn.setOnClickListener(startTimeBtnOnClickListener);
	    
	    /**
	     * endTimeBtn listener
	     */
	    Button endTimeSetBtn=(Button) v.findViewById(R.id.endTimePickerBtn);
	    
	    if(endTimeSetBtnOnClickListener==null)
	    endTimeSetBtnOnClickListener=new View.OnClickListener() {
	    	@Override
	    	public void onClick(View v)
	    	{
	    		endTimePickerDialog.updateTime(endHour, endMinute);
	    		endTimePickerDialog.show();
	    	
	    	}
	    };
	    endTimeSetBtn.setOnClickListener(endTimeSetBtnOnClickListener);
	    /**
	     *  startDismiss listener
	     */
	    if(startTimeDismissListener==null)
	    startTimeDismissListener=new OnDismissListener() {
		@Override
		public void onDismiss(DialogInterface dialog)
		{
	        startTimePickerDialog.onSaveInstanceState();
	        endTimePickerDialog.onSaveInstanceState();
	        //Preference values  save time
	        storeString = startHour+":"+startMinute+"-"+endHour+":"+endMinute+"-"+muteEnabled;
			
			persistString(storeString);
			callChangeListener(storeString);
			
		}
	    };
	  
	  startTimePickerDialog.setOnDismissListener(startTimeDismissListener);
	  
	  /**
	   * endDismiss listener
	   */
	  if(endTimeDismissListenere==null)
	  endTimeDismissListenere=new OnDismissListener() {
		@Override
		public void onDismiss(DialogInterface dialog)
		{
			storeString = startHour+":"+startMinute+"-"+endHour+":"+endMinute+"-"+muteEnabled;
			persistString(storeString);
			callChangeListener(storeString);
			
		}
	  };	    
    	endTimePickerDialog.setOnDismissListener(endTimeDismissListenere);    
	    return v;
  }
	@Override
	public void  setSummary(CharSequence summary)
	{
        if (summary == null && this.summary != null || summary != null && !summary.equals(this.summary)) {
        	this.summary  = summary;
    		super.setSummary(null);
    		notifyChanged();
        }
	}


}
  
package mobi.cloudymail.mailclient;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ImageButton;

public class TranslucentButton extends Activity {
	int m_nSreenHeight = 0;
	ImageButton m_menu1;
	private String refMailBody = null;

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.translucent_button);
        
        Intent intent = getIntent();
        m_menu1 = (ImageButton)findViewById(R.id.last);
        boolean enableFlag = intent.getBooleanExtra(MailViewer.PREVIOUS_MAIL, true);
  //      m_menu1.setEnabled(enableFlag);
  //     m_menu1.setClickable(enableFlag);
        m_menu1.setVisibility(enableFlag?View.VISIBLE:View.GONE);
        ImageButton menu2 = (ImageButton)findViewById(R.id.replyMail);
        ImageButton menu3 = (ImageButton)findViewById(R.id.dseleteMail);
        enableFlag = intent.getBooleanExtra(MailViewer.DEL_MAIL, true);
  //      menu3.setEnabled(enableFlag);
  //      menu3.setClickable(enableFlag);
        menu3.setVisibility(enableFlag?View.VISIBLE:View.GONE);
       ImageButton menu4 = (ImageButton)findViewById(R.id.next);
       enableFlag = intent.getBooleanExtra(MailViewer.NEXT_MAIL, true);
  //     menu4.setEnabled(enableFlag);
  //     menu4.setClickable(enableFlag);
        menu4.setVisibility(enableFlag?View.VISIBLE:View.GONE);
        
        m_menu1.setOnClickListener(lastClickListener);
        menu2.setOnClickListener(replyMailClickListener);
        menu3.setOnClickListener(delMailClickListener);
        menu4.setOnClickListener(nextClickListener);
        
        DisplayMetrics dm = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(dm);
        m_nSreenHeight = dm.heightPixels;
        
    }
    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
    	if (keyCode == KeyEvent.KEYCODE_MENU) {
    		this.finish();
    	}
    	return super.onKeyUp(keyCode, event);
    }
    @Override
    public boolean onTouchEvent(MotionEvent event) {
    	if (event.getX() < m_nSreenHeight - m_menu1.getHeight()) {
    		finish();
    	}
        return false;
    }
 /*   public void openComposer(int type)
	{
		Intent intent = new Intent(this,Composer.class);
		intent.putExtra("composer_type", type);
		if(type == Composer.COMPOSER_REPLYALL)
			intent.putExtra("ccList", MyApp.curMailInfo.getCc());
		//_htmlView.loadUrl("javascript:window.cmail.setMailBody(mailBody.innerHTML);");
		intent.putExtra("refMailBody", refMailBody);
		startActivity(intent);
	}*/
    private OnClickListener lastClickListener = new OnClickListener() {
    	public void onClick(View v) {
    		setResult(R.id.last);
    		finish();
    	}
    };
    private OnClickListener replyMailClickListener = new OnClickListener() {
    	public void onClick(View v) {
    		setResult(R.id.replyMail);
    		finish();
    	}
    };
    private OnClickListener delMailClickListener = new OnClickListener() {
    	public void onClick(View v) {
    		setResult(R.id.delMail);
    		finish();
    	}
    };
    private OnClickListener nextClickListener = new OnClickListener() {
    	public void onClick(View v) {
    	     setResult(R.id.next);
    	     finish();
    	}
    };
}package mobi.cloudymail.mailclient;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.sql.SQLException;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

public class UpdateMailReceiver extends BroadcastReceiver
{
	private MailFolderActivity ui;
	public UpdateMailReceiver(MailFolderActivity ui)
	{
		this.ui = ui;
	}
	@Override
	public void onReceive(Context context, Intent intent)
	{
         String action=intent.getAction();
         try
		{
			ui.updateMail();
		}
		catch (SQLException e)
		{
			e.printStackTrace();
		}
         Log.d(LOGTAG, "current action is:"+action+",-----Wait for accepting...");
	}

}
package mobi.cloudymail.mms;
import java.io.File;

import mobi.cloudymail.util.Utils;
import android.R.integer;
import android.content.Context;
import android.net.Uri;

import com.google.android.mms.pdu.CharacterSets;
import com.google.android.mms.pdu.EncodedStringValue;
import com.google.android.mms.pdu.PduBody;
import com.google.android.mms.pdu.PduComposer;
import com.google.android.mms.pdu.PduPart;
import com.google.android.mms.pdu.SendReq;

/**
* @author 
* @version 创建时间：2012-1-31 下午01:59:30
*/
public class MMSInfo {
        private Context con;
        private PduBody pduBody;
        //以分号分隔的手机号字符串
        private String recieverNum;
        private int partCount = 1;
        private String subject="";
		//        private static final String SUBJECT_STR = "来自XX好友的彩信"; // 彩信主题
        public void setSubject(String subject)
        {
        	this.subject=subject;
        }
        public MMSInfo(Context con, String recieverNum) {
                // TODO Auto-generated constructor stub
                this.con = con;
                this.recieverNum = recieverNum;
                pduBody = new PduBody();
        }

	/**
	 * @param type
	 * @param str
	 * 
	 */
	public void addPart(String type, String str)
	{
		if (Utils.isEmpty(type) || Utils.isEmpty(str))
			return;
		if (type.equals("text"))
		{
			PduPart partPdu3 = new PduPart();
			partPdu3.setCharset(CharacterSets.UTF_8);
			partPdu3.setName("mms_text.txt".getBytes());
			partPdu3.setContentType("text/plain".getBytes());
			partPdu3.setData(str.getBytes());
			pduBody.addPart(partPdu3);
		}
		if (type.equals("image"))
		{
			PduPart partPdu = new PduPart();
			partPdu.setCharset(CharacterSets.UTF_8);
			partPdu.setName("camera.jpg".getBytes());
			partPdu.setContentType("image/png".getBytes());
			partPdu.setDataUri(Uri.fromFile(new File(str)));
			pduBody.addPart(partPdu);
		}
		if (type.equals("audio"))
		{
			PduPart partPdu2 = new PduPart();
			partPdu2.setCharset(CharacterSets.UTF_8);
			partPdu2.setName("speech_test.amr".getBytes());
			partPdu2.setContentType("audio/amr".getBytes());
			// partPdu2.setContentType("audio/amr-wb".getBytes());
			// partPdu2.setDataUri(Uri.parse("file://mnt//sdcard//.lv//audio//1326786209801.amr"));
			partPdu2.setDataUri(Uri.fromFile(new File(str)));
			pduBody.addPart(partPdu2);
		}
		// if("jpg".equals(getTypeFromUri(uriStr)))
		// part.setContentType("image/jpg".getBytes());
		// else if("png".equals(getTypeFromUri(uriStr)))
		// part.setContentType("image/png".getBytes());
	}

        /**
         * 通过URI路径得到图片格式，如："file://mnt/sdcard//1.jpg" -----> "jpg"
         * 
         * @author 
         * @param uriStr
         * @return
         */
        private String getTypeFromUri(String uriStr) {
                return uriStr.substring(uriStr.lastIndexOf("."), uriStr.length());
        }

        /**
         * 将彩信的内容以及主题等信息转化成byte数组，准备通过http协议发送到"http://mmsc.monternet.com"
         * 
         * @author 邓
         * @return
         */
        public byte[] getMMSBytes() {
                PduComposer composer = new PduComposer(con, initSendReq());
                return composer.make();
        }

        /**
         * 初始化SendReq
         * 
         * @author 
         * @return
         */
        private SendReq initSendReq() {
                SendReq req = new SendReq();
                EncodedStringValue[] sub = EncodedStringValue.extract(subject);
                if (sub != null && sub.length > 0) {
                        req.setSubject(sub[0]);// 设置主题
                }
                EncodedStringValue[] rec = EncodedStringValue.extract(recieverNum);
                if (rec != null && rec.length > 0) {
                	for(int i=0;i<rec.length;i++)
                        req.addTo(rec[i]);// 设置接收者
                }
		
                req.setBody(pduBody);
                return req;
        }

}//发送类
package mobi.cloudymail.mms;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.SocketException;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;

import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.HttpResponse;
import org.apache.http.StatusLine;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.params.HttpClientParams;
import org.apache.http.conn.params.ConnRoutePNames;
import org.apache.http.conn.params.ConnRouteParams;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.entity.ByteArrayEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Proxy;
import android.net.Uri;
import android.os.Handler;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.widget.Toast;

/**
 * 发送彩信至彩信中心
 */
public class MMSSender
{
	private static final String TAG = "MMSSender";
	public static String mmscUrl = "http://mmsc.monternet.com";
	public static String mmsProxy = "10.0.0.172";
	public static int mmsProt = 80;
	// 电信彩信中心url，代理，端口
	public static String mmscUrl_ct = "http://mmsc.vnet.mobi";//apn::ctwap
	public static String mmsProxy_ct = "10.0.0.200";
	// 移动彩信中心url，代理，端口
	public static String mmscUrl_cm = "http://mmsc.monternet.com";//apn:cmwap
	public static String mmsProxy_cm = "010.000.000.172";
	// 联通彩信中心url，代理，端口
	public static String mmscUrl_uni = "http://mmsc.myuni.com.cn";   //http://mmsc.vnet.mobi apn:uniwap或3gwap
	public static String mmsProxy_uni = "10.0.0.172";
	private static String HDR_VALUE_ACCEPT_LANGUAGE = "";
	private static final String HDR_KEY_ACCEPT = "Accept";
	private static final String HDR_KEY_ACCEPT_LANGUAGE = "Accept-Language";
	private static final String HDR_VALUE_ACCEPT = "*/*, application/vnd.wap.mms-message, application/vnd.wap.sic";
	private static String APN_NET_ID = null;
	public List<String> getSimMNC(Context context)
	{
		TelephonyManager telManager = (TelephonyManager) context
				.getSystemService(Context.TELEPHONY_SERVICE);
		String imsi = telManager.getSubscriberId();
		if (imsi != null)
		{
			ArrayList<String> list = new ArrayList<String>();
			if (imsi.startsWith("46000") || imsi.startsWith("46002")||imsi.startsWith("46007"))
			{
				// 因为移动网络编号46000下的IMSI已经用完，所以虚拟了一个46002编号，134/159号段使用了此编号
				// 中国移动
				list.add(mmscUrl_cm);
				list.add(mmsProxy_cm);
			}
			else if (imsi.startsWith("46001"))
			{
				// 中国联通
				list.add(mmscUrl_uni);
				list.add(mmsProxy_uni);
			}
			else if (imsi.startsWith("46003"))
			{
				// 中国电信
				list.add(mmscUrl_ct);
				list.add(mmsProxy_ct);
			}
//			shouldChangeApn(context);
			return list;
		}
		return null;
	}

	public boolean shouldChangeApn(final Context context)
	{

		final String wapId = getWapApnId(context);
		String apnId = getCurrentApn(context);
		// 若当前apn不是wap，则切换至wap
		if (!wapId.equals(apnId))
		{
			APN_NET_ID = apnId;
			setApn(context, wapId);
			// 切换apn需要一定时间，先让等待2秒
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException e)
			{
				e.printStackTrace();
			}
			return true;
		}
		return false;
	}

	private static String getCurrentApn(Context context)
	{
		ContentResolver resoler = context.getContentResolver();
		String[] projection = new String[] { "_id" };
		Cursor cur = resoler.query(	Uri.parse("content://telephony/carriers/preferapn"),//取得当前设置的apn
									projection,
									null, null, null);
		String apnId = null;
		if (cur != null && cur.moveToFirst())
		{
			do
			{
				apnId = cur.getString(cur.getColumnIndex("_id"));
			} while (cur.moveToNext());
		}
		return apnId;
	}

	/**
	 * 设置接入点
	 * 
	 * @param id
	 */
	private static void setApn(Context context, String id)
	{
		Uri uri = Uri.parse("content://telephony/carriers/preferapn");
		ContentResolver resolver = context.getContentResolver();
		ContentValues values = new ContentValues();
		values.put("apn_id", id);
		resolver.update(uri, values, null, null);
	}

	

	/**
	 * 取到wap接入c的id
	 * 
	 * @return
	 */
	private static String getWapApnId(Context context)
	{
		ContentResolver contentResolver = context.getContentResolver();
		String[] projection = new String[] { "_id", "proxy" };
		Cursor cur = contentResolver.query(	Uri.parse("content://telephony/carriers"), projection,//取得所有的apn列表
											"current = 1", null, null);
		if (cur != null && cur.moveToFirst())
		{
			do
			{
				String id = cur.getString(0);
				String proxy = cur.getString(1);
				if (!Utils.isEmpty(proxy))
				{
					return id;
				}
			} while (cur.moveToNext());
		}
		return null;
	}

	public boolean sendMMS(List<String> list, final Context context, byte[] pdu) throws Exception
	{
		// HDR_AVLUE_ACCEPT_LANGUAGE = getHttpAcceptLanguage();
		if (list == null)
		{
			new Handler().post(new Runnable() {

				@Override
				public void run()
				{
					Toast.makeText(context, "找不到sim卡", Toast.LENGTH_LONG).show();
				}
			});
			return false;
		}
		String mmsUrl = (String) list.get(0);
		String mmsProxy = (String) list.get(1);
		HttpClient client = null;
		try
		{
			HttpHost httpHost = new HttpHost(mmsProxy, 80);
			HttpParams httpParams = new BasicHttpParams();
			httpParams.setParameter(ConnRouteParams.DEFAULT_PROXY, httpHost);
			HttpConnectionParams.setConnectionTimeout(httpParams, 10000);
			client = new DefaultHttpClient(httpParams);
			
			HttpPost post = new HttpPost(mmsUrl);
			// mms PUD START
			ByteArrayEntity entity = new ByteArrayEntity(pdu);
			entity.setContentType("application/vnd.wap.mms-message");
			post.setEntity(entity);
			post.addHeader(HDR_KEY_ACCEPT, HDR_VALUE_ACCEPT);
			post.addHeader(HDR_KEY_ACCEPT_LANGUAGE, HDR_VALUE_ACCEPT_LANGUAGE);
			post.addHeader(	"user-agent",
							"Mozilla/5.0(Linux;U;Android 2.1-update1;zh-cn;ZTE-C_N600/ZTE-C_N600V1.0.0B02;240*320;CTC/2.0)AppleWebkit/530.17(KHTML,like Gecko) Version/4.0 Mobile Safari/530.17");
			// mms PUD END
			HttpParams params = client.getParams();
			HttpProtocolParams.setContentCharset(params, "UTF-8");
			HttpResponse response = client.execute(post);
			StatusLine status = response.getStatusLine();
			Log.d(TAG, "status " + status.getStatusCode());
			if (status.getStatusCode() != 200)
			{
				throw new IOException("HTTP error: " + status.getReasonPhrase());
			}
			// 彩信发送完毕后检查是否需要把接入点切换回来
			if (null != APN_NET_ID)
			{
				setApn(context, APN_NET_ID);
			}
			return true;

		}
		catch (Exception e)
		{
			e.printStackTrace();
			Log.d("彩信发送", "彩信发送失败：" + e.getMessage());
			// 发送失败处理
		}
		return false;
	}
}

package mobi.cloudymail.protocol.imap;

public class AuthenticationFailedException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public AuthenticationFailedException(String message)
    {
        super(message);
    }

    public AuthenticationFailedException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mobi.cloudymail.protocol.imap;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;

import org.apache.commons.codec.BinaryDecoder;
import org.apache.commons.codec.BinaryEncoder;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.EncoderException;

/**
 * Provides Base64 encoding and decoding as defined by RFC 2045.
 *
 * <p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
 * @author Apache Software Foundation
 * @since 1.0-dev
 * @version $Id$
 */
public class Base64 implements BinaryEncoder, BinaryDecoder
{
    /**
     * Chunk size per RFC 2045 section 6.8.
     *
     * <p>
     * The {@value} character limit does not count the trailing CRLF, but counts all other characters, including any
     * equal signs.
     * </p>
     *
     * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045 section 6.8</a>
     */
    static final int CHUNK_SIZE = 76;

    /**
     * Chunk separator per RFC 2045 section 2.1.
     *
     * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045 section 2.1</a>
     */
    static final byte[] CHUNK_SEPARATOR = {'\r','\n'};

    /**
     * This array is a lookup table that translates 6-bit positive integer
     * index values into their "Base64 Alphabet" equivalents as specified
     * in Table 1 of RFC 2045.
     *
     * Thanks to "commons" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] intToBase64 =
    {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    /**
     * Byte used to pad output.
     */
    private static final byte PAD = '=';

    /**
     * This array is a lookup table that translates unicode characters
     * drawn from the "Base64 Alphabet" (as specified in Table 1 of RFC 2045)
     * into their 6-bit positive integer equivalents.  Characters that
     * are not in the Base64 alphabet but fall within the bounds of the
     * array are translated to -1.
     *
     * Thanks to "commons" project in ws.apache.org for this code.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     */
    private static final byte[] base64ToInt =
    {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54,
        55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4,
        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
        24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34,
        35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
    };

    /** Mask used to extract 6 bits, used when encoding */
    private static final int MASK_6BITS = 0x3f;

    /** Mask used to extract 8 bits, used in decoding base64 bytes */
    private static final int MASK_8BITS = 0xff;

    // The static final fields above are used for the original static byte[] methods on Base64.
    // The private member fields below are used with the new streaming approach, which requires
    // some state be preserved between calls of encode() and decode().


    /**
     * Line length for encoding.  Not used when decoding.  A value of zero or less implies
     * no chunking of the base64 encoded data.
     */
    private final int lineLength;

    /**
     * Line separator for encoding.  Not used when decoding.  Only used if lineLength > 0.
     */
    private final byte[] lineSeparator;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>decodeSize = 3 + lineSeparator.length;</code>
     */
    private final int decodeSize;

    /**
     * Convenience variable to help us determine when our buffer is going to run out of
     * room and needs resizing.  <code>encodeSize = 4 + lineSeparator.length;</code>
     */
    private final int encodeSize;

    /**
     * Buffer for streaming.
     */
    private byte[] buf;

    /**
     * Position where next character should be written in the buffer.
     */
    private int pos;

    /**
     * Position where next character should be read from the buffer.
     */
    private int readPos;

    /**
     * Variable tracks how many characters have been written to the current line.
     * Only used when encoding.  We use it to make sure each encoded line never
     * goes beyond lineLength (if lineLength > 0).
     */
    private int currentLinePos;

    /**
     * Writes to the buffer only occur after every 3 reads when encoding, an
     * every 4 reads when decoding.  This variable helps track that.
     */
    private int modulus;

    /**
     * Boolean flag to indicate the EOF has been reached.  Once EOF has been
     * reached, this Base64 object becomes useless, and must be thrown away.
     */
    private boolean eof;

    /**
     * Place holder for the 3 bytes we're dealing with for our base64 logic.
     * Bitwise operations store and extract the base64 encoding or decoding from
     * this variable.
     */
    private int x;

    /**
     * Default constructor:  lineLength is 76, and the lineSeparator is CRLF
     * when encoding, and all forms can be decoded.
     */
    public Base64()
    {
        this(CHUNK_SIZE, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * when encoding (lineSeparator is still CRLF).  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     *
     * @param lineLength each line of encoded data will be at most this long
     * (rounded up to nearest multiple of 4).
     * If lineLength <= 0, then the output will not be divided into lines (chunks).
     * Ignored when decoding.
     */
    public Base64(int lineLength)
    {
        this(lineLength, CHUNK_SEPARATOR);
    }

    /**
     * <p>
     * Consumer can use this constructor to choose a different lineLength
     * and lineSeparator when encoding.  All forms of data can
     * be decoded.
     * </p><p>
     * Note:  lineLengths that aren't multiples of 4 will still essentially
     * end up being multiples of 4 in the encoded data.
     * </p>
     * @param lineLength    Each line of encoded data will be at most this long
     *                      (rounded up to nearest multiple of 4).  Ignored when decoding.
     *                      If <= 0, then output will not be divided into lines (chunks).
     * @param lineSeparator Each line of encoded data will end with this
     *                      sequence of bytes.
     *                      If lineLength <= 0, then the lineSeparator is not used.
     * @throws IllegalArgumentException The provided lineSeparator included
     *                                  some base64 characters.  That's not going to work!
     */
    public Base64(int lineLength, byte[] lineSeparator)
    {
        this.lineLength = lineLength;
        this.lineSeparator = new byte[lineSeparator.length];
        System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
        if (lineLength > 0)
        {
            this.encodeSize = 4 + lineSeparator.length;
        }
        else
        {
            this.encodeSize = 4;
        }
        this.decodeSize = encodeSize - 1;
        if (containsBase64Byte(lineSeparator))
        {
            String sep;
            try
            {
                sep = new String(lineSeparator, "UTF-8");
            }
            catch (UnsupportedEncodingException uee)
            {
                sep = new String(lineSeparator);
            }
            throw new IllegalArgumentException("lineSeperator must not contain base64 characters: [" + sep + "]");
        }
    }

    /**
     * Returns true if this Base64 object has buffered data for reading.
     *
     * @return true if there is Base64 object still available for reading.
     */
    boolean hasData()
    {
        return buf != null;
    }

    /**
     * Returns the amount of buffered data available for reading.
     *
     * @return The amount of buffered data available for reading.
     */
    int avail()
    {
        return buf != null ? pos - readPos : 0;
    }

    /** Doubles our buffer. */
    private void resizeBuf()
    {
        if (buf == null)
        {
            buf = new byte[8192];
            pos = 0;
            readPos = 0;
        }
        else
        {
            byte[] b = new byte[buf.length * 2];
            System.arraycopy(buf, 0, b, 0, buf.length);
            buf = b;
        }
    }

    /**
     * Extracts buffered data into the provided byte[] array, starting
     * at position bPos, up to a maximum of bAvail bytes.  Returns how
     * many bytes were actually extracted.
     *
     * @param b      byte[] array to extract the buffered data into.
     * @param bPos   position in byte[] array to start extraction at.
     * @param bAvail amount of bytes we're allowed to extract.  We may extract
     *               fewer (if fewer are available).
     * @return The number of bytes successfully extracted into the provided
     *         byte[] array.
     */
    int readResults(byte[] b, int bPos, int bAvail)
    {
        if (buf != null)
        {
            int len = Math.min(avail(), bAvail);
            if (buf != b)
            {
                System.arraycopy(buf, readPos, b, bPos, len);
                readPos += len;
                if (readPos >= pos)
                {
                    buf = null;
                }
            }
            else
            {
                // Re-using the original consumer's output array is only
                // allowed for one round.
                buf = null;
            }
            return len;
        }
        else
        {
            return eof ? -1 : 0;
        }
    }

    /**
     * Small optimization where we try to buffer directly to the consumer's
     * output array for one round (if consumer calls this method first!) instead
     * of starting our own buffer.
     *
     * @param out byte[] array to buffer directly to.
     * @param outPos Position to start buffering into.
     * @param outAvail Amount of bytes available for direct buffering.
     */
    void setInitialBuffer(byte[] out, int outPos, int outAvail)
    {
        // We can re-use consumer's original output array under
        // special circumstances, saving on some System.arraycopy().
        if (out != null && out.length == outAvail)
        {
            buf = out;
            pos = outPos;
            readPos = outPos;
        }
    }

    /**
     * <p>
     * Encodes all of the provided data, starting at inPos, for inAvail bytes.
     * Must be called at least twice:  once with the data to encode, and once
     * with inAvail set to "-1" to alert encoder that EOF has been reached,
     * so flush last remaining bytes (if not multiple of 3).
     * </p><p>
     * Thanks to "commons" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>
     *
     * @param in byte[] array of binary data to base64 encode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void encode(byte[] in, int inPos, int inAvail)
    {
        if (eof)
        {
            return;
        }

        // inAvail < 0 is how we're informed of EOF in the underlying data we're
        // encoding.
        if (inAvail < 0)
        {
            eof = true;
            if (buf == null || buf.length - pos < encodeSize)
            {
                resizeBuf();
            }
            switch (modulus)
            {
                case 1:
                    buf[pos++] = intToBase64[(x >> 2) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x << 4) & MASK_6BITS];
                    buf[pos++] = PAD;
                    buf[pos++] = PAD;
                    break;

                case 2:
                    buf[pos++] = intToBase64[(x >> 10) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 4) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x << 2) & MASK_6BITS];
                    buf[pos++] = PAD;
                    break;
            }
            if (lineLength > 0)
            {
                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                pos += lineSeparator.length;
            }
        }
        else
        {
            for (int i = 0; i < inAvail; i++)
            {
                if (buf == null || buf.length - pos < encodeSize)
                {
                    resizeBuf();
                }
                modulus = (++modulus) % 3;
                int b = in[inPos++];
                if (b < 0)
                {
                    b += 256;
                }
                x = (x << 8) + b;
                if (0 == modulus)
                {
                    buf[pos++] = intToBase64[(x >> 18) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 12) & MASK_6BITS];
                    buf[pos++] = intToBase64[(x >> 6) & MASK_6BITS];
                    buf[pos++] = intToBase64[x & MASK_6BITS];
                    currentLinePos += 4;
                    if (lineLength > 0 && lineLength <= currentLinePos)
                    {
                        System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);
                        pos += lineSeparator.length;
                        currentLinePos = 0;
                    }
                }
            }
        }
    }

    /**
     * <p>
     * Decodes all of the provided data, starting at inPos, for inAvail bytes.
     * Should be called at least twice:  once with the data to decode, and once
     * with inAvail set to "-1" to alert decoder that EOF has been reached.
     * The "-1" call is not necessary when decoding, but it doesn't hurt, either.
     * </p><p>
     * Ignores all non-base64 characters.  This is how chunked (e.g. 76 character)
     * data is handled, since CR and LF are silently ignored, but has implications
     * for other bytes, too.  This method subscribes to the garbage-in, garbage-out
     * philosophy:  it will not check the provided data for validity.
     * </p><p>
     * Thanks to "commons" project in ws.apache.org for the bitwise operations,
     * and general approach.
     * http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/
     * </p>

     * @param in byte[] array of ascii data to base64 decode.
     * @param inPos Position to start reading data from.
     * @param inAvail Amount of bytes available from input for encoding.
     */
    void decode(byte[] in, int inPos, int inAvail)
    {
        if (eof)
        {
            return;
        }
        if (inAvail < 0)
        {
            eof = true;
        }
        for (int i = 0; i < inAvail; i++)
        {
            if (buf == null || buf.length - pos < decodeSize)
            {
                resizeBuf();
            }
            byte b = in[inPos++];
            if (b == PAD)
            {
                x = x << 6;
                switch (modulus)
                {
                    case 2:
                        x = x << 6;
                        buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                        break;
                    case 3:
                        buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                        buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                        break;
                }
                // WE'RE DONE!!!!
                eof = true;
                return;
            }
            else
            {
                if (b >= 0 && b < base64ToInt.length)
                {
                    int result = base64ToInt[b];
                    if (result >= 0)
                    {
                        modulus = (++modulus) % 4;
                        x = (x << 6) + result;
                        if (modulus == 0)
                        {
                            buf[pos++] = (byte)((x >> 16) & MASK_8BITS);
                            buf[pos++] = (byte)((x >> 8) & MASK_8BITS);
                            buf[pos++] = (byte)(x & MASK_8BITS);
                        }
                    }
                }
            }
        }
    }

    /**
     * Returns whether or not the <code>octet</code> is in the base 64 alphabet.
     *
     * @param octet
     *            The value to test
     * @return <code>true</code> if the value is defined in the the base 64 alphabet, <code>false</code> otherwise.
     */
    public static boolean isBase64(byte octet)
    {
        return octet == PAD || (octet >= 0 && octet < base64ToInt.length && base64ToInt[octet] != -1);
    }

    /**
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     * Currently the method treats whitespace as valid.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if all bytes are valid characters in the Base64 alphabet or if the byte array is
     *         empty; false, otherwise
     */
    public static boolean isArrayByteBase64(byte[] arrayOctet)
    {
        for (byte anArrayOctet : arrayOctet)
        {
            if (!isBase64(anArrayOctet) && !isWhiteSpace(anArrayOctet))
            {
                return false;
            }
        }
        return true;
    }

    /*
     * Tests a given byte array to see if it contains only valid characters within the Base64 alphabet.
     *
     * @param arrayOctet
     *            byte array to test
     * @return <code>true</code> if any byte is a valid character in the Base64 alphabet; false herwise
     */
    private static boolean containsBase64Byte(byte[] arrayOctet)
    {
        for (byte element : arrayOctet)
        {
            if (isBase64(element))
            {
                return true;
            }
        }
        return false;
    }

    /**
     * Encodes binary data using the base64 algorithm but does not chunk the output.
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters
     */
    public static byte[] encodeBase64(byte[] binaryData)
    {
        return encodeBase64(binaryData, false);
    }

    /**
     * Encodes binary data using the base64 algorithm and chunks the encoded output into 76 character blocks
     *
     * @param binaryData
     *            binary data to encode
     * @return Base64 characters chunked in 76 character blocks
     */
    public static byte[] encodeBase64Chunked(byte[] binaryData)
    {
        return encodeBase64(binaryData, true);
    }

    /**
     * Decodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Decoder interface, and will throw a DecoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to decode
     * @return An object (of type byte[]) containing the binary data which corresponds to the byte[] supplied.
     * @throws DecoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object decode(Object pObject) throws DecoderException
    {
        if (!(pObject instanceof byte[]))
        {
            throw new DecoderException("Parameter supplied to Base64 decode is not a byte[]");
        }
        return decode((byte[]) pObject);
    }

    /**
     * Decodes a byte[] containing containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            A byte array containing Base64 character data
     * @return a byte array containing binary data
     */
    public byte[] decode(byte[] pArray)
    {
        return decodeBase64(pArray);
    }

    /**
     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.
     *
     * @param binaryData
     *            Array containing binary data to encode.
     * @param isChunked
     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks
     * @return Base64-encoded data.
     * @throws IllegalArgumentException
     *             Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE}
     */
    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked)
    {
        if (binaryData == null || binaryData.length == 0)
        {
            return binaryData;
        }
        Base64 b64 = isChunked ? new Base64() : new Base64(0);

        long len = (binaryData.length * 4) / 3;
        long mod = len % 4;
        if (mod != 0)
        {
            len += 4 - mod;
        }
        if (isChunked)
        {
            len += (1 + (len / CHUNK_SIZE)) * CHUNK_SEPARATOR.length;
        }

        if (len > Integer.MAX_VALUE)
        {
            throw new IllegalArgumentException(
                "Input array too big, output array would be bigger than Integer.MAX_VALUE=" + Integer.MAX_VALUE);
        }
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.encode(binaryData, 0, binaryData.length);
        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.

        // Encoder might have resized, even though it was unnecessary.
        if (b64.buf != buf)
        {
            b64.readResults(buf, 0, buf.length);
        }
        return buf;
    }

    /**
     * Decodes Base64 data into octets
     *
     * @param base64Data Byte array containing Base64 data
     * @return Array containing decoded data.
     */
    public static byte[] decodeBase64(byte[] base64Data)
    {
        if (base64Data == null || base64Data.length == 0)
        {
            return base64Data;
        }
        Base64 b64 = new Base64();

        long len = (base64Data.length * 3) / 4;
        byte[] buf = new byte[(int) len];
        b64.setInitialBuffer(buf, 0, buf.length);
        b64.decode(base64Data, 0, base64Data.length);
        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.

        // We have no idea what the line-length was, so we
        // cannot know how much of our array wasn't used.
        byte[] result = new byte[b64.pos];
        b64.readResults(result, 0, result.length);
        return result;
    }

    /**
     * Check if a byte value is whitespace or not.
     *
     * @param byteToCheck the byte to check
     * @return true if byte is whitespace, false otherwise
     */
    private static boolean isWhiteSpace(byte byteToCheck)
    {
        switch (byteToCheck)
        {
            case ' ' :
            case '\n' :
            case '\r' :
            case '\t' :
                return true;
            default :
                return false;
        }
    }

    /**
     * Discards any characters outside of the base64 alphabet, per the requirements on page 25 of RFC 2045 - "Any
     * characters outside of the base64 alphabet are to be ignored in base64 encoded data."
     *
     * @param data
     *            The base-64 encoded data to groom
     * @return The data, less non-base64 characters (see RFC 2045).
     */
    static byte[] discardNonBase64(byte[] data)
    {
        byte groomedData[] = new byte[data.length];
        int bytesCopied = 0;

        for (byte element : data)
        {
            if (isBase64(element))
            {
                groomedData[bytesCopied++] = element;
            }
        }

        byte packedData[] = new byte[bytesCopied];

        System.arraycopy(groomedData, 0, packedData, 0, bytesCopied);

        return packedData;
    }

    // Implementation of the Encoder Interface

    /**
     * Encodes an Object using the base64 algorithm. This method is provided in order to satisfy the requirements of the
     * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
     *
     * @param pObject
     *            Object to encode
     * @return An object (of type byte[]) containing the base64 encoded data which corresponds to the byte[] supplied.
     * @throws EncoderException
     *             if the parameter supplied is not of type byte[]
     */
    public Object encode(Object pObject) throws EncoderException
    {
        if (!(pObject instanceof byte[]))
        {
            throw new EncoderException("Parameter supplied to Base64 encode is not a byte[]");
        }
        return encode((byte[]) pObject);
    }

    /**
     * Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.
     *
     * @param pArray
     *            a byte array containing binary data
     * @return A byte array containing only Base64 character data
     */
    public byte[] encode(byte[] pArray)
    {
        return encodeBase64(pArray, false);
    }

    // Implementation of integer encoding used for crypto
    /**
     * Decode a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param pArray a byte array containing base64 character data
     * @return A BigInteger
     */
    public static BigInteger decodeInteger(byte[] pArray)
    {
        return new BigInteger(1, decodeBase64(pArray));
    }

    /**
     * Encode to a byte64-encoded integer according to crypto
     * standards such as W3C's XML-Signature
     *
     * @param bigInt a BigInteger
     * @return A byte array containing base64 character data
     * @throws NullPointerException if null is passed in
     */
    public static byte[] encodeInteger(BigInteger bigInt)
    {
        if (bigInt == null)
        {
            throw new NullPointerException("encodeInteger called with null parameter");
        }

        return encodeBase64(toIntegerBytes(bigInt), false);
    }

    /**
     * Returns a byte-array representation of a <code>BigInteger</code>
     * without sign bit.
     *
     * @param bigInt <code>BigInteger</code> to be converted
     * @return a byte array representation of the BigInteger parameter
     */
    static byte[] toIntegerBytes(BigInteger bigInt)
    {
        int bitlen = bigInt.bitLength();
        // round bitlen
        bitlen = ((bitlen + 7) >> 3) << 3;
        byte[] bigBytes = bigInt.toByteArray();

        if (((bigInt.bitLength() % 8) != 0) &&
                (((bigInt.bitLength() / 8) + 1) == (bitlen / 8)))
        {
            return bigBytes;
        }

        // set up params for copying everything but sign bit
        int startSrc = 0;
        int len = bigBytes.length;

        // if bigInt is exactly byte-aligned, just skip signbit in copy
        if ((bigInt.bitLength() % 8) == 0)
        {
            startSrc = 1;
            len--;
        }

        int startDst = bitlen / 8 - len; // to pad w/ nulls as per spec
        byte[] resizedBytes = new byte[bitlen / 8];

        System.arraycopy(bigBytes, startSrc, resizedBytes, startDst, len);

        return resizedBytes;
    }
}
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mobi.cloudymail.protocol.imap;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
 * When encoding the default lineLength is 76 characters and the default
 * lineEnding is CRLF, but these can be overridden by using the appropriate
 * constructor.
 * <p>
 * The default behaviour of the Base64OutputStream is to ENCODE, whereas the
 * default behaviour of the Base64InputStream is to DECODE.  But this behaviour
 * can be overridden by using a different constructor.
 * </p><p>
 * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
 * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
 * </p>
 *
 * @author Apache Software Foundation
 * @version $Id $
 * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
 * @since 1.0-dev
 */
public class Base64OutputStream extends FilterOutputStream
{
    private final boolean doEncode;
    private final Base64 base64;
    private final byte[] singleByte = new byte[1];

    /**
     * Creates a Base64OutputStream such that all data written is Base64-encoded
     * to the original provided OutputStream.
     *
     * @param out OutputStream to wrap.
     */
    public Base64OutputStream(OutputStream out)
    {
        this(out, true);
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out      OutputStream to wrap.
     * @param doEncode true if we should encode all data written to us,
     *                 false if we should decode.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode)
    {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64();
    }

    /**
     * Creates a Base64OutputStream such that all data written is either
     * Base64-encoded or Base64-decoded to the original provided OutputStream.
     *
     * @param out           OutputStream to wrap.
     * @param doEncode      true if we should encode all data written to us,
     *                      false if we should decode.
     * @param lineLength    If doEncode is true, each line of encoded
     *                      data will contain lineLength characters.
     *                      If lineLength <=0, the encoded data is not divided into lines.
     *                      If doEncode is false, lineLength is ignored.
     * @param lineSeparator If doEncode is true, each line of encoded
     *                      data will be terminated with this byte sequence (e.g. \r\n).
     *                      If lineLength <= 0, the lineSeparator is not used.
     *                      If doEncode is false lineSeparator is ignored.
     */
    public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator)
    {
        super(out);
        this.doEncode = doEncode;
        this.base64 = new Base64(lineLength, lineSeparator);
    }

    /**
     * Writes the specified <code>byte</code> to this output stream.
     */
    @Override
    public void write(int i) throws IOException
    {
        singleByte[0] = (byte) i;
        write(singleByte, 0, 1);
    }

    /**
     * Writes <code>len</code> bytes from the specified
     * <code>b</code> array starting at <code>offset</code> to
     * this output stream.
     *
     * @param b source byte array
     * @param offset where to start reading the bytes
     * @param len maximum number of bytes to write
     *
     * @throws IOException if an I/O error occurs.
     * @throws NullPointerException if the byte array parameter is null
     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
     */
    @Override
    public void write(byte b[], int offset, int len) throws IOException
    {
        if (b == null)
        {
            throw new NullPointerException();
        }
        else if (offset < 0 || len < 0 || offset + len < 0)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (offset > b.length || offset + len > b.length)
        {
            throw new IndexOutOfBoundsException();
        }
        else if (len > 0)
        {
            if (doEncode)
            {
                base64.encode(b, offset, len);
            }
            else
            {
                base64.decode(b, offset, len);
            }
            flush(false);
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.  If propogate is true, the wrapped
     * stream will also be flushed.
     *
     * @param propogate boolean flag to indicate whether the wrapped
     *                  OutputStream should also be flushed.
     * @throws IOException if an I/O error occurs.
     */
    private void flush(boolean propogate) throws IOException
    {
        int avail = base64.avail();
        if (avail > 0)
        {
            byte[] buf = new byte[avail];
            int c = base64.readResults(buf, 0, avail);
            if (c > 0)
            {
                out.write(buf, 0, c);
            }
        }
        if (propogate)
        {
            out.flush();
        }
    }

    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out to the stream.
     *
     * @throws IOException if an I/O error occurs.
     */
    @Override
    public void flush() throws IOException
    {
        flush(true);
    }

    /**
     * Closes this output stream, flushing any remaining bytes that must be encoded. The
     * underlying stream is flushed but not closed.
     */
    @Override
    public void close() throws IOException
    {
        // Notify encoder of EOF (-1).
        if (doEncode)
        {
            base64.encode(singleByte, 0, -1);
        }
        else
        {
            base64.decode(singleByte, 0, -1);
        }
        flush();
    }

}

package mobi.cloudymail.protocol.imap;

public class CertificateValidationException extends MessagingException
{
    public static final long serialVersionUID = -1;

    public CertificateValidationException(String message)
    {
        super(message);
    }

    public CertificateValidationException(String message, Throwable throwable)
    {
        super(message, throwable);
    }
}
package mobi.cloudymail.protocol.imap;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that stops allowing reads after the given length has been read. This
 * is used to allow a client to read directly from an underlying protocol stream without reading
 * past where the protocol handler intended the client to read.
 */
public class FixedLengthInputStream extends InputStream
{
    private InputStream mIn;
    private int mLength;
    private int mCount;

    public FixedLengthInputStream(InputStream in, int length)
    {
        this.mIn = in;
        this.mLength = length;
    }

    @Override
    public int available() throws IOException
    {
        return mLength - mCount;
    }

    @Override
    public int read() throws IOException
    {
        if (mCount < mLength)
        {
            mCount++;
            return mIn.read();
        }
        else
        {
            return -1;
        }
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException
    {
        if (mCount < mLength)
        {
            int d = mIn.read(b, offset, Math.min(mLength - mCount, length));
            if (d == -1)
            {
                return -1;
            }
            else
            {
                mCount += d;
                return d;
            }
        }
        else
        {
            return -1;
        }
    }

    @Override
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    @Override
    public String toString()
    {
        return String.format("FixedLengthInputStream(in=%s, length=%d)", mIn.toString(), mLength);
    }
}

package mobi.cloudymail.protocol.imap;

/**
 * Flags that can be applied to Messages.
 */
public enum Flag
{
    DELETED,
    SEEN,
    ANSWERED,
    FLAGGED,
    DRAFT,
    RECENT,

    /*
     * The following flags are for internal library use only.
     */
    /**
     * Delete and remove from the LocalStore immediately.
     */
    X_DESTROYED,

    /**
     * Sending of an unsent message failed. It will be retried. Used to show status.
     */
    X_SEND_FAILED,

    /**
     * Sending of an unsent message is in progress.
     */
    X_SEND_IN_PROGRESS,

    /**
     * Indicates that a message is fully downloaded from the server and can be viewed normally.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_FULL,

    /**
     * Indicates that a message is partially downloaded from the server and can be viewed but
     * more content is available on the server.
     * This does not include attachments, which are never downloaded fully.
     */
    X_DOWNLOADED_PARTIAL,

    /**
     * Indicates that the copy of a message to the Sent folder has started.
     */
    X_REMOTE_COPY_STARTED,

    /**
     * Indicates that all headers of the message have been stored in the
     * database. If this is false, additional headers might be retrieved from
     * the server (if the message is still there).
     */
    X_GOT_ALL_HEADERS,
}
package mobi.cloudymail.protocol.imap;

import mobi.cloudymail.mailclient.net.Account;

public abstract class Folder
{
    protected final Account mAccount;

    private String status = null;
    private long lastChecked = 0;
    private long lastPush = 0;
    public enum OpenMode
    {
        READ_WRITE, READ_ONLY,
    }
    // NONE is obsolete, it will be translated to NO_CLASS for display and to INHERITED for sync and push
    public enum FolderClass
    {
        NONE, NO_CLASS, INHERITED, FIRST_CLASS, SECOND_CLASS
    }

    public enum FolderType
    {
        HOLDS_FOLDERS, HOLDS_MESSAGES,
    }

    protected Folder(Account account)
    {
        mAccount = account;
    }

    /**
     * Forces an open of the MailProvider. If the provider is already open this
     * function returns without doing anything.
     *
     * @param mode READ_ONLY or READ_WRITE
     */
    public abstract void open(OpenMode mode) throws MessagingException;

    /**
     * Forces a close of the MailProvider. Any further access will attempt to
     * reopen the MailProvider.
     */
    public abstract void close();

    /**
     * @return True if further commands are not expected to have to open the
     *         connection.
     */
    public abstract boolean isOpen();

    /**
     * Get the mode the folder was opened with. This may be different than the mode the open
     * was requested with.
     * @return
     */
    public abstract OpenMode getMode();

    public abstract boolean create(FolderType type) throws MessagingException;

    /**
     * Create a new folder with a specified display limit.  Not abstract to allow
     * remote folders to not override or worry about this call if they don't care to.
     */
    public boolean create(FolderType type, int displayLimit) throws MessagingException
    {
        return create(type);
    }

    public abstract boolean exists() throws MessagingException;

    /**
     * @return A count of the messages in the selected folder.
     */
    public abstract int getMessageCount() throws MessagingException;

    public abstract int getUnreadMessageCount() throws MessagingException;
    public abstract int getFlaggedMessageCount() throws MessagingException;

//    public abstract Message getMessage(String uid) throws MessagingException;
//
//    public abstract Message[] getMessages(int start, int end, Date earliestDate, MessageRetrievalListener listener)
//    throws MessagingException;

    /**
     * Fetches the given list of messages. The specified listener is notified as
     * each fetch completes. Messages are downloaded as (as) lightweight (as
     * possible) objects to be filled in with later requests. In most cases this
     * means that only the UID is downloaded.
     *
     * @param uids
     * @param listener
     */
//    public abstract Message[] getMessages(MessageRetrievalListener listener)
//    throws MessagingException;
//
//    public Message[] getMessages(MessageRetrievalListener listener, boolean includeDeleted) throws MessagingException
//    {
//        return getMessages(listener);
//    }
//
//    public abstract Message[] getMessages(String[] uids, MessageRetrievalListener listener)
//    throws MessagingException;
//
//    public abstract void appendMessages(Message[] messages) throws MessagingException;
//
//    public void copyMessages(Message[] msgs, Folder folder) throws MessagingException {}
//
//    public void moveMessages(Message[] msgs, Folder folder) throws MessagingException {}
//
//    public void delete(Message[] msgs, String trashFolderName) throws MessagingException
//    {
//        for (Message message : msgs)
//        {
//            Message myMessage = getMessage(message.getUid());
//            myMessage.delete(trashFolderName);
//        }
//    }
//
//    public abstract void setFlags(Message[] messages, Flag[] flags, boolean value)
//    throws MessagingException;
//
//    public abstract void setFlags(Flag[] flags, boolean value) throws MessagingException;
//
//    public abstract String getUidFromMessageId(Message message) throws MessagingException;
//
//    public void expunge() throws MessagingException
//        {}
//
//    public abstract void fetch(Message[] messages, FetchProfile fp,
//                               MessageRetrievalListener listener) throws MessagingException;
//
//    public void fetchPart(Message message, Part part,
//                          MessageRetrievalListener listener) throws MessagingException
//    {
//        // This is causing trouble. Disabled for now. See issue 1733
//        //throw new RuntimeException("fetchPart() not implemented.");
//
//        if (K9.DEBUG)
//            Log.d(K9.LOG_TAG, "fetchPart() not implemented.");
//    }
//
//    public abstract void delete(boolean recurse) throws MessagingException;

    public abstract String getName();

    public abstract Flag[] getPermanentFlags();

//    /**
//     *
//     * @param oldPushState
//     * @param message
//     * @return empty string to clear the pushState, null to leave the state as-is
//     */
//    public String getNewPushState(String oldPushState, Message message)
//    {
//        return null;
//    }
//
//    public boolean supportsFetchingFlags()
//    {
//        return true;
//    }//isFlagSupported

    @Override
    public String toString()
    {
        return getName();
    }

    public long getLastChecked()
    {
        return lastChecked;
    }

    public void setLastChecked(long lastChecked) throws MessagingException
    {
        this.lastChecked = lastChecked;
    }

    public long getLastPush()
    {
        return lastPush;
    }

    public void setLastPush(long lastCheckedDisplay) throws MessagingException
    {
        this.lastPush = lastCheckedDisplay;
    }

    public long getLastUpdate()
    {
        return Math.max(getLastChecked(), getLastPush());
    }

    public FolderClass getDisplayClass()
    {
        return FolderClass.NO_CLASS;
    }

    public FolderClass getSyncClass()
    {
        return getDisplayClass();
    }
    public FolderClass getPushClass()
    {
        return getSyncClass();
    }

//    public void refresh(Preferences preferences) throws MessagingException
//    {
//
//    }
//
//    public boolean isInTopGroup()
//    {
//        return false;
//    }

    public String getStatus()
    {
        return status;
    }

    public void setStatus(String status) throws MessagingException
    {
        this.status = status;
    }

    public Account getAccount()
    {
        return mAccount;
    }
}
package mobi.cloudymail.protocol.imap;

import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Locale;

public class ImapResponseParser
{
    private static final SimpleDateFormat mDateTimeFormat = new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss Z", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat = new SimpleDateFormat("dd MMM yyyy HH:mm:ss Z", Locale.US);
    private static final SimpleDateFormat badDateTimeFormat2 = new SimpleDateFormat("E, dd MMM yyyy HH:mm:ss Z", Locale.US);

    private PeekableInputStream mIn;
    private ImapResponse mResponse;
    private Exception mException;

    public ImapResponseParser(PeekableInputStream in)
    {
        this.mIn = in;
    }

    public ImapResponse readResponse() throws IOException
    {
        return readResponse(null);
    }

    /**
     * Reads the next response available on the stream and returns an
     * ImapResponse object that represents it.
     */
    public ImapResponse readResponse(IImapResponseCallback callback) throws IOException
    {
        try
        {
            ImapResponse response = new ImapResponse();
            mResponse = response;
            mResponse.mCallback = callback;

            int ch = mIn.peek();
            if (ch == '*')
            {
                parseUntaggedResponse();
                readTokens(response);
            }
            else if (ch == '+')
            {
                response.mCommandContinuationRequested =
                    parseCommandContinuationRequest();
                //TODO: Add special "resp-text" parsing
                readTokens(response);
            }
            else
            {
                response.mTag = parseTaggedResponse();
                readTokens(response);
            }

            if (mException != null)
            {
                throw new RuntimeException("readResponse(): Exception in callback method", mException);
            }

            return response;
        }
        finally
        {
            mResponse.mCallback = null;
            mResponse = null;
            mException = null;
        }
    }

    private void readTokens(ImapResponse response) throws IOException
    {
        response.clear();
        Object token;
        while ((token = readToken(response)) != null)
        {
            if (!(token instanceof ImapList))
            {
                response.add(token);
            }

            /*
             * TODO: Check for responses ("OK", "PREAUTH", "BYE", "NO", "BAD")
             * that can contain resp-text tokens. If found, hand over to a special
             * method that parses a resp-text token. There's no need to use
             * readToken()/parseToken() on that data.
             *
             * See RFC 3501, Section 9 Formal Syntax (resp-text)
             */
        }
        response.mCompleted = true;
    }

    /**
     * Reads the next token of the response. The token can be one of: String -
     * for NIL, QUOTED, NUMBER, ATOM. Object - for LITERAL.
     * ImapList - for PARENTHESIZED LIST. Can contain any of the above
     * elements including List.
     *
     * @return The next token in the response or null if there are no more
     *         tokens.
     */
    private Object readToken(ImapResponse response) throws IOException
    {
        while (true)
        {
            Object token = parseToken(response);
            if (token == null || !(token.equals(")") || token.equals("]")))
            {
                return token;
            }
        }
    }

    private Object parseToken(ImapList parent) throws IOException
    {
        while (true)
        {
            int ch = mIn.peek();
            if (ch == '(')
            {
                return parseList(parent);
            }
            else if (ch == '[')
            {
                return parseSequence(parent);
            }
            else if (ch == ')')
            {
                expect(')');
                return ")";
            }
            else if (ch == ']')
            {
                expect(']');
                return "]";
            }
            else if (ch == '"')
            {
                return parseQuoted();
            }
            else if (ch == '{')
            {
                return parseLiteral();
            }
            else if (ch == ' ')
            {
                expect(' ');
            }
            else if (ch == '\r')
            {
                expect('\r');
                expect('\n');
                return null;
            }
            else if (ch == '\n')
            {
                expect('\n');
                return null;
            }
            else if (ch == '\t')
            {
                expect('\t');
            }
            else
            {
                return parseAtom();
            }
        }
    }

    private boolean parseCommandContinuationRequest() throws IOException
    {
        expect('+');
        return true;
    }

    // * OK [UIDNEXT 175] Predicted next UID
    private void parseUntaggedResponse() throws IOException
    {
        expect('*');
        expect(' ');
    }

    // 3 OK [READ-WRITE] Select completed.
    private String parseTaggedResponse() throws IOException
    {
        String tag = readStringUntil(' ');
        return tag;
    }

    private ImapList parseList(ImapList parent) throws IOException
    {
        expect('(');
        ImapList list = new ImapList();
        parent.add(list);
        Object token;
        while (true)
        {
            token = parseToken(list);
            if (token == null)
            {
                return null;
            }
            else if (token.equals(")"))
            {
                break;
            }
            else if (token instanceof ImapList)
            {
                // Do nothing
            }
            else
            {
                list.add(token);
            }
        }
        return list;
    }

    private ImapList parseSequence(ImapList parent) throws IOException
    {
        expect('[');
        ImapList list = new ImapList();
        parent.add(list);
        Object token;
        while (true)
        {
            token = parseToken(list);
            if (token == null)
            {
                return null;
            }
            else if (token.equals("]"))
            {
                break;
            }
            else if (token instanceof ImapList)
            {
                // Do nothing
            }
            else
            {
                list.add(token);
            }
        }
        return list;
    }

    private String parseAtom() throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int ch;
        while (true)
        {
            ch = mIn.peek();
            if (ch == -1)
            {
                throw new IOException("parseAtom(): end of stream reached");
            }
            else if (ch == '(' || ch == ')' || ch == '{' || ch == ' ' ||
                     ch == '[' || ch == ']' ||
                     // docs claim that flags are \ atom but atom isn't supposed to
                     // contain
                     // * and some falgs contain *
                     // ch == '%' || ch == '*' ||
//                    ch == '%' ||
                     // TODO probably should not allow \ and should recognize
                     // it as a flag instead
                     // ch == '"' || ch == '\' ||
                     ch == '"' || (ch >= 0x00 && ch <= 0x1f) || ch == 0x7f)
            {
                if (sb.length() == 0)
                {
                    throw new IOException(String.format("parseAtom(): (%04x %c)", ch, ch));
                }
                return sb.toString();
            }
            else
            {
                sb.append((char)mIn.read());
            }
        }
    }

    /**
     * A "{" has been read. Read the rest of the size string, the space and then
     * notify the callback with an InputStream.
     */
    private Object parseLiteral() throws IOException
    {
        expect('{');
        int size = Integer.parseInt(readStringUntil('}'));
        expect('\r');
        expect('\n');

        if (size == 0)
        {
            return "";
        }

        if (mResponse.mCallback != null)
        {
            FixedLengthInputStream fixed = new FixedLengthInputStream(mIn, size);

            Object result = null;
            try
            {
                result = mResponse.mCallback.foundLiteral(mResponse, fixed);
            }
            catch (IOException e)
            {
                // Pass IOExceptions through
                throw e;
            }
            catch (Exception e)
            {
                // Catch everything else and save it for later.
                mException = e;
                //Log.e(K9.LOG_TAG, "parseLiteral(): Exception in callback method", e);
            }

            // Check if only some of the literal data was read
            int available = fixed.available();
            if ((available > 0) && (available != size))
            {
                // If so, skip the rest
                while (fixed.available() > 0)
                {
                    fixed.skip(fixed.available());
                }
            }

            if (result != null)
            {
                return result;
            }
        }

        byte[] data = new byte[size];
        int read = 0;
        while (read != size)
        {
            int count = mIn.read(data, read, size - read);
            if (count == -1)
            {
                throw new IOException("parseLiteral(): end of stream reached");
            }
            read += count;
        }

        return new String(data, "US-ASCII");
    }

    private String parseQuoted() throws IOException
    {
        expect('"');

        StringBuffer sb = new StringBuffer();
        int ch;
        boolean escape = false;
        while ((ch = mIn.read()) != -1)
        {
            if (!escape && (ch == '\\'))
            {
                // Found the escape character
                escape = true;
            }
            else if (!escape && (ch == '"'))
            {
                return sb.toString();
            }
            else
            {
                sb.append((char)ch);
                escape = false;
            }
        }
        throw new IOException("parseQuoted(): end of stream reached");
    }

    private String readStringUntil(char end) throws IOException
    {
        StringBuffer sb = new StringBuffer();
        int ch;
        while ((ch = mIn.read()) != -1)
        {
            if (ch == end)
            {
                return sb.toString();
            }
            else
            {
                sb.append((char)ch);
            }
        }
        throw new IOException("readStringUntil(): end of stream reached");
    }

    private int expect(char ch) throws IOException
    {
        int d;
        if ((d = mIn.read()) != ch)
        {
            throw new IOException(String.format("Expected %04x (%c) but got %04x (%c)", (int)ch,
                                                ch, d, (char)d));
        }
        return d;
    }

    /**
     * Represents an IMAP list response and is also the base class for the
     * ImapResponse.
     */
    public class ImapList extends ArrayList<Object>
    {
        private static final long serialVersionUID = -4067248341419617583L;

        public ImapList getList(int index)
        {
            return (ImapList)get(index);
        }

        public Object getObject(int index)
        {
            return get(index);
        }

        public String getString(int index)
        {
            return (String)get(index);
        }

        public InputStream getLiteral(int index)
        {
            return (InputStream)get(index);
        }

        public int getNumber(int index)
        {
            return Integer.parseInt(getString(index));
        }

        public Date getDate(int index) throws MessagingException
        {
            try
            {
                return parseDate(getString(index));
            }
            catch (ParseException pe)
            {
                throw new MessagingException("Unable to parse IMAP datetime", pe);
            }
        }

        public Object getKeyedValue(Object key)
        {
            for (int i = 0, count = size(); i < count; i++)
            {
                if (equalsIgnoreCase(get(i), key))
                {
                    return get(i + 1);
                }
            }
            return null;
        }

        public ImapList getKeyedList(Object key)
        {
            return (ImapList)getKeyedValue(key);
        }

        public String getKeyedString(Object key)
        {
            return (String)getKeyedValue(key);
        }

        public InputStream getKeyedLiteral(Object key)
        {
            return (InputStream)getKeyedValue(key);
        }

        public int getKeyedNumber(Object key)
        {
            return Integer.parseInt(getKeyedString(key));
        }

        public Date getKeyedDate(Object key) throws MessagingException
        {
            try
            {
                String value = getKeyedString(key);
                if (value == null)
                {
                    return null;
                }
                return parseDate(value);
            }
            catch (ParseException pe)
            {
                throw new MessagingException("Unable to parse IMAP datetime", pe);
            }
        }

        public boolean containsKey(Object key)
        {
            if (key == null)
            {
                return false;
            }

            for (int i = 0, count = size(); i < count; i++)
            {
                if (equalsIgnoreCase(key, get(i)))
                {
                    return true;
                }
            }
            return false;
        }

        public int getKeyIndex(Object key)
        {
            for (int i = 0, count = size(); i < count; i++)
            {
                if (equalsIgnoreCase(key, get(i)))
                {
                    return i;
                }
            }

            throw new IllegalArgumentException("getKeyIndex() only works for keys that are in the collection.");
        }

        private Date parseDate(String value) throws ParseException
        {
            //TODO: clean this up a bit
            try
            {
                synchronized (mDateTimeFormat)
                {
                    return mDateTimeFormat.parse(value);
                }
            }
            catch (Exception e)
            {
                try
                {
                    synchronized (badDateTimeFormat)
                    {
                        return badDateTimeFormat.parse(value);
                    }
                }
                catch (Exception e2)
                {
                    synchronized (badDateTimeFormat2)
                    {
                        return badDateTimeFormat2.parse(value);
                    }
                }
            }
        }
    }

    /**
     * Represents a single response from the IMAP server. Tagged responses will
     * have a non-null tag. Untagged responses will have a null tag. The object
     * will contain all of the available tokens at the time the response is
     * received. In general, it will either contain all of the tokens of the
     * response or all of the tokens up until the first LITERAL. If the object
     * does not contain the entire response the caller must call more() to
     * continue reading the response until more returns false.
     */
    public class ImapResponse extends ImapList
    {
        /**
         *
         */
        private static final long serialVersionUID = 6886458551615975669L;
        private boolean mCompleted;
        private IImapResponseCallback mCallback;

        boolean mCommandContinuationRequested;
        String mTag;

        public boolean more() throws IOException
        {
            if (mCompleted)
            {
                return false;
            }
            readTokens(this);
            return true;
        }

        public String getAlertText()
        {
            if (size() > 1 && equalsIgnoreCase("[ALERT]", get(1)))
            {
                StringBuffer sb = new StringBuffer();
                for (int i = 2, count = size(); i < count; i++)
                {
                    sb.append(get(i).toString());
                    sb.append(' ');
                }
                return sb.toString();
            }
            else
            {
                return null;
            }
        }

        @Override
        public String toString()
        {
            return "#" + (mCommandContinuationRequested ? "+" : mTag) + "# " + super.toString();
        }
    }

    public static boolean equalsIgnoreCase(Object o1, Object o2)
    {
        if (o1 != null && o2 != null && o1 instanceof String && o2 instanceof String)
        {
            String s1 = (String)o1;
            String s2 = (String)o2;
            return s1.equalsIgnoreCase(s2);
        }
        else if (o1 != null)
        {
            return o1.equals(o2);
        }
        else if (o2 != null)
        {
            return o2.equals(o1);
        }
        else
        {
            // Both o1 and o2 are null
            return true;
        }
    }

    public interface IImapResponseCallback
    {
        /**
         * Callback method that is called by the parser when a literal string
         * is found in an IMAP response.
         *
         * @param response ImapResponse object with the fields that have been
         *                 parsed up until now (excluding the literal string).
         * @param literal  FixedLengthInputStream that can be used to access
         *                 the literal string.
         *
         * @return an Object that will be put in the ImapResponse object at the
         *         place of the literal string.
         *
         * @throws IOException passed-through if thrown by FixedLengthInputStream
         * @throws Exception if something goes wrong. Parsing will be resumed
         *                   and the exception will be thrown after the
         *                   complete IMAP response has been parsed.
         */
        public Object foundLiteral(ImapResponse response, FixedLengthInputStream literal)
        throws IOException, Exception;
    }
}
package mobi.cloudymail.protocol.imap;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.Security;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLException;
import javax.net.ssl.TrustManager;

import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.mailclient.FolderNames;
import mobi.cloudymail.mailclient.R;
import mobi.cloudymail.mailclient.ReceiveMailService;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.protocol.imap.ImapResponseParser.ImapList;
import mobi.cloudymail.protocol.imap.ImapResponseParser.ImapResponse;
import mobi.cloudymail.protocol.imap.TracingPowerManager.TracingWakeLock;
import mobi.cloudymail.util.MyApp;
import mobi.cloudymail.util.NewDbHelper;
import mobi.cloudymail.util.Utils;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.util.Log;

import com.beetstra.jutf7.CharsetProvider;
import com.jcraft.jzlib.JZlib;
import com.jcraft.jzlib.ZInputStream;
import com.jcraft.jzlib.ZOutputStream;

/**
 * <pre>
 * TODO Need to start keeping track of UIDVALIDITY
 * TODO Need a default response handler for things like folder updates
 * </pre>
 */
public class ImapStore extends Store
{
	public static final int CONNECTION_SECURITY_NONE = 0;
	public static final int CONNECTION_SECURITY_TLS_OPTIONAL = 1;
	public static final int CONNECTION_SECURITY_TLS_REQUIRED = 2;
	public static final int CONNECTION_SECURITY_SSL_REQUIRED = 3;
	public static final int CONNECTION_SECURITY_SSL_OPTIONAL = 4;

	public enum AuthType
	{
		PLAIN, CRAM_MD5
	}

	private static final int IDLE_READ_TIMEOUT_INCREMENT = 5 * 60 * 1000;
	private static final int IDLE_FAILURE_COUNT_LIMIT = 10;
	private static int MAX_DELAY_TIME = 5 * 60 * 1000; // 5 minutes
	private static int NORMAL_DELAY_TIME = 5000;

	private static int FETCH_WINDOW_SIZE = 100;

	private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED, Flag.SEEN };

	private static final String CAPABILITY_IDLE = "IDLE";
	private static final String COMMAND_IDLE = "IDLE";
	private static final String CAPABILITY_NAMESPACE = "NAMESPACE";
	private static final String COMMAND_NAMESPACE = "NAMESPACE";

	private static final String CAPABILITY_CAPABILITY = "CAPABILITY";
	private static final String COMMAND_CAPABILITY = "CAPABILITY";

	private static final String CAPABILITY_COMPRESS_DEFLATE = "COMPRESS=DEFLATE";
	private static final String COMMAND_COMPRESS_DEFLATE = "COMPRESS DEFLATE";

	// private static final Message[] EMPTY_MESSAGE_ARRAY = new Message[0];

	private static final String[] EMPTY_STRING_ARRAY = new String[0];

	private String mHost;
	private int mPort;
	private String mUsername;
	private String mPassword;
	private int mConnectionSecurity;
	private AuthType mAuthType;
	private volatile String mPathPrefix;
	private volatile String mCombinedPrefix = null;
	private volatile String mPathDelimeter = null;

	public class StoreImapSettings
	{

		public String getHost()
		{
			return mHost;
		}

		public int getPort()
		{
			return mPort;
		}

		public int getConnectionSecurity()
		{
			return mConnectionSecurity;
		}

		public AuthType getAuthType()
		{
			return mAuthType;
		}

		public String getUsername()
		{
			return mUsername;
		}

		public String getPassword()
		{
			return mPassword;
		}

		public boolean useCompression(final int type)
		{
			// return mAccount.useCompression(type);
			return false;
		}

		public String getPathPrefix()
		{
			return mPathPrefix;
		}

		public void setPathPrefix(String prefix)
		{
			mPathPrefix = prefix;
		}

		public String getPathDelimeter()
		{
			return mPathDelimeter;
		}

		public void setPathDelimeter(String delimeter)
		{
			mPathDelimeter = delimeter;
		}

		public String getCombinedPrefix()
		{
			return mCombinedPrefix;
		}

		public void setCombinedPrefix(String prefix)
		{
			mCombinedPrefix = prefix;
		}

	}

	private static final SimpleDateFormat RFC3501_DATE = new SimpleDateFormat("dd-MMM-yyyy",
																				Locale.US);

	private LinkedList<ImapConnection> mConnections = new LinkedList<ImapConnection>();

	/**
	 * Charset used for converting folder names to and from UTF-7 as defined by
	 * RFC 3501.
	 */
	private Charset mModifiedUtf7Charset;

	/**
	 * Cache of ImapFolder objects. ImapFolders are attached to a given folder
	 * on the server and as long as their associated connection remains open
	 * they are reusable between requests. This cache lets us make sure we
	 * always reuse, if possible, for a given folder name.
	 */
	// private HashMap<String, ImapFolder> mFolderCache = new HashMap<String,
	// ImapFolder>();

	/**
	 * imap://auth:user:password@server:port CONNECTION_SECURITY_NONE
	 * imap+tls://auth:user:password@server:port
	 * CONNECTION_SECURITY_TLS_OPTIONAL
	 * imap+tls+://auth:user:password@server:port
	 * CONNECTION_SECURITY_TLS_REQUIRED
	 * imap+ssl+://auth:user:password@server:port
	 * CONNECTION_SECURITY_SSL_REQUIRED
	 * imap+ssl://auth:user:password@server:port
	 * CONNECTION_SECURITY_SSL_OPTIONAL
	 * 
	 * @param _uri
	 */
	public ImapStore(Account account) throws MessagingException
	{
		super(account);
		mPort = account.getMailPort();
		if (account.useSSL)
			mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
		else
			mConnectionSecurity = CONNECTION_SECURITY_NONE;

		// if (scheme.equals("imap"))
		// {
		// mConnectionSecurity = CONNECTION_SECURITY_NONE;
		// mPort = 143;
		// }
		// else if (scheme.equals("imap+tls"))
		// {
		// mConnectionSecurity = CONNECTION_SECURITY_TLS_OPTIONAL;
		// mPort = 143;
		// }
		// else if (scheme.equals("imap+tls+"))
		// {
		// mConnectionSecurity = CONNECTION_SECURITY_TLS_REQUIRED;
		// mPort = 143;
		// }
		// else if (scheme.equals("imap+ssl+"))
		// {
		// mConnectionSecurity = CONNECTION_SECURITY_SSL_REQUIRED;
		// mPort = 993;
		// }
		// else if (scheme.equals("imap+ssl"))
		// {
		// mConnectionSecurity = CONNECTION_SECURITY_SSL_OPTIONAL;
		// mPort = 993;
		// }
		// else
		// {
		// throw new MessagingException("Unsupported protocol");
		// }

		mHost = account.mailServer;

		mAuthType = AuthType.PLAIN;
		mUsername = account.loginName;
		mPassword = account.password;

		// if (uri.getUserInfo() != null)
		// {
		// try
		// {
		// String[] userInfoParts = uri.getUserInfo().split(":");
		// if (userInfoParts.length == 2)
		// {
		// mAuthType = AuthType.PLAIN;
		// mUsername = URLDecoder.decode(userInfoParts[0], "UTF-8");
		// mPassword = URLDecoder.decode(userInfoParts[1], "UTF-8");
		// }
		// else
		// {
		// mAuthType = AuthType.valueOf(userInfoParts[0]);
		// mUsername = URLDecoder.decode(userInfoParts[1], "UTF-8");
		// mPassword = URLDecoder.decode(userInfoParts[2], "UTF-8");
		// }
		// }
		// catch (UnsupportedEncodingException enc)
		// {
		// // This shouldn't happen since the encoding is hardcoded to UTF-8
		// Log.e(Utils.LOGTAG, "Couldn't urldecode username or password.", enc);
		// }
		// }

		// if ((uri.getPath() != null) && (uri.getPath().length() > 0))
		// {
		// mPathPrefix = uri.getPath().substring(1);
		// if (mPathPrefix != null && mPathPrefix.trim().length() == 0)
		// {
		// mPathPrefix = null;
		// }
		// }

		mModifiedUtf7Charset = new CharsetProvider().charsetForName("X-RFC-3501");
	}

	// @Override
	// public Folder getFolder(String name)
	// {
	// ImapFolder folder;
	// synchronized (mFolderCache)
	// {
	// folder = mFolderCache.get(name);
	// if (folder == null)
	// {
	// folder = new ImapFolder(this, name);
	// mFolderCache.put(name, folder);
	// }
	// }
	// return folder;
	// }

	// private String getCombinedPrefix()
	// {
	// if (mCombinedPrefix == null)
	// {
	// if (mPathPrefix != null)
	// {
	// String tmpPrefix = mPathPrefix.trim();
	// String tmpDelim = (mPathDelimeter != null ? mPathDelimeter.trim() : "");
	// if (tmpPrefix.endsWith(tmpDelim))
	// {
	// mCombinedPrefix = tmpPrefix;
	// }
	// else if (tmpPrefix.length() > 0)
	// {
	// mCombinedPrefix = tmpPrefix + tmpDelim;
	// }
	// else
	// {
	// mCombinedPrefix = "";
	// }
	// }
	// else
	// {
	// mCombinedPrefix = "";
	// }
	// }
	// return mCombinedPrefix;
	// }

	// @Override
	// public List<? extends Folder> getPersonalNamespaces(boolean forceListAll)
	// throws MessagingException
	// {
	// ImapConnection connection = getConnection();
	// try
	// {
	// List<? extends Folder> allFolders = listFolders(connection, false);
	// if (forceListAll || !mAccount.subscribedFoldersOnly())
	// {
	// return allFolders;
	// }
	// else
	// {
	// List<Folder> resultFolders = new LinkedList<Folder>();
	// HashSet<String> subscribedFolderNames = new HashSet<String>();
	// List<? extends Folder> subscribedFolders = listFolders(connection, true);
	// for (Folder subscribedFolder : subscribedFolders)
	// {
	// subscribedFolderNames.add(subscribedFolder.getName());
	// }
	// for (Folder folder : allFolders)
	// {
	// if (subscribedFolderNames.contains(folder.getName()))
	// {
	// resultFolders.add(folder);
	// }
	// }
	// return resultFolders;
	// }
	// }
	// catch (IOException ioe)
	// {
	// connection.close();
	// throw new MessagingException("Unable to get folder list.", ioe);
	// }
	// catch (MessagingException me)
	// {
	// connection.close();
	// throw new MessagingException("Unable to get folder list.", me);
	// }
	// finally
	// {
	// releaseConnection(connection);
	// }
	// }

	// private List<? extends Folder> listFolders(ImapConnection connection,
	// boolean LSUB) throws IOException, MessagingException
	// {
	// String commandResponse = LSUB ? "LSUB" : "LIST";
	//
	// LinkedList<Folder> folders = new LinkedList<Folder>();
	//
	// List<ImapResponse> responses =
	// connection.executeSimpleCommand(String.format(commandResponse +
	// " \"\" %s",
	// encodeString(getCombinedPrefix() + "*")));
	//
	// for (ImapResponse response : responses)
	// {
	// if (ImapResponseParser.equalsIgnoreCase(response.get(0),
	// commandResponse))
	// {
	// boolean includeFolder = true;
	// String folder = decodeFolderName(response.getString(3));
	//
	// if (mPathDelimeter == null)
	// {
	// mPathDelimeter = response.getString(2);
	// mCombinedPrefix = null;
	// }
	//
	// if (folder.equalsIgnoreCase(K9.INBOX))
	// {
	// continue;
	// }
	// else
	// {
	//
	// if (getCombinedPrefix().length() > 0)
	// {
	// if (folder.length() >= getCombinedPrefix().length())
	// {
	// folder = folder.substring(getCombinedPrefix().length());
	// }
	// if
	// (!decodeFolderName(response.getString(3)).equalsIgnoreCase(getCombinedPrefix()
	// + folder))
	// {
	// includeFolder = false;
	// }
	// }
	// }
	//
	// ImapList attributes = response.getList(1);
	// for (int i = 0, count = attributes.size(); i < count; i++)
	// {
	// String attribute = attributes.getString(i);
	// if (attribute.equalsIgnoreCase("\\NoSelect"))
	// {
	// includeFolder = false;
	// }
	// }
	// if (includeFolder)
	// {
	// folders.add(getFolder(folder));
	// }
	// }
	// }
	// folders.add(getFolder("INBOX"));
	// return folders;
	//
	// }

	@Override
	public void checkSettings() throws MessagingException
	{
		try
		{
			ImapConnection connection = new ImapConnection(new StoreImapSettings());
			connection.open();
			connection.close();
		}
		catch (IOException ioe)
		{
			throw new MessagingException(MyApp.instance()
					.getString(R.string.fl_cannotConnectServer), ioe);
		}
	}

	/**
	 * Gets a connection if one is available for reuse, or creates a new one if
	 * not.
	 * 
	 * @return
	 */
	private ImapConnection getConnection() throws MessagingException
	{
		synchronized (mConnections)
		{
			ImapConnection connection = null;
			while ((connection = mConnections.poll()) != null)
			{
				try
				{
					connection.executeSimpleCommand("NOOP");
					break;
				}
				catch (IOException ioe)
				{
					connection.close();
				}
			}
			if (connection == null)
			{
				connection = new ImapConnection(new StoreImapSettings());
			}
			return connection;
		}
	}

	private void releaseConnection(ImapConnection connection)
	{
		if (connection != null && connection.isOpen())
		{
			synchronized (mConnections)
			{
				mConnections.offer(connection);
			}
		}
	}

/**
     * Encode a string to be able to use it in an IMAP command.
     *
     * "A quoted string is a sequence of zero or more 7-bit characters,
     *  excluding CR and LF, with double quote (<">) characters at each
     *  end." - Section 4.3, RFC 3501
     *
     * Double quotes and backslash are escaped by prepending a backslash.
     *
     * @param str
     *     The input string (only 7-bit characters allowed).
     * @return
     *     The string encoded as quoted (IMAP) string.
     */
	private static String encodeString(String str)
	{
		return "\"" + str.replace("\\", "\\\\").replace("\"", "\\\"") + "\"";
	}

	private String encodeFolderName(String name)
	{
		try
		{
			ByteBuffer bb = mModifiedUtf7Charset.encode(name);
			byte[] b = new byte[bb.limit()];
			bb.get(b);
			return new String(b, "US-ASCII");
		}
		catch (UnsupportedEncodingException uee)
		{
			/*
			 * The only thing that can throw this is getBytes("US-ASCII") and if
			 * US-ASCII doesn't exist we're totally screwed.
			 */
			throw new RuntimeException("Unable to encode folder name: " + name, uee);
		}
	}

	private String decodeFolderName(String name)
	{
		/*
		 * Convert the encoded name to US-ASCII, then pass it through the
		 * modified UTF-7 decoder and return the Unicode String.
		 */
		try
		{
			byte[] encoded = name.getBytes("US-ASCII");
			CharBuffer cb = mModifiedUtf7Charset.decode(ByteBuffer.wrap(encoded));
			return cb.toString();
		}
		catch (UnsupportedEncodingException uee)
		{
			/*
			 * The only thing that can throw this is getBytes("US-ASCII") and if
			 * US-ASCII doesn't exist we're totally screwed.
			 */
			throw new RuntimeException("Unable to decode folder name: " + name, uee);
		}
	}

	//
	// @Override
	// public boolean isMoveCapable()
	// {
	// return true;
	// }
	//
	// @Override
	// public boolean isCopyCapable()
	// {
	// return true;
	// }

	public boolean isPushCapable()
	{
		return true;
	}

	// @Override
	// public boolean isExpungeCapable()
	// {
	// return true;
	// }

	public Pusher getPusher(PushReceiver receiver)
	{
		return new ImapPusher(this, receiver);
	}

	public class ImapPusher implements Pusher
	{
		final ImapStore mStore;
		final PushReceiver mReceiver;
		private long lastRefresh = -1;

		HashMap<String, ImapFolderPusher> folderPushers = new HashMap<String, ImapFolderPusher>();

		public ImapPusher(ImapStore store, PushReceiver receiver)
		{
			mStore = store;
			mReceiver = receiver;
		}

		public void start(List<String> folderNames)
		{
			stop();
			synchronized (folderPushers)
			{
				setLastRefresh(System.currentTimeMillis());
				for (String folderName : folderNames)
				{
					ImapFolderPusher pusher = folderPushers.get(folderName);
					if (pusher == null)
					{
						pusher = new ImapFolderPusher(mStore, folderName, mReceiver);
						folderPushers.put(folderName, pusher);
						pusher.start();
					}
				}
			}
		}

		public void refresh()
		{
			synchronized (folderPushers)
			{
				for (ImapFolderPusher folderPusher : folderPushers.values())
				{
					try
					{
						folderPusher.refresh();
					}
					catch (Exception e)
					{
						Log.e(	K9.LOG_TAG,
								"Got exception while refreshing for " + folderPusher.getName(), e);
					}
				}
			}
		}

		public void stop()
		{
			if (K9.DEBUG)
				Log.i(K9.LOG_TAG, "Requested stop of IMAP pusher");

			synchronized (folderPushers)
			{
				for (ImapFolderPusher folderPusher : folderPushers.values())
				{
					try
					{
						if (K9.DEBUG)
							Log.i(K9.LOG_TAG, "Requesting stop of IMAP folderPusher "
												+ folderPusher.getName());
						folderPusher.stop();
					}
					catch (Exception e)
					{
						Log.e(	K9.LOG_TAG,
								"Got exception while stopping " + folderPusher.getName(),
								e);
					}
				}
				folderPushers.clear();
			}
		}

		public int getRefreshInterval()
		{
			return (getAccount().getIdleRefreshMinutes() * 60 * 1000);
		}

		public long getLastRefresh()
		{
			return lastRefresh;
		}

		public void setLastRefresh(long lastRefresh)
		{
			this.lastRefresh = lastRefresh;
		}

	}

	private interface UntaggedHandler
	{
		void handleAsyncUntaggedResponse(ImapResponse respose);
	}

	protected static class ImapPushState
	{
		protected int uidNext;

		protected ImapPushState(int nUidNext)
		{
			uidNext = nUidNext;
		}

		protected static ImapPushState parse(String pushState)
		{
			int newUidNext = -1;
			if (pushState != null)
			{
				StringTokenizer tokenizer = new StringTokenizer(pushState, ";");
				while (tokenizer.hasMoreTokens())
				{
					StringTokenizer thisState = new StringTokenizer(tokenizer.nextToken(), "=");
					if (thisState.hasMoreTokens())
					{
						String key = thisState.nextToken();

						if ("uidNext".equalsIgnoreCase(key) && thisState.hasMoreTokens())
						{
							String value = thisState.nextToken();
							try
							{
								newUidNext = Integer.parseInt(value);
							}
							catch (Exception e)
							{
								Log.e(K9.LOG_TAG, "Unable to part uidNext value " + value, e);
							}

						}
					}
				}
			}
			return new ImapPushState(newUidNext);
		}

		@Override
		public String toString()
		{
			return "uidNext=" + uidNext;
		}

	}

	/**
	 * A cacheable class that stores the details for a single IMAP connection.
	 */
	public static class ImapConnection
	{
		protected Socket mSocket;
		protected PeekableInputStream mIn;
		protected OutputStream mOut;
		protected ImapResponseParser mParser;
		protected int mNextCommandTag;
		protected Set<String> capabilities = new HashSet<String>();

		private StoreImapSettings mSettings;

		public ImapConnection(final StoreImapSettings settings)
		{
			this.mSettings = settings;
		}

		protected String getLogId()
		{
			return "conn" + hashCode();
		}

		private List<ImapResponse> receiveCapabilities(List<ImapResponse> responses)
		{
			for (ImapResponse response : responses)
			{
				ImapList capabilityList = null;
				if (response.size() > 0
					&& ImapResponseParser.equalsIgnoreCase(response.get(0), "OK"))
				{
					for (Object thisPart : response)
					{
						if (thisPart instanceof ImapList)
						{
							ImapList thisList = (ImapList) thisPart;
							if (ImapResponseParser.equalsIgnoreCase(thisList.get(0),
																	CAPABILITY_CAPABILITY))
							{
								capabilityList = thisList;
								break;
							}
						}
					}
				}
				else if (response.mTag == null)
				{
					capabilityList = response;
				}

				if (capabilityList != null)
				{
					if (capabilityList.size() > 0
						&& ImapResponseParser.equalsIgnoreCase(	capabilityList.get(0),
																CAPABILITY_CAPABILITY))
					{
						if (K9.DEBUG)
						{
							Log.d(K9.LOG_TAG, "Saving " + capabilityList.size()
												+ " capabilities for " + getLogId());
						}
						for (Object capability : capabilityList)
						{
							if (capability instanceof String)
							{
								// if (K9.DEBUG)
								// {
								// Log.v(K9.LOG_TAG, "Saving capability '" +
								// capability + "' for " + getLogId());
								// }
								capabilities.add(((String) capability).toUpperCase());
							}
						}

					}
				}
			}
			return responses;
		}

		public void open() throws IOException, MessagingException
		{
			if (isOpen())
			{
				return;
			}

			boolean authSuccess = false;

			mNextCommandTag = 1;
			try
			{
				Security.setProperty("networkaddress.cache.ttl", "0");
			}
			catch (Exception e)
			{
				Log.w(K9.LOG_TAG, "Could not set DNS ttl to 0 for " + getLogId(), e);
			}

			try
			{
				Security.setProperty("networkaddress.cache.negative.ttl", "0");
			}
			catch (Exception e)
			{
				Log.w(K9.LOG_TAG, "Could not set DNS negative ttl to 0 for " + getLogId(), e);
			}

			try
			{

				SocketAddress socketAddress = new InetSocketAddress(mSettings.getHost(),
																	mSettings.getPort());

				if (K9.DEBUG)
					Log.i(	K9.LOG_TAG,
							"Connection " + getLogId() + " connecting to " + mSettings.getHost()
									+ " @ IP addr " + socketAddress);

				if (mSettings.getConnectionSecurity() == CONNECTION_SECURITY_SSL_REQUIRED
					|| mSettings.getConnectionSecurity() == CONNECTION_SECURITY_SSL_OPTIONAL)
				{
					SSLContext sslContext = SSLContext.getInstance("TLS");
					final boolean secure = false;//mSettings.getConnectionSecurity() == CONNECTION_SECURITY_SSL_REQUIRED;
					sslContext.init(null, new TrustManager[] { TrustManagerFactory.get(mSettings
							.getHost(), secure) }, new SecureRandom());
					mSocket = sslContext.getSocketFactory().createSocket();
					mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
				}
				else
				{
					mSocket = new Socket();
					mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
				}

				setReadTimeout(Store.SOCKET_READ_TIMEOUT);

				mIn = new PeekableInputStream(new BufferedInputStream(mSocket.getInputStream(),
																		1024));
				mParser = new ImapResponseParser(mIn);
				mOut = mSocket.getOutputStream();

				capabilities.clear();
				ImapResponse nullResponse = mParser.readResponse();
				if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
					Log.v(K9.LOG_TAG, getLogId() + "<<<" + nullResponse);

				List<ImapResponse> nullResponses = new LinkedList<ImapResponse>();
				nullResponses.add(nullResponse);
				receiveCapabilities(nullResponses);

				if (!hasCapability(CAPABILITY_CAPABILITY))
				{
					if (K9.DEBUG)
						Log.i(	K9.LOG_TAG,
								"Did not get capabilities in banner, requesting CAPABILITY for "
										+ getLogId());
					List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
					if (responses.size() != 2)
					{
						throw new MessagingException("Invalid CAPABILITY response received");
					}
				}

				if (mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_OPTIONAL
					|| mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_REQUIRED)
				{

					if (hasCapability("STARTTLS"))
					{
						// STARTTLS
						executeSimpleCommand("STARTTLS");

						SSLContext sslContext = SSLContext.getInstance("TLS");
						boolean secure = mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_REQUIRED;
						sslContext.init(null, new TrustManager[] { TrustManagerFactory
								.get(mSettings.getHost(), secure) }, new SecureRandom());
						mSocket = sslContext.getSocketFactory()
								.createSocket(mSocket, mSettings.getHost(), mSettings.getPort(),
												true);
						mSocket.setSoTimeout(Store.SOCKET_READ_TIMEOUT);
						mIn = new PeekableInputStream(
														new BufferedInputStream(mSocket
																.getInputStream(), 1024));
						mParser = new ImapResponseParser(mIn);
						mOut = mSocket.getOutputStream();
					}
					else if (mSettings.getConnectionSecurity() == CONNECTION_SECURITY_TLS_REQUIRED)
					{
						throw new MessagingException("TLS not supported but required");
					}
				}

				mOut = new BufferedOutputStream(mOut, 1024);

				try
				{
					// Yahoo! requires a custom IMAP command to work right over
					// a non-3G network
					if (mSettings.getHost().endsWith("yahoo.com"))
					{
						if (K9.DEBUG)
							Log.v(	K9.LOG_TAG,
									"Found Yahoo! account.  Sending proprietary commands.");
						executeSimpleCommand("ID (\"GUID\" \"1\")");
					}
					if (mSettings.getAuthType() == AuthType.CRAM_MD5)
					{
						authCramMD5();
						// The authCramMD5 method called on the previous line
						// does not allow for handling updated capabilities
						// sent by the server. So, to make sure we update to the
						// post-authentication capability list
						// we fetch the capabilities here.
						if (K9.DEBUG)
							Log.i(	K9.LOG_TAG,
									"Updating capabilities after CRAM-MD5 authentication for "
											+ getLogId());
						List<ImapResponse> responses = receiveCapabilities(executeSimpleCommand(COMMAND_CAPABILITY));
						if (responses.size() != 2)
						{
							throw new MessagingException("Invalid CAPABILITY response received");
						}

					}
					else if (mSettings.getAuthType() == AuthType.PLAIN)
					{
						receiveCapabilities(executeSimpleCommand(	String.format(	"LOGIN %s %s",
																					ImapStore
																							.encodeString(mSettings
																									.getUsername()),
																					ImapStore
																							.encodeString(mSettings
																									.getPassword())),
																	true));
					}
					authSuccess = true;
				}
				catch (ImapException ie)
				{
					throw new AuthenticationFailedException(ie.getAlertText(), ie);

				}
				catch (MessagingException me)
				{
					throw new AuthenticationFailedException(null, me);
				}
				if (K9.DEBUG)
				{
					Log.d(K9.LOG_TAG, CAPABILITY_COMPRESS_DEFLATE + " = "
										+ hasCapability(CAPABILITY_COMPRESS_DEFLATE));
				}
				if (hasCapability(CAPABILITY_COMPRESS_DEFLATE))
				{
					ConnectivityManager connectivityManager = (ConnectivityManager) MyApp
							.instance().getSystemService(Context.CONNECTIVITY_SERVICE);
					boolean useCompression = true;

					NetworkInfo netInfo = connectivityManager.getActiveNetworkInfo();
					if (netInfo != null)
					{
						int type = netInfo.getType();
						if (K9.DEBUG)
							Log.d(K9.LOG_TAG, "On network type " + type);
						useCompression = mSettings.useCompression(type);

					}
					if (K9.DEBUG)
						Log.d(K9.LOG_TAG, "useCompression " + useCompression);
					if (useCompression)
					{
						try
						{
							executeSimpleCommand(COMMAND_COMPRESS_DEFLATE);
							ZInputStream zInputStream = new ZInputStream(mSocket.getInputStream(),
																			true);
							zInputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
							mIn = new PeekableInputStream(new BufferedInputStream(zInputStream,
																					1024));
							mParser = new ImapResponseParser(mIn);
							ZOutputStream zOutputStream = new ZOutputStream(
																			mSocket.getOutputStream(),
																			JZlib.Z_BEST_SPEED,
																			true);
							mOut = new BufferedOutputStream(zOutputStream, 1024);
							zOutputStream.setFlushMode(JZlib.Z_PARTIAL_FLUSH);
							if (K9.DEBUG)
							{
								Log.i(K9.LOG_TAG, "Compression enabled for " + getLogId());
							}
						}
						catch (Exception e)
						{
							Log.e(K9.LOG_TAG, "Unable to negotiate compression", e);
						}
					}
				}

				if (K9.DEBUG)
					Log.d(K9.LOG_TAG, "NAMESPACE = " + hasCapability(CAPABILITY_NAMESPACE));

				if (mSettings.getPathPrefix() == null)
				{
					if (hasCapability(CAPABILITY_NAMESPACE))
					{
						if (K9.DEBUG)
							Log.i(	K9.LOG_TAG,
									"mPathPrefix is unset and server has NAMESPACE capability");
						List<ImapResponse> namespaceResponses = executeSimpleCommand(COMMAND_NAMESPACE);
						for (ImapResponse response : namespaceResponses)
						{
							if (ImapResponseParser.equalsIgnoreCase(response.get(0),
																	COMMAND_NAMESPACE))
							{
								if (K9.DEBUG)
									Log.d(K9.LOG_TAG, "Got NAMESPACE response " + response + " on "
														+ getLogId());

								Object personalNamespaces = response.get(1);
								if (personalNamespaces != null
									&& personalNamespaces instanceof ImapList)
								{
									if (K9.DEBUG)
										Log.d(K9.LOG_TAG, "Got personal namespaces: "
															+ personalNamespaces);
									ImapList bracketed = (ImapList) personalNamespaces;
									Object firstNamespace = bracketed.get(0);
									if (firstNamespace != null
										&& firstNamespace instanceof ImapList)
									{
										if (K9.DEBUG)
											Log.d(K9.LOG_TAG, "Got first personal namespaces: "
																+ firstNamespace);
										bracketed = (ImapList) firstNamespace;
										mSettings.setPathPrefix(bracketed.getString(0));
										mSettings.setPathDelimeter(bracketed.getString(1));
										mSettings.setCombinedPrefix(null);
										if (K9.DEBUG)
											Log.d(	K9.LOG_TAG,
													"Got path '" + mSettings.getPathPrefix()
															+ "' and separator '"
															+ mSettings.getPathDelimeter() + "'");
									}
								}
							}
						}
					}
					else
					{
						if (K9.DEBUG)
							Log.i(	K9.LOG_TAG,
									"mPathPrefix is unset but server does not have NAMESPACE capability");
						mSettings.setPathPrefix("");
					}
				}
				if (mSettings.getPathDelimeter() == null)
				{
					try
					{
						List<ImapResponse> nameResponses = executeSimpleCommand(String
								.format("LIST \"\" \"\""));
						for (ImapResponse response : nameResponses)
						{
							if (ImapResponseParser.equalsIgnoreCase(response.get(0), "LIST"))
							{
								mSettings.setPathDelimeter(response.getString(2));
								mSettings.setCombinedPrefix(null);
								if (K9.DEBUG)
									Log.d(	K9.LOG_TAG,
											"Got path delimeter '" + mSettings.getPathDelimeter()
													+ "' for " + getLogId());
							}
						}
					}
					catch (Exception e)
					{
						Log.e(K9.LOG_TAG, "Unable to get path delimeter using LIST", e);
					}
				}

			}
			catch (SSLException e)
			{
				throw new CertificateValidationException(e.getMessage(), e);
			}
			catch (GeneralSecurityException gse)
			{
				throw new MessagingException(
												"Unable to open connection to IMAP server due to security error.",
												gse);
			}
			catch (ConnectException ce)
			{
				String ceMess = ce.getMessage();
				String[] tokens = ceMess.split("-");
				if (tokens != null && tokens.length > 1 && tokens[1] != null)
				{
					Log.e(K9.LOG_TAG, "Stripping host/port from ConnectionException for "
										+ getLogId(), ce);
					throw new ConnectException(tokens[1].trim());
				}
				else
				{
					throw ce;
				}
			}
			finally
			{
				if (!authSuccess)
				{
					Log.e(K9.LOG_TAG, "Failed to login, closing connection for " + getLogId());
					close();
				}
			}
		}

		protected void authCramMD5() throws AuthenticationFailedException, MessagingException
		{
			try
			{
				String tag = sendCommand("AUTHENTICATE CRAM-MD5", false);
				byte[] buf = new byte[1024];
				int b64NonceLen = 0;
				for (int i = 0; i < buf.length; i++)
				{
					buf[i] = (byte) mIn.read();
					if (buf[i] == 0x0a)
					{
						b64NonceLen = i;
						break;
					}
				}
				if (b64NonceLen == 0)
				{
					throw new AuthenticationFailedException(
															"Error negotiating CRAM-MD5: nonce too long.");
				}
				byte[] b64NonceTrim = new byte[b64NonceLen - 2];
				System.arraycopy(buf, 1, b64NonceTrim, 0, b64NonceLen - 2);
				byte[] nonce = Base64.decodeBase64(b64NonceTrim);
				if (K9.DEBUG)
				{
					Log.d(K9.LOG_TAG, "Got nonce: " + new String(b64NonceTrim, "US-ASCII"));
					Log.d(K9.LOG_TAG, "Plaintext nonce: " + new String(nonce, "US-ASCII"));
				}

				byte[] ipad = new byte[64];
				byte[] opad = new byte[64];
				byte[] secretBytes = mSettings.getPassword().getBytes("US-ASCII");
				MessageDigest md = MessageDigest.getInstance("MD5");
				if (secretBytes.length > 64)
				{
					secretBytes = md.digest(secretBytes);
				}
				System.arraycopy(secretBytes, 0, ipad, 0, secretBytes.length);
				System.arraycopy(secretBytes, 0, opad, 0, secretBytes.length);
				for (int i = 0; i < ipad.length; i++)
					ipad[i] ^= 0x36;
				for (int i = 0; i < opad.length; i++)
					opad[i] ^= 0x5c;
				md.update(ipad);
				byte[] firstPass = md.digest(nonce);
				md.update(opad);
				byte[] result = md.digest(firstPass);
				String plainCRAM = mSettings.getUsername() + " "
									+ new String(Hex.encodeHex(result));
				byte[] b64CRAM = Base64.encodeBase64(plainCRAM.getBytes("US-ASCII"));
				if (K9.DEBUG)
				{
					Log.d(K9.LOG_TAG, "Username == " + mSettings.getUsername());
					Log.d(K9.LOG_TAG, "plainCRAM: " + plainCRAM);
					Log.d(K9.LOG_TAG, "b64CRAM: " + new String(b64CRAM, "US-ASCII"));
				}

				mOut.write(b64CRAM);
				mOut.write(new byte[] { 0x0d, 0x0a });
				mOut.flush();
				int respLen = 0;
				for (int i = 0; i < buf.length; i++)
				{
					buf[i] = (byte) mIn.read();
					if (buf[i] == 0x0a)
					{
						respLen = i;
						break;
					}
				}
				String toMatch = tag + " OK";
				String respStr = new String(buf, 0, respLen);
				if (!respStr.startsWith(toMatch))
				{
					throw new AuthenticationFailedException("CRAM-MD5 error: " + respStr);
				}
			}
			catch (IOException ioe)
			{
				throw new AuthenticationFailedException("CRAM-MD5 Auth Failed.");
			}
			catch (NoSuchAlgorithmException nsae)
			{
				throw new AuthenticationFailedException("MD5 Not Available.");
			}
		}

		protected void setReadTimeout(int millis) throws SocketException
		{
			Socket sock = mSocket;
			if (sock != null)
			{
				sock.setSoTimeout(millis);
			}
		}

		protected boolean isIdleCapable()
		{
			if (K9.DEBUG)
				Log.v(K9.LOG_TAG, "Connection " + getLogId() + " has " + capabilities.size()
									+ " capabilities");

			return capabilities.contains(CAPABILITY_IDLE);
		}

		protected boolean hasCapability(String capability)
		{
			return capabilities.contains(capability.toUpperCase());
		}

		public boolean isOpen()
		{
			return (mIn != null && mOut != null && mSocket != null && mSocket.isConnected() && !mSocket
					.isClosed());
		}

		public void close()
		{
			// if (isOpen()) {
			// try {
			// executeSimpleCommand("LOGOUT");
			// } catch (Exception e) {
			//
			// }
			// }
			try
			{
				mIn.close();
			}
			catch (Exception e)
			{

			}
			try
			{
				mOut.close();
			}
			catch (Exception e)
			{

			}
			try
			{
				mSocket.close();
			}
			catch (Exception e)
			{

			}
			mIn = null;
			mOut = null;
			mSocket = null;
		}

		public ImapResponse readResponse() throws IOException, MessagingException
		{
			return readResponse(null);
		}

		public ImapResponse readResponse(ImapResponseParser.IImapResponseCallback callback)
				throws IOException
		{
			try
			{
				ImapResponse response = mParser.readResponse(callback);
				if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
					Log.v(K9.LOG_TAG, getLogId() + "<<<" + response);

				return response;
			}
			catch (IOException ioe)
			{
				close();
				throw ioe;
			}
		}

		public void sendContinuation(String continuation) throws IOException
		{
			mOut.write(continuation.getBytes());
			mOut.write('\r');
			mOut.write('\n');
			mOut.flush();

			if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
				Log.v(K9.LOG_TAG, getLogId() + ">>> " + continuation);

		}

		public String sendCommand(String command, boolean sensitive) throws MessagingException,
				IOException
		{
			try
			{
				open();
				String tag = Integer.toString(mNextCommandTag++);
				String commandToSend = tag + " " + command;
				mOut.write(commandToSend.getBytes());
				mOut.write('\r');
				mOut.write('\n');
				mOut.flush();

				if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
				{
					if (sensitive && !K9.DEBUG_SENSITIVE)
					{
						Log.v(	K9.LOG_TAG,
								getLogId()
										+ ">>> "
										+ "[Command Hidden, Enable Sensitive Debug Logging To Show]");
					}
					else
					{
						Log.v(K9.LOG_TAG, getLogId() + ">>> " + commandToSend);
					}
				}

				return tag;
			}
			catch (IOException ioe)
			{
				close();
				throw ioe;
			}
			catch (ImapException ie)
			{
				close();
				throw ie;
			}
			catch (MessagingException me)
			{
				close();
				throw me;
			}
		}

		public List<ImapResponse> executeSimpleCommand(String command) throws IOException,
				ImapException, MessagingException
		{
			return executeSimpleCommand(command, false);
		}

		public List<ImapResponse> executeSimpleCommand(String command, boolean sensitive)
				throws IOException, ImapException, MessagingException
		{
			return executeSimpleCommand(command, sensitive, null);
		}

		public List<ImapResponse> executeSimpleCommand(String command, boolean sensitive,
				UntaggedHandler untaggedHandler) throws IOException, ImapException,
				MessagingException
		{
			String commandToLog = command;
			if (sensitive && !K9.DEBUG_SENSITIVE)
			{
				commandToLog = "*sensitive*";
			}

			// if (K9.DEBUG)
			// Log.v(K9.LOG_TAG, "Sending IMAP command " + commandToLog +
			// " on connection " + getLogId());

			String tag = sendCommand(command, sensitive);
			// if (K9.DEBUG)
			// Log.v(K9.LOG_TAG, "Sent IMAP command " + commandToLog +
			// " with tag " + tag + " for " + getLogId());

			ArrayList<ImapResponse> responses = new ArrayList<ImapResponse>();
			ImapResponse response;
			do
			{
				response = mParser.readResponse();
				if (K9.DEBUG && K9.DEBUG_PROTOCOL_IMAP)
					Log.v(K9.LOG_TAG, getLogId() + "<<<" + response);

				if (response.mTag != null && !response.mTag.equalsIgnoreCase(tag))
				{
					Log.w(K9.LOG_TAG, "After sending tag " + tag
										+ ", got tag response from previous command " + response
										+ " for " + getLogId());
					Iterator<ImapResponse> iter = responses.iterator();
					while (iter.hasNext())
					{
						ImapResponse delResponse = iter.next();
						if (delResponse.mTag != null
							|| delResponse.size() < 2
							|| (!ImapResponseParser.equalsIgnoreCase(delResponse.get(1), "EXISTS") && !ImapResponseParser
									.equalsIgnoreCase(delResponse.get(1), "EXPUNGE")))
						{
							iter.remove();
						}
					}
					response.mTag = null;
					continue;
				}
				if (untaggedHandler != null)
				{
					untaggedHandler.handleAsyncUntaggedResponse(response);
				}
				responses.add(response);
			} while (response.mTag == null);
			if (response.size() < 1 || !ImapResponseParser.equalsIgnoreCase(response.get(0), "OK"))
			{
				throw new ImapException("Command: " + commandToLog + "; response: "
										+ response.toString(), response.getAlertText());
			}
			return responses;
		}
	}

	public class ImapFolderPusher extends ImapFolder implements UntaggedHandler
	{
		final PushReceiver receiver;
		Thread listeningThread = null;
		final AtomicBoolean stop = new AtomicBoolean(false);
		final AtomicBoolean idling = new AtomicBoolean(false);
		final AtomicBoolean doneSent = new AtomicBoolean(false);
		final AtomicInteger delayTime = new AtomicInteger(NORMAL_DELAY_TIME);
		final AtomicInteger idleFailureCount = new AtomicInteger(0);
		final AtomicBoolean needsPoll = new AtomicBoolean(false);
//		List<ImapResponse> storedUntaggedResponses = new ArrayList<ImapResponse>();
		TracingWakeLock wakeLock = null;

		public ImapFolderPusher(ImapStore store, String name, PushReceiver nReceiver)
		{
			super(store, name);
			receiver = nReceiver;
			TracingPowerManager pm = TracingPowerManager.getPowerManager(receiver.getContext());
//			wakeLock = pm.newWakeLock(	PowerManager.PARTIAL_WAKE_LOCK,
//										"ImapFolderPusher " + store.getAccount().name + ":"
//												+ getName());
//			wakeLock.setReferenceCounted(false);

		}

		public void refresh() throws IOException, MessagingException
		{
			if (idling.get())
			{
//				wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
				sendDone();
			}
		}

		private void sendDone() throws IOException, MessagingException
		{
			if (doneSent.compareAndSet(false, true))
			{
				ImapConnection conn = mConnection;
				if (conn != null)
				{
					conn.setReadTimeout(Store.SOCKET_READ_TIMEOUT);
					sendContinuation("DONE");
				}

			}
		}

		private void sendContinuation(String continuation) throws IOException
		{
			ImapConnection conn = mConnection;
			if (conn != null)
			{
				conn.sendContinuation(continuation);
			}
		}

		public void start()
		{
			Runnable runner = new Runnable() {
				public void run()
				{
//					wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
					if (K9.DEBUG)
						Log.i(K9.LOG_TAG, "Pusher starting for " + getLogId());
					Thread.currentThread().setName("IDLE_"+getAccount().name);
					while (!stop.get())
					{
						try
						{
							int oldUidNext = uidNext;
							int oldMessageCount = mMessageCount;
							
							
							internalOpen(OpenMode.READ_ONLY);
							ImapConnection conn = mConnection;
							if (conn == null)
							{
								receiver.pushError("Could not establish connection for IDLE", null);
								throw new MessagingException(
																"Could not establish connection for IDLE");

							}
							if (!conn.isIdleCapable())
							{
								stop.set(true);
								receiver.pushError(	"IMAP server is not IDLE capable: "
															+ conn.toString(), null);
								throw new MessagingException("IMAP server is not IDLE capable:"
																+ conn.toString());
							}

							
							if (stop.get())
							{
								continue;
							}


							if (K9.DEBUG)
								Log.i(K9.LOG_TAG, "About to IDLE for " + getLogId());

							idling.set(true);
							doneSent.set(false);

							conn.setReadTimeout((getAccount().getIdleRefreshMinutes() * 60 * 1000)
												+ IDLE_READ_TIMEOUT_INCREMENT);
							executeSimpleCommand(	COMMAND_IDLE, false, ImapFolderPusher.this);
							idling.set(false);
							delayTime.set(NORMAL_DELAY_TIME);
							idleFailureCount.set(0);
							

							if (uidNext > oldUidNext || oldMessageCount != mMessageCount)
							{
								Log.d(Utils.LOGTAG, "IDLE push inited, oldCount="+oldMessageCount+" newCount="+mMessageCount);
								ReceiveMailService.SyncRequest r = new ReceiveMailService.SyncRequest();
								Vector<Account> v = new Vector<Account>(1);
								v.add(getAccount());
								r.setAccountsToSync(v);
								ReceiveMailService.addToSyncQueue(r);
							}
						}
						catch (Exception e)
						{
							Log.e(Utils.LOGTAG, "Error in IDLEing", e);
							try
							{
								Thread.sleep(60*1000); //sleep 1 minutes, so we will not repeat same error rapidly 
							}
							catch (InterruptedException e1)
							{
								// TODO Auto-generated catch block
								e1.printStackTrace();
							}
						}
					}
					receiver.setPushActive(getName(), false);
					try
					{
						if (K9.DEBUG)
							Log.i(K9.LOG_TAG, "Pusher for " + getLogId() + " is exiting");
						close();
					}
					catch (Exception me)
					{
						Log.e(K9.LOG_TAG, "Got exception while closing for " + getLogId(), me);
					}
					finally
					{
//						wakeLock.release();
					}
				}
			};
			listeningThread = new Thread(runner);
			listeningThread.start();
		}

//		@Override
//		protected void handleUntaggedResponse(ImapResponse response)
//		{
//			if (response.mTag == null && response.size() > 1)
//			{
//				Object responseType = response.get(1);
//				if (ImapResponseParser.equalsIgnoreCase(responseType, "FETCH")
//					|| ImapResponseParser.equalsIgnoreCase(responseType, "EXPUNGE")
//					|| ImapResponseParser.equalsIgnoreCase(responseType, "EXISTS"))
//				{
//					if (K9.DEBUG)
//						Log.d(K9.LOG_TAG, "Storing response " + response + " for later processing");
//
//					storedUntaggedResponses.add(response);
//				}
//				handlePossibleUidNext(response);
//			}
//		}

//		protected void processUntaggedResponses(List<ImapResponse> responses)
//				throws MessagingException
//		{
			// boolean skipSync = false;
			// int oldMessageCount = mMessageCount;
			// if (oldMessageCount == -1)
			// {
			// skipSync = true;
			// }
			// List<Integer> flagSyncMsgSeqs = new ArrayList<Integer>();
			// List<String> removeMsgUids = new LinkedList<String>();
			//
//			for (ImapResponse response : responses)
//			{
//				processUntaggedResponse(	oldMessageCount, response,
//															flagSyncMsgSeqs, removeMsgUids);
//			}
			// if (!skipSync)
			// {
			// if (oldMessageCount < 0)
			// {
			// oldMessageCount = 0;
			// }
			// if (mMessageCount > oldMessageCount)
			// {
			// syncMessages(mMessageCount, true);
			// }
			// }
			// if (K9.DEBUG)
			// Log.d(K9.LOG_TAG, "UIDs for messages needing flag sync are " +
			// flagSyncMsgSeqs + "  for " + getLogId());
			//
			// if (flagSyncMsgSeqs.size() > 0)
			// {
			// syncMessages(flagSyncMsgSeqs);
			// }
			// if (removeMsgUids.size() > 0)
			// {
			// removeMessages(removeMsgUids);
			// }
//		}

		// private void syncMessages(int end, boolean newArrivals) throws
		// MessagingException
		// {
		// int oldUidNext = -1;
		// try
		// {
		// String pushStateS = receiver.getPushState(getName());
		// ImapPushState pushState = ImapPushState.parse(pushStateS);
		// oldUidNext = pushState.uidNext;
		// if (K9.DEBUG)
		// Log.i(K9.LOG_TAG, "Got oldUidNext " + oldUidNext + " for " +
		// getLogId());
		// }
		// catch (Exception e)
		// {
		// Log.e(K9.LOG_TAG, "Unable to get oldUidNext for " + getLogId(), e);
		// }
		//
		// Message[] messageArray = getMessages(end, end, null, true, null);
		// if (messageArray != null && messageArray.length > 0)
		// {
		// int newUid = Integer.parseInt(messageArray[0].getUid());
		// if (K9.DEBUG)
		// Log.i(K9.LOG_TAG, "Got newUid " + newUid + " for message " + end +
		// " on " + getLogId());
		// int startUid = oldUidNext;
		// if (startUid < newUid - 10)
		// {
		// startUid = newUid - 10;
		// }
		// if (startUid < 1)
		// {
		// startUid = 1;
		// }
		// if (newUid >= startUid)
		// {
		//
		// if (K9.DEBUG)
		// Log.i(K9.LOG_TAG, "Needs sync from uid " + startUid + " to " + newUid
		// + " for " + getLogId());
		// List<Message> messages = new ArrayList<Message>();
		// for (int uid = startUid; uid <= newUid; uid++)
		// {
		// ImapMessage message = new ImapMessage("" + uid,
		// ImapFolderPusher.this);
		// messages.add(message);
		// }
		// if (messages.size() > 0)
		// {
		// pushMessages(messages, true);
		// }
		// }
		// }
		// }

		// private void syncMessages(List<Integer> flagSyncMsgSeqs)
		// {
		// try
		// {
		// Message[] messageArray = null;
		//
		// messageArray = getMessages(flagSyncMsgSeqs, true, null);
		//
		// List<Message> messages = new ArrayList<Message>();
		// messages.addAll(Arrays.asList(messageArray));
		// pushMessages(messages, false);
		//
		// }
		// catch (Exception e)
		// {
		// receiver.pushError("Exception while processing Push untagged responses",
		// e);
		// }
		// }

		// private void removeMessages(List<String> removeUids)
		// {
		// List<Message> messages = new ArrayList<Message>(removeUids.size());
		//
		// try
		// {
		// Message[] existingMessages = getMessagesFromUids(removeUids, true,
		// null);
		// for (Message existingMessage : existingMessages)
		// {
		// needsPoll.set(true);
		// msgSeqUidMap.clear();
		// String existingUid = existingMessage.getUid();
		// Log.w(K9.LOG_TAG, "Message with UID " + existingUid +
		// " still exists on server, not expunging");
		// removeUids.remove(existingUid);
		// }
		// for (String uid : removeUids)
		// {
		// ImapMessage message = new ImapMessage(uid, this);
		// try
		// {
		// message.setFlagInternal(Flag.DELETED, true);
		// }
		// catch (MessagingException me)
		// {
		// Log.e(K9.LOG_TAG, "Unable to set DELETED flag on message " +
		// message.getUid());
		// }
		// messages.add(message);
		// }
		// receiver.messagesRemoved(this, messages);
		// }
		// catch (Exception e)
		// {
		// Log.e(K9.LOG_TAG, "Cannot remove EXPUNGEd messages", e);
		// }
		//
		// }

//		protected int processUntaggedResponse(int oldMessageCount, ImapResponse response,
//				List<Integer> flagSyncMsgSeqs, List<String> removeMsgUids)
//		{
//			super.handleUntaggedResponse(response);
//			int messageCountDelta = 0;
//			if (response.mTag == null && response.size() > 1)
//			{
//				try
//				{
//					Object responseType = response.get(1);
//					if (ImapResponseParser.equalsIgnoreCase(responseType, "EXISTS"))
//					{
//						mMessageCount = response.getNumber(0);
//					}
//					else if (ImapResponseParser.equalsIgnoreCase(responseType, "FETCH"))
//					{
//						Log.i(K9.LOG_TAG, "Got FETCH " + response);
//						int msgSeq = response.getNumber(0);
//
//						if (K9.DEBUG)
//							Log.d(K9.LOG_TAG, "Got untagged FETCH for msgseq " + msgSeq + " for "
//												+ getLogId());
//
//						if (!flagSyncMsgSeqs.contains(msgSeq))
//						{
//							flagSyncMsgSeqs.add(msgSeq);
//						}
//					}
//					else if (ImapResponseParser.equalsIgnoreCase(responseType, "EXPUNGE"))
//					{
//						int msgSeq = response.getNumber(0);
//						if (msgSeq <= oldMessageCount)
//						{
//							messageCountDelta = -1;
//						}
//						if (K9.DEBUG)
//							Log.d(K9.LOG_TAG, "Got untagged EXPUNGE for msgseq " + msgSeq + " for "
//												+ getLogId());
//
//						List<Integer> newSeqs = new ArrayList<Integer>();
//						Iterator<Integer> flagIter = flagSyncMsgSeqs.iterator();
//						while (flagIter.hasNext())
//						{
//							Integer flagMsg = flagIter.next();
//							if (flagMsg >= msgSeq)
//							{
//								flagIter.remove();
//								if (flagMsg > msgSeq)
//								{
//									newSeqs.add(flagMsg--);
//								}
//							}
//						}
//						flagSyncMsgSeqs.addAll(newSeqs);
//
//						List<Integer> msgSeqs = new ArrayList<Integer>(msgSeqUidMap.keySet());
//						Collections.sort(msgSeqs); // Have to do comparisons in
//													// order because of msgSeq
//													// reductions
//
//						for (Integer msgSeqNumI : msgSeqs)
//						{
//							if (K9.DEBUG)
//							{
//								Log.v(K9.LOG_TAG, "Comparing EXPUNGEd msgSeq " + msgSeq + " to "
//													+ msgSeqNumI);
//							}
//							int msgSeqNum = msgSeqNumI;
//							if (msgSeqNum == msgSeq)
//							{
//								String uid = msgSeqUidMap.get(msgSeqNum);
//								if (K9.DEBUG)
//								{
//									Log.d(K9.LOG_TAG, "Scheduling removal of UID " + uid
//														+ " because msgSeq " + msgSeqNum
//														+ " was expunged");
//								}
//								removeMsgUids.add(uid);
//								msgSeqUidMap.remove(msgSeqNum);
//							}
//							else if (msgSeqNum > msgSeq)
//							{
//								String uid = msgSeqUidMap.get(msgSeqNum);
//								if (K9.DEBUG)
//								{
//									Log.d(K9.LOG_TAG, "Reducing msgSeq for UID " + uid + " from "
//														+ msgSeqNum + " to " + (msgSeqNum - 1));
//								}
//								msgSeqUidMap.remove(msgSeqNum);
//								msgSeqUidMap.put(msgSeqNum - 1, uid);
//							}
//						}
//					}
//				}
//				catch (Exception e)
//				{
//					Log.e(K9.LOG_TAG, "Could not handle untagged FETCH for " + getLogId(), e);
//				}
//			}
//			return messageCountDelta;
//		}

		// private void pushMessages(List<Message> messages, boolean
		// newArrivals)
		// {
		// RuntimeException holdException = null;
		// try
		// {
		// if (newArrivals)
		// {
		// receiver.messagesArrived(this, messages);
		// }
		// else
		// {
		// receiver.messagesFlagsChanged(this, messages);
		// }
		// }
		// catch (RuntimeException e)
		// {
		// holdException = e;
		// }
		//
		// if (holdException != null)
		// {
		// throw holdException;
		// }
		// }

		public void stop()
		{
			stop.set(true);
			if (listeningThread != null)
			{
				listeningThread.interrupt();
			}
			ImapConnection conn = mConnection;
			if (conn != null)
			{
				if (K9.DEBUG)
					Log.v(K9.LOG_TAG, "Closing mConnection to stop pushing for " + getLogId());
				conn.close();
			}
			else
			{
				Log.w(	K9.LOG_TAG,
						"Attempt to interrupt null mConnection to stop pushing on folderPusher for "
								+ getLogId());
			}
		}

		public void handleAsyncUntaggedResponse(ImapResponse response)
		{
			if (K9.DEBUG)
				Log.v(K9.LOG_TAG, "Got async response: " + response);

			if (stop.get())
			{
				if (K9.DEBUG)
					Log.d(K9.LOG_TAG, "Got async untagged response: " + response
										+ ", but stop is set for " + getLogId());

				try
				{
					sendDone();
				}
				catch (Exception e)
				{
					Log.e(K9.LOG_TAG, "Exception while sending DONE for " + getLogId(), e);
				}
			}
			else
			{
				if (response.mTag == null)
				{
					if (response.size() > 1)
					{
						boolean started = false;
						Object responseType = response.get(1);
						if (ImapResponseParser.equalsIgnoreCase(responseType, "EXISTS")
							|| ImapResponseParser.equalsIgnoreCase(responseType, "EXPUNGE")
							|| ImapResponseParser.equalsIgnoreCase(responseType, "FETCH"))
						{
							if (!started)
							{
//								wakeLock.acquire(K9.PUSH_WAKE_LOCK_TIMEOUT);
								started = true;
							}

							if (K9.DEBUG)
								Log.d(K9.LOG_TAG, "Got useful async untagged response: " + response
													+ " for " + getLogId());

							try
							{
								sendDone();
							}
							catch (Exception e)
							{
								Log.e(	K9.LOG_TAG, "Exception while sending DONE for "
													+ getLogId(),
										e);
							}
						}
					}
					else if (response.mCommandContinuationRequested)
					{
						if (K9.DEBUG)
							Log.d(K9.LOG_TAG, "Idling " + getLogId());

//						wakeLock.release();
					}
				}
			}
		}
	}

	class ImapFolder extends Folder
	{
		private String mName;
		protected volatile int mMessageCount = -1;
		protected volatile int uidNext = -1;
		protected volatile ImapConnection mConnection;
		private OpenMode mMode;
		private volatile boolean mExists;
		private ImapStore store = null;
		Map<Integer, String> msgSeqUidMap = new ConcurrentHashMap<Integer, String>();

		public ImapFolder(ImapStore nStore, String name)
		{
			super(nStore.getAccount());
			store = nStore;
			this.mName = name;
			assert name.equalsIgnoreCase("INBOX");
				
			Account a = getAccount();
			mMessageCount = NewDbHelper.getInstance().getInMailCount(a.id, FolderNames.FOLDER_INBOX,new int[]{MailStatus.MAIL_NEW,MailStatus.MAIL_READED}, true);
		}

		public String getPrefixedName() throws MessagingException
		{
			String prefixedName = "";
			if (!K9.INBOX.equalsIgnoreCase(mName))
			{
				ImapConnection connection = null;
				synchronized (this)
				{
					if (mConnection == null)
					{
						connection = getConnection();
					}
					else
					{
						connection = mConnection;
					}
				}
				try
				{

					connection.open();
				}
				catch (IOException ioe)
				{
					throw new MessagingException("Unable to get IMAP prefix", ioe);
				}
				finally
				{
					if (mConnection == null)
					{
						releaseConnection(connection);
					}
				}
				// prefixedName = getCombinedPrefix();
			}

			prefixedName += mName;
			return prefixedName;
		}

		protected List<ImapResponse> executeSimpleCommand(String command)
				throws MessagingException, IOException
		{
			return handleUntaggedResponses(mConnection.executeSimpleCommand(command));
		}

		protected List<ImapResponse> executeSimpleCommand(String command, boolean sensitve,
				UntaggedHandler untaggedHandler) throws MessagingException, IOException
		{
			return handleUntaggedResponses(mConnection.executeSimpleCommand(command, sensitve,
																			untaggedHandler));
		}

		@Override
		public void open(OpenMode mode) throws MessagingException
		{
			internalOpen(mode);

			if (mMessageCount == -1)
			{
				throw new MessagingException("Did not find message count during open");
			}
		}

		public List<ImapResponse> internalOpen(OpenMode mode) throws MessagingException
		{
			if (isOpen() && mMode == mode)
			{
				// Make sure the connection is valid. If it's not we'll close it
				// down and continue
				// on to get a new one.
				try
				{
					List<ImapResponse> responses = executeSimpleCommand("NOOP");
					return responses;
				}
				catch (IOException ioe)
				{
					ioExceptionHandler(mConnection, ioe);
				}
			}
			releaseConnection(mConnection);
			synchronized (this)
			{
				mConnection = getConnection();
			}
			// * FLAGS (\Answered \Flagged \Deleted \Seen \Draft NonJunk
			// $MDNSent)
			// * OK [PERMANENTFLAGS (\Answered \Flagged \Deleted \Seen \Draft
			// NonJunk $MDNSent \*)] Flags permitted.
			// * 23 EXISTS
			// * 0 RECENT
			// * OK [UIDVALIDITY 1125022061] UIDs valid
			// * OK [UIDNEXT 57576] Predicted next UID
			// 2 OK [READ-WRITE] Select completed.
			try
			{
				msgSeqUidMap.clear();
				String command = String
						.format((mode == OpenMode.READ_WRITE ? "SELECT" : "EXAMINE") + " %s",
								encodeString(encodeFolderName(getPrefixedName())));

				List<ImapResponse> responses = executeSimpleCommand(command);

				/*
				 * If the command succeeds we expect the folder has been opened
				 * read-write unless we are notified otherwise in the responses.
				 */
				mMode = mode;

				for (ImapResponse response : responses)
				{
					if (response.mTag != null && response.size() >= 2)
					{
						Object bracketedObj = response.get(1);
						if (bracketedObj instanceof ImapList)
						{
							ImapList bracketed = (ImapList) bracketedObj;

							if (bracketed.size() > 0)
							{
								Object keyObj = bracketed.get(0);
								if (keyObj instanceof String)
								{
									String key = (String) keyObj;

									if ("READ-ONLY".equalsIgnoreCase(key))
									{
										mMode = OpenMode.READ_ONLY;
									}
									else if ("READ-WRITE".equalsIgnoreCase(key))
									{
										mMode = OpenMode.READ_WRITE;
									}
								}
							}
						}

					}
				}

				mExists = true;
				return responses;
			}
			catch (IOException ioe)
			{
				throw ioExceptionHandler(mConnection, ioe);
			}
			catch (MessagingException me)
			{
				Log.e(K9.LOG_TAG, "Unable to open connection for " + getLogId(), me);
				throw me;
			}

		}

		@Override
		public boolean isOpen()
		{
			return mConnection != null;
		}

		@Override
		public OpenMode getMode()
		{
			return mMode;
		}

		@Override
		public void close()
		{
			if (mMessageCount != -1)
			{
				mMessageCount = -1;
			}
			if (!isOpen())
			{
				return;
			}

			synchronized (this)
			{
				releaseConnection(mConnection);
				mConnection = null;
			}
		}

		@Override
		public String getName()
		{
			return mName;
		}

		/**
		 * Check if a given folder exists on the server.
		 * 
		 * @param folderName
		 *            The name of the folder encoded as quoted string. See
		 *            {@link ImapStore#encodeString}
		 * 
		 * @return {@code True}, if the folder exists. {@code False}, otherwise.
		 */
		private boolean exists(String folderName) throws MessagingException
		{
			try
			{
				// Since we don't care about RECENT, we'll use that for the
				// check, because we're checking
				// a folder other than ourself, and don't want any untagged
				// responses to cause a change
				// in our own fields
				mConnection.executeSimpleCommand(String.format("STATUS %s (RECENT)", folderName));
				return true;
			}
			catch (IOException ioe)
			{
				throw ioExceptionHandler(mConnection, ioe);
			}
			catch (MessagingException me)
			{
				return false;
			}
		}

		@Override
		public boolean exists() throws MessagingException
		{
			if (mExists)
			{
				return true;
			}
			/*
			 * This method needs to operate in the unselected mode as well as
			 * the selected mode so we must get the connection ourselves if it's
			 * not there. We are specifically not calling checkOpen() since we
			 * don't care if the folder is open.
			 */
			ImapConnection connection = null;
			synchronized (this)
			{
				if (mConnection == null)
				{
					connection = getConnection();
				}
				else
				{
					connection = mConnection;
				}
			}
			try
			{
				connection.executeSimpleCommand(String
						.format("STATUS %s (UIDVALIDITY)",
								encodeString(encodeFolderName(getPrefixedName()))));
				mExists = true;
				return true;
			}
			catch (MessagingException me)
			{
				return false;
			}
			catch (IOException ioe)
			{
				throw ioExceptionHandler(connection, ioe);
			}
			finally
			{
				if (mConnection == null)
				{
					releaseConnection(connection);
				}
			}
		}

		@Override
		public boolean create(FolderType type) throws MessagingException
		{
			/*
			 * This method needs to operate in the unselected mode as well as
			 * the selected mode so we must get the connection ourselves if it's
			 * not there. We are specifically not calling checkOpen() since we
			 * don't care if the folder is open.
			 */
			ImapConnection connection = null;
			synchronized (this)
			{
				if (mConnection == null)
				{
					connection = getConnection();
				}
				else
				{
					connection = mConnection;
				}
			}
			try
			{
				connection.executeSimpleCommand(String
						.format("CREATE %s", encodeString(encodeFolderName(getPrefixedName()))));
				return true;
			}
			catch (MessagingException me)
			{
				return false;
			}
			catch (IOException ioe)
			{
				throw ioExceptionHandler(mConnection, ioe);
			}
			finally
			{
				if (mConnection == null)
				{
					releaseConnection(connection);
				}
			}
		}

		// @Override
		// public void copyMessages(Message[] messages, Folder folder) throws
		// MessagingException
		// {
		// if (!(folder instanceof ImapFolder))
		// {
		// throw new
		// MessagingException("ImapFolder.copyMessages passed non-ImapFolder");
		// }
		//
		// if (messages.length == 0)
		// return;
		//
		// ImapFolder iFolder = (ImapFolder)folder;
		// checkOpen();
		// String[] uids = new String[messages.length];
		// for (int i = 0, count = messages.length; i < count; i++)
		// {
		// uids[i] = messages[i].getUid();
		// }
		// try
		// {
		// String remoteDestName =
		// encodeString(encodeFolderName(iFolder.getPrefixedName()));
		//
		// if (!exists(remoteDestName))
		// {
		// /*
		// * If the remote trash folder doesn't exist we try to create it.
		// */
		// if (K9.DEBUG)
		// Log.i(K9.LOG_TAG,
		// "IMAPMessage.copyMessages: attempting to create remote '" +
		// remoteDestName + "' folder for " + getLogId());
		// iFolder.create(FolderType.HOLDS_MESSAGES);
		// }
		//
		// if (exists(remoteDestName))
		// {
		// executeSimpleCommand(String.format("UID COPY %s %s",
		// Utility.combine(uids, ','),
		// remoteDestName));
		// }
		// else
		// {
		// throw new
		// MessagingException("IMAPMessage.copyMessages: remote destination folder "
		// + folder.getName()
		// + " does not exist and could not be created for " + getLogId()
		// , true);
		// }
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }
		//
		// @Override
		// public void moveMessages(Message[] messages, Folder folder) throws
		// MessagingException
		// {
		// if (messages.length == 0)
		// return;
		// copyMessages(messages, folder);
		// setFlags(messages, new Flag[] { Flag.DELETED }, true);
		// }
		//
		// @Override
		// public void delete(Message[] messages, String trashFolderName) throws
		// MessagingException
		// {
		// if (messages.length == 0)
		// return;
		//
		// if (trashFolderName == null ||
		// getName().equalsIgnoreCase(trashFolderName))
		// {
		// setFlags(messages, new Flag[] { Flag.DELETED }, true);
		// }
		// else
		// {
		// ImapFolder remoteTrashFolder =
		// (ImapFolder)getStore().getFolder(trashFolderName);
		// String remoteTrashName =
		// encodeString(encodeFolderName(remoteTrashFolder.getPrefixedName()));
		//
		// if (!exists(remoteTrashName))
		// {
		// /*
		// * If the remote trash folder doesn't exist we try to create it.
		// */
		// if (K9.DEBUG)
		// Log.i(K9.LOG_TAG, "IMAPMessage.delete: attempting to create remote '"
		// + trashFolderName + "' folder for " + getLogId());
		// remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);
		// }
		//
		// if (exists(remoteTrashName))
		// {
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG, "IMAPMessage.delete: copying remote " +
		// messages.length + " messages to '" + trashFolderName + "' for " +
		// getLogId());
		//
		// moveMessages(messages, remoteTrashFolder);
		// }
		// else
		// {
		// throw new
		// MessagingException("IMAPMessage.delete: remote Trash folder " +
		// trashFolderName + " does not exist and could not be created for " +
		// getLogId()
		// , true);
		// }
		// }
		// }

		@Override
		public int getMessageCount()
		{
			return mMessageCount;
		}

		private int getRemoteMessageCount(String criteria) throws MessagingException
		{
			checkOpen();
			try
			{
				int count = 0;
				int start = 1;

				List<ImapResponse> responses = executeSimpleCommand(String
						.format("SEARCH %d:* " + criteria, start));
				for (ImapResponse response : responses)
				{
					if (ImapResponseParser.equalsIgnoreCase(response.get(0), "SEARCH"))
					{
						count += response.size() - 1;
					}
				}
				return count;
			}
			catch (IOException ioe)
			{
				throw ioExceptionHandler(mConnection, ioe);
			}

		}

		@Override
		public int getUnreadMessageCount() throws MessagingException
		{
			return getRemoteMessageCount("UNSEEN NOT DELETED");
		}

		@Override
		public int getFlaggedMessageCount() throws MessagingException
		{
			return getRemoteMessageCount("FLAGGED NOT DELETED");
		}

		protected int getHighestUid()
		{
			// try
			// {
			// ImapSearcher searcher = new ImapSearcher()
			// {
			// public List<ImapResponse> search() throws IOException,
			// MessagingException
			// {
			// return executeSimpleCommand(String.format("UID SEARCH *:* "));
			// }
			// };
			// Message[] messages = search(searcher, null);
			// if (messages.length > 0)
			// {
			// return Integer.parseInt(messages[0].getUid());
			// }
			// }
			// catch (Exception e)
			// {
			// Log.e(K9.LOG_TAG, "Unable to find highest UID in folder " +
			// getName(), e);
			// }
			// return -1;
			return NewDbHelper.getInstance()
					.executScalar("select max(uidx) from mail where accountId=" + getAccount().id,
									new String[] {});
		}

		// @Override
		// public void delete(boolean recurse) throws MessagingException
		// {
		// throw new Error("ImapStore.delete() not yet implemented");
		// }
		//
		// @Override
		// public Message getMessage(String uid) throws MessagingException
		// {
		// return new ImapMessage(uid, this);
		// }
		//
		//
		// @Override
		// public Message[] getMessages(int start, int end, Date earliestDate,
		// MessageRetrievalListener listener)
		// throws MessagingException
		// {
		// return getMessages(start, end, earliestDate, false, listener);
		// }
		//
		// protected Message[] getMessages(final int start, final int end, Date
		// earliestDate, final boolean includeDeleted, final
		// MessageRetrievalListener listener)
		// throws MessagingException
		// {
		// if (start < 1 || end < 1 || end < start)
		// {
		// throw new MessagingException(
		// String.format("Invalid message set %d %d",
		// start, end));
		// }
		// final StringBuilder dateSearchString = new StringBuilder();
		// if (earliestDate != null)
		// {
		// dateSearchString.append(" SINCE ");
		// synchronized (RFC3501_DATE)
		// {
		// dateSearchString.append(RFC3501_DATE.format(earliestDate));
		// }
		// }
		//
		//
		// ImapSearcher searcher = new ImapSearcher()
		// {
		// public List<ImapResponse> search() throws IOException,
		// MessagingException
		// {
		// return executeSimpleCommand(String.format("UID SEARCH %d:%d%s" +
		// (includeDeleted ? "" : " NOT DELETED"), start, end,
		// dateSearchString));
		// }
		// };
		// return search(searcher, listener);
		//
		// }
		// protected Message[] getMessages(final List<Integer> mesgSeqs, final
		// boolean includeDeleted, final MessageRetrievalListener listener)
		// throws MessagingException
		// {
		// ImapSearcher searcher = new ImapSearcher()
		// {
		// public List<ImapResponse> search() throws IOException,
		// MessagingException
		// {
		// return executeSimpleCommand(String.format("UID SEARCH %s" +
		// (includeDeleted ? "" : " NOT DELETED"),
		// Utility.combine(mesgSeqs.toArray(), ',')));
		// }
		// };
		// return search(searcher, listener);
		// }
		//
		// protected Message[] getMessagesFromUids(final List<String> mesgUids,
		// final boolean includeDeleted, final MessageRetrievalListener
		// listener)
		// throws MessagingException
		// {
		// ImapSearcher searcher = new ImapSearcher()
		// {
		// public List<ImapResponse> search() throws IOException,
		// MessagingException
		// {
		// return executeSimpleCommand(String.format("UID SEARCH UID %s" +
		// (includeDeleted ? "" : " NOT DELETED"),
		// Utility.combine(mesgUids.toArray(), ',')));
		// }
		// };
		// return search(searcher, listener);
		// }
		//
		// private Message[] search(ImapSearcher searcher,
		// MessageRetrievalListener listener) throws MessagingException
		// {
		//
		// checkOpen();
		// ArrayList<Message> messages = new ArrayList<Message>();
		// try
		// {
		// ArrayList<Integer> uids = new ArrayList<Integer>();
		// List<ImapResponse> responses = searcher.search(); //
		// for (ImapResponse response : responses)
		// {
		// if (response.mTag == null)
		// {
		// if (ImapResponseParser.equalsIgnoreCase(response.get(0), "SEARCH"))
		// {
		// for (int i = 1, count = response.size(); i < count; i++)
		// {
		// uids.add(Integer.parseInt(response.getString(i)));
		// }
		// }
		// }
		// }
		//
		// // Sort the uids in numerically ascending order
		// Collections.sort(uids);
		// for (int i = 0, count = uids.size(); i < count; i++)
		// {
		// if (listener != null)
		// {
		// listener.messageStarted("" + uids.get(i), i, count);
		// }
		// ImapMessage message = new ImapMessage("" + uids.get(i), this);
		// messages.add(message);
		// if (listener != null)
		// {
		// listener.messageFinished(message, i, count);
		// }
		// }
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// return messages.toArray(EMPTY_MESSAGE_ARRAY);
		// }
		//
		//
		// @Override
		// public Message[] getMessages(MessageRetrievalListener listener)
		// throws MessagingException
		// {
		// return getMessages(null, listener);
		// }
		//
		// @Override
		// public Message[] getMessages(String[] uids, MessageRetrievalListener
		// listener)
		// throws MessagingException
		// {
		// checkOpen();
		// ArrayList<Message> messages = new ArrayList<Message>();
		// try
		// {
		// if (uids == null)
		// {
		// List<ImapResponse> responses =
		// executeSimpleCommand("UID SEARCH 1:* NOT DELETED");
		// ArrayList<String> tempUids = new ArrayList<String>();
		// for (ImapResponse response : responses)
		// {
		// if (ImapResponseParser.equalsIgnoreCase(response.get(0), "SEARCH"))
		// {
		// for (int i = 1, count = response.size(); i < count; i++)
		// {
		// tempUids.add(response.getString(i));
		// }
		// }
		// }
		// uids = tempUids.toArray(EMPTY_STRING_ARRAY);
		// }
		// for (int i = 0, count = uids.length; i < count; i++)
		// {
		// if (listener != null)
		// {
		// listener.messageStarted(uids[i], i, count);
		// }
		// ImapMessage message = new ImapMessage(uids[i], this);
		// messages.add(message);
		// if (listener != null)
		// {
		// listener.messageFinished(message, i, count);
		// }
		// }
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// return messages.toArray(EMPTY_MESSAGE_ARRAY);
		// }
		//
		// @Override
		// public void fetch(Message[] messages, FetchProfile fp,
		// MessageRetrievalListener listener)
		// throws MessagingException
		// {
		// if (messages == null || messages.length == 0)
		// {
		// return;
		// }
		// checkOpen();
		// List<String> uids = new ArrayList<String>(messages.length);
		// HashMap<String, Message> messageMap = new HashMap<String, Message>();
		// for (int i = 0, count = messages.length; i < count; i++)
		// {
		//
		// String uid = messages[i].getUid();
		// uids.add(uid);
		// messageMap.put(uid, messages[i]);
		// }
		//
		// /*
		// * Figure out what command we are going to run:
		// * Flags - UID FETCH (FLAGS)
		// * Envelope - UID FETCH ([FLAGS] INTERNALDATE UID RFC822.SIZE FLAGS
		// BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc)])
		// *
		// */
		// LinkedHashSet<String> fetchFields = new LinkedHashSet<String>();
		// fetchFields.add("UID");
		// if (fp.contains(FetchProfile.Item.FLAGS))
		// {
		// fetchFields.add("FLAGS");
		// }
		// if (fp.contains(FetchProfile.Item.ENVELOPE))
		// {
		// fetchFields.add("INTERNALDATE");
		// fetchFields.add("RFC822.SIZE");
		// fetchFields.add("BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc reply-to "
		// + K9.IDENTITY_HEADER + ")]");
		// }
		// if (fp.contains(FetchProfile.Item.STRUCTURE))
		// {
		// fetchFields.add("BODYSTRUCTURE");
		// }
		// if (fp.contains(FetchProfile.Item.BODY_SANE))
		// {
		// fetchFields.add(String.format("BODY.PEEK[]<0.%d>",
		// mAccount.getMaximumAutoDownloadMessageSize()));
		// }
		// if (fp.contains(FetchProfile.Item.BODY))
		// {
		// fetchFields.add("BODY.PEEK[]");
		// }
		//
		//
		//
		// for (int windowStart=0; windowStart <= messages.length; windowStart
		// += (FETCH_WINDOW_SIZE))
		// {
		// List<String> uidWindow = uids.subList(windowStart,
		// Math.min((windowStart+FETCH_WINDOW_SIZE),messages.length));
		//
		// try
		// {
		// mConnection.sendCommand(String.format("UID FETCH %s (%s)",
		// Utility.combine(uidWindow.toArray(new String[uidWindow.size()]),
		// ','),
		// Utility.combine(fetchFields.toArray(new String[fetchFields.size()]),
		// ' ')
		// ), false);
		// ImapResponse response;
		// int messageNumber = 0;
		//
		// ImapResponseParser.IImapResponseCallback callback = null;
		// if (fp.contains(FetchProfile.Item.BODY) ||
		// fp.contains(FetchProfile.Item.BODY_SANE))
		// {
		// callback = new FetchBodyCallback(messageMap);
		// }
		//
		// do
		// {
		// response = mConnection.readResponse(callback);
		//
		// if (response.mTag == null &&
		// ImapResponseParser.equalsIgnoreCase(response.get(1), "FETCH"))
		// {
		// ImapList fetchList = (ImapList)response.getKeyedValue("FETCH");
		// String uid = fetchList.getKeyedString("UID");
		// int msgSeq = response.getNumber(0);
		// if (uid != null)
		// {
		// try
		// {
		// msgSeqUidMap.put(msgSeq, uid);
		// if (K9.DEBUG)
		// {
		// Log.v(K9.LOG_TAG, "Stored uid '" + uid + "' for msgSeq " + msgSeq +
		// " into map " /*+ msgSeqUidMap.toString() */);
		// }
		// }
		// catch (Exception e)
		// {
		// Log.e(K9.LOG_TAG, "Unable to store uid '" + uid + "' for msgSeq " +
		// msgSeq);
		// }
		// }
		//
		// Message message = messageMap.get(uid);
		// if (message == null)
		// {
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG, "Do not have message in messageMap for UID " + uid
		// + " for " + getLogId());
		//
		// handleUntaggedResponse(response);
		// continue;
		// }
		// if (listener != null)
		// {
		// listener.messageStarted(uid, messageNumber++, messageMap.size());
		// }
		//
		// ImapMessage imapMessage = (ImapMessage) message;
		//
		// Object literal = handleFetchResponse(imapMessage, fetchList);
		//
		// if (literal != null)
		// {
		// if (literal instanceof String)
		// {
		// String bodyString = (String)literal;
		// InputStream bodyStream = new
		// ByteArrayInputStream(bodyString.getBytes());
		// imapMessage.parse(bodyStream);
		// }
		// else if (literal instanceof Integer)
		// {
		// // All the work was done in FetchBodyCallback.foundLiteral()
		// }
		// else
		// {
		// // This shouldn't happen
		// throw new
		// MessagingException("Got FETCH response with bogus parameters");
		// }
		// }
		//
		// if (listener != null)
		// {
		// listener.messageFinished(message, messageNumber, messageMap.size());
		// }
		// }
		// else
		// {
		// handleUntaggedResponse(response);
		// }
		//
		// while (response.more());
		//
		// }
		// while (response.mTag == null);
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }
		// }
		//
		//
		// @Override
		// public void fetchPart(Message message, Part part,
		// MessageRetrievalListener listener)
		// throws MessagingException
		// {
		// checkOpen();
		//
		// String[] parts =
		// part.getHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA);
		// if (parts == null)
		// {
		// return;
		// }
		//
		// String fetch;
		// String partId = parts[0];
		// if ("TEXT".equalsIgnoreCase(partId))
		// {
		// fetch = String.format("BODY.PEEK[TEXT]<0.%d>",
		// mAccount.getMaximumAutoDownloadMessageSize());
		// }
		// else
		// {
		// fetch = String.format("BODY.PEEK[%s]", partId);
		// }
		//
		// try
		// {
		// mConnection.sendCommand(
		// String.format("UID FETCH %s (UID %s)", message.getUid(), fetch),
		// false);
		//
		// ImapResponse response;
		// int messageNumber = 0;
		//
		// ImapResponseParser.IImapResponseCallback callback = new
		// FetchPartCallback(part);
		//
		// do
		// {
		// response = mConnection.readResponse(callback);
		//
		// if ((response.mTag == null) &&
		// (ImapResponseParser.equalsIgnoreCase(response.get(1), "FETCH")))
		// {
		// ImapList fetchList = (ImapList)response.getKeyedValue("FETCH");
		// String uid = fetchList.getKeyedString("UID");
		//
		// if (!message.getUid().equals(uid))
		// {
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG, "Did not ask for UID " + uid + " for " +
		// getLogId());
		//
		// handleUntaggedResponse(response);
		// continue;
		// }
		// if (listener != null)
		// {
		// listener.messageStarted(uid, messageNumber++, 1);
		// }
		//
		// ImapMessage imapMessage = (ImapMessage) message;
		//
		// Object literal = handleFetchResponse(imapMessage, fetchList);
		//
		// if (literal != null)
		// {
		// if (literal instanceof Body)
		// {
		// // Most of the work was done in FetchAttchmentCallback.foundLiteral()
		// part.setBody((Body)literal);
		// }
		// else if (literal instanceof String)
		// {
		// String bodyString = (String)literal;
		// InputStream bodyStream = new
		// ByteArrayInputStream(bodyString.getBytes());
		//
		// String contentTransferEncoding = part.getHeader(
		// MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];
		// part.setBody(MimeUtility.decodeBody(bodyStream,
		// contentTransferEncoding));
		// }
		// else
		// {
		// // This shouldn't happen
		// throw new
		// MessagingException("Got FETCH response with bogus parameters");
		// }
		// }
		//
		// if (listener != null)
		// {
		// listener.messageFinished(message, messageNumber, 1);
		// }
		// }
		// else
		// {
		// handleUntaggedResponse(response);
		// }
		//
		// while (response.more());
		//
		// }
		// while (response.mTag == null);
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }
		//
		// Returns value of body field
		// private Object handleFetchResponse(ImapMessage message, ImapList
		// fetchList) throws MessagingException
		// {
		// Object result = null;
		// if (fetchList.containsKey("FLAGS"))
		// {
		// ImapList flags = fetchList.getKeyedList("FLAGS");
		// if (flags != null)
		// {
		// for (int i = 0, count = flags.size(); i < count; i++)
		// {
		// String flag = flags.getString(i);
		// if (flag.equalsIgnoreCase("\\Deleted"))
		// {
		// message.setFlagInternal(Flag.DELETED, true);
		// }
		// else if (flag.equalsIgnoreCase("\\Answered"))
		// {
		// message.setFlagInternal(Flag.ANSWERED, true);
		// }
		// else if (flag.equalsIgnoreCase("\\Seen"))
		// {
		// message.setFlagInternal(Flag.SEEN, true);
		// }
		// else if (flag.equalsIgnoreCase("\\Flagged"))
		// {
		// message.setFlagInternal(Flag.FLAGGED, true);
		// }
		// }
		// }
		// }
		//
		// if (fetchList.containsKey("INTERNALDATE"))
		// {
		// Date internalDate = fetchList.getKeyedDate("INTERNALDATE");
		// message.setInternalDate(internalDate);
		// }
		//
		// if (fetchList.containsKey("RFC822.SIZE"))
		// {
		// int size = fetchList.getKeyedNumber("RFC822.SIZE");
		// message.setSize(size);
		// }
		//
		// if (fetchList.containsKey("BODYSTRUCTURE"))
		// {
		// ImapList bs = fetchList.getKeyedList("BODYSTRUCTURE");
		// if (bs != null)
		// {
		// try
		// {
		// parseBodyStructure(bs, message, "TEXT");
		// }
		// catch (MessagingException e)
		// {
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG, "Error handling message for " + getLogId(), e);
		// message.setBody(null);
		// }
		// }
		// }
		//
		// if (fetchList.containsKey("BODY"))
		// {
		// int index = fetchList.getKeyIndex("BODY") + 2;
		// result = fetchList.getObject(index);
		//
		// // Check if there's an origin octet
		// if (result instanceof String)
		// {
		// String originOctet = (String)result;
		// if (originOctet.startsWith("<"))
		// {
		// result = fetchList.getObject(index + 1);
		// }
		// }
		// }
		//
		// return result;
		// }
		//
		@Override
		public Flag[] getPermanentFlags()
		{
			return PERMANENT_FLAGS;
		}

		/**
		 * Handle any untagged responses that the caller doesn't care to handle
		 * themselves.
		 * 
		 * @param responses
		 */
		protected List<ImapResponse> handleUntaggedResponses(List<ImapResponse> responses)
		{
			for (ImapResponse response : responses)
			{
				handleUntaggedResponse(response);
			}
			return responses;
		}

		protected void handlePossibleUidNext(ImapResponse response)
		{
			if (ImapResponseParser.equalsIgnoreCase(response.get(0), "OK") && response.size() > 1)
			{
				Object bracketedObj = response.get(1);
				if (bracketedObj instanceof ImapList)
				{
					ImapList bracketed = (ImapList) bracketedObj;

					if (bracketed.size() > 1)
					{
						Object keyObj = bracketed.get(0);
						if (keyObj instanceof String)
						{
							String key = (String) keyObj;
							if ("UIDNEXT".equalsIgnoreCase(key))
							{
								uidNext = bracketed.getNumber(1);
								if (K9.DEBUG)
									Log.d(K9.LOG_TAG, "Got UidNext = " + uidNext + " for "
														+ getLogId());
							}
						}
					}

				}
			}
		}

		/**
		 * Handle an untagged response that the caller doesn't care to handle
		 * themselves.
		 * 
		 * @param response
		 */
		protected void handleUntaggedResponse(ImapResponse response)
		{
			if (response.mTag == null && response.size() > 1)
			{
				if (ImapResponseParser.equalsIgnoreCase(response.get(1), "EXISTS"))
				{
					mMessageCount = response.getNumber(0);
					if (K9.DEBUG)
						Log.d(K9.LOG_TAG, "Got untagged EXISTS with value " + mMessageCount
											+ " for " + getLogId());
				}
				handlePossibleUidNext(response);

				if (ImapResponseParser.equalsIgnoreCase(response.get(1), "EXPUNGE")
					&& mMessageCount > 0)
				{
					mMessageCount--;
					if (K9.DEBUG)
						Log.d(K9.LOG_TAG, "Got untagged EXPUNGE with mMessageCount "
											+ mMessageCount + " for " + getLogId());
				}
				// if (response.size() > 1) {
				// Object bracketedObj = response.get(1);
				// if (bracketedObj instanceof ImapList)
				// {
				// ImapList bracketed = (ImapList)bracketedObj;
				//
				// if (bracketed.size() > 0)
				// {
				// Object keyObj = bracketed.get(0);
				// if (keyObj instanceof String)
				// {
				// String key = (String)keyObj;
				// if ("ALERT".equalsIgnoreCase(key))
				// {
				// StringBuffer sb = new StringBuffer();
				// for (int i = 2, count = response.size(); i < count; i++) {
				// sb.append(response.get(i).toString());
				// sb.append(' ');
				// }
				//
				// Log.w(K9.LOG_TAG, "ALERT: " + sb.toString() + " for " +
				// getLogId());
				// }
				// }
				// }
				//
				//
				// }
				// }
			}
			// Log.i(K9.LOG_TAG, "mMessageCount = " + mMessageCount + " for " +
			// getLogId());
		}

		// private void parseBodyStructure(ImapList bs, Part part, String id)
		// throws MessagingException
		// {
		// if (bs.get(0) instanceof ImapList)
		// {
		// /*
		// * This is a multipart/*
		// */
		// MimeMultipart mp = new MimeMultipart();
		// for (int i = 0, count = bs.size(); i < count; i++)
		// {
		// if (bs.get(i) instanceof ImapList)
		// {
		// /*
		// * For each part in the message we're going to add a new BodyPart and
		// parse
		// * into it.
		// */
		// ImapBodyPart bp = new ImapBodyPart();
		// if (id.equalsIgnoreCase("TEXT"))
		// {
		// parseBodyStructure(bs.getList(i), bp, Integer.toString(i + 1));
		// }
		// else
		// {
		// parseBodyStructure(bs.getList(i), bp, id + "." + (i + 1));
		// }
		// mp.addBodyPart(bp);
		// }
		// else
		// {
		// /*
		// * We've got to the end of the children of the part, so now we can
		// find out
		// * what type it is and bail out.
		// */
		// String subType = bs.getString(i);
		// mp.setSubType(subType.toLowerCase());
		// break;
		// }
		// }
		// part.setBody(mp);
		// }
		// else
		// {
		// /*
		// * This is a body. We need to add as much information as we can find
		// out about
		// * it to the Part.
		// */
		//
		// /*
		// body type
		// body subtype
		// body parameter parenthesized list
		// body id
		// body description
		// body encoding
		// body size
		// */
		//
		//
		// String type = bs.getString(0);
		// String subType = bs.getString(1);
		// String mimeType = (type + "/" + subType).toLowerCase();
		//
		// ImapList bodyParams = null;
		// if (bs.get(2) instanceof ImapList)
		// {
		// bodyParams = bs.getList(2);
		// }
		// String encoding = bs.getString(5);
		// int size = bs.getNumber(6);
		//
		// if (MimeUtility.mimeTypeMatches(mimeType, "message/rfc822"))
		// {
		// // A body type of type MESSAGE and subtype RFC822
		// // contains, immediately after the basic fields, the
		// // envelope structure, body structure, and size in
		// // text lines of the encapsulated message.
		// // [MESSAGE, RFC822, [NAME, Fwd: [#HTR-517941]: update plans at 1am
		// Friday - Memory allocation - displayware.eml], NIL, NIL, 7BIT, 5974,
		// NIL, [INLINE, [FILENAME*0, Fwd: [#HTR-517941]: update plans at 1am
		// Friday - Memory all, FILENAME*1, ocation - displayware.eml]], NIL]
		// /*
		// * This will be caught by fetch and handled appropriately.
		// */
		// throw new
		// MessagingException("BODYSTRUCTURE message/rfc822 not yet supported.");
		// }
		//
		// /*
		// * Set the content type with as much information as we know right now.
		// */
		// String contentType = String.format("%s", mimeType);
		//
		// if (bodyParams != null)
		// {
		// /*
		// * If there are body params we might be able to get some more
		// information out
		// * of them.
		// */
		// for (int i = 0, count = bodyParams.size(); i < count; i += 2)
		// {
		// contentType += String.format(";\n %s=\"%s\"",
		// bodyParams.getString(i),
		// bodyParams.getString(i + 1));
		// }
		// }
		//
		// part.setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType);
		//
		// // Extension items
		// ImapList bodyDisposition = null;
		// if (("text".equalsIgnoreCase(type))
		// && (bs.size() > 8)
		// && (bs.get(9) instanceof ImapList))
		// {
		// bodyDisposition = bs.getList(9);
		// }
		// else if (!("text".equalsIgnoreCase(type))
		// && (bs.size() > 7)
		// && (bs.get(8) instanceof ImapList))
		// {
		// bodyDisposition = bs.getList(8);
		// }
		//
		// String contentDisposition = "";
		//
		// if (bodyDisposition != null && bodyDisposition.size() > 0)
		// {
		// if (!"NIL".equalsIgnoreCase(bodyDisposition.getString(0)))
		// {
		// contentDisposition = bodyDisposition.getString(0).toLowerCase();
		// }
		//
		// if ((bodyDisposition.size() > 1)
		// && (bodyDisposition.get(1) instanceof ImapList))
		// {
		// ImapList bodyDispositionParams = bodyDisposition.getList(1);
		// /*
		// * If there is body disposition information we can pull some more
		// information
		// * about the attachment out.
		// */
		// for (int i = 0, count = bodyDispositionParams.size(); i < count; i +=
		// 2)
		// {
		// contentDisposition += String.format(";\n %s=\"%s\"",
		// bodyDispositionParams.getString(i).toLowerCase(),
		// bodyDispositionParams.getString(i + 1));
		// }
		// }
		// }
		//
		// if (MimeUtility.getHeaderParameter(contentDisposition, "size") ==
		// null)
		// {
		// contentDisposition += String.format(";\n size=%d", size);
		// }
		//
		// /*
		// * Set the content disposition containing at least the size.
		// Attachment
		// * handling code will use this down the road.
		// */
		// part.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION,
		// contentDisposition);
		//
		//
		// /*
		// * Set the Content-Transfer-Encoding header. Attachment code will use
		// this
		// * to parse the body.
		// */
		// part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING,
		// encoding);
		//
		// if (part instanceof ImapMessage)
		// {
		// ((ImapMessage) part).setSize(size);
		// }
		// else if (part instanceof ImapBodyPart)
		// {
		// ((ImapBodyPart) part).setSize(size);
		// }
		// else
		// {
		// throw new MessagingException("Unknown part type " + part.toString());
		// }
		// part.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, id);
		// }
		//
		// }
		//
		// /**
		// * Appends the given messages to the selected folder. This
		// implementation also determines
		// * the new UID of the given message on the IMAP server and sets the
		// Message's UID to the
		// * new server UID.
		// */
		// @Override
		// public void appendMessages(Message[] messages) throws
		// MessagingException
		// {
		// checkOpen();
		// try
		// {
		// for (Message message : messages)
		// {
		// CountingOutputStream out = new CountingOutputStream();
		// EOLConvertingOutputStream eolOut = new
		// EOLConvertingOutputStream(out);
		// message.writeTo(eolOut);
		// eolOut.flush();
		//
		// mConnection.sendCommand(
		// String.format("APPEND %s (%s) {%d}",
		// encodeString(encodeFolderName(getPrefixedName())),
		// combineFlags(message.getFlags()),
		// out.getCount()), false);
		// ImapResponse response;
		// do
		// {
		// response = mConnection.readResponse();
		// handleUntaggedResponse(response);
		// if (response.mCommandContinuationRequested)
		// {
		// eolOut = new EOLConvertingOutputStream(mConnection.mOut);
		// message.writeTo(eolOut);
		// eolOut.write('\r');
		// eolOut.write('\n');
		// eolOut.flush();
		// }
		// while (response.more());
		// }
		// while (response.mTag == null);
		//
		// String newUid = getUidFromMessageId(message);
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG, "Got UID " + newUid + " for message for " +
		// getLogId());
		//
		// if (newUid != null)
		// {
		// message.setUid(newUid);
		// }
		//
		//
		// }
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }
		//
		// @Override
		// public String getUidFromMessageId(Message message) throws
		// MessagingException
		// {
		// try
		// {
		// /*
		// * Try to find the UID of the message we just appended using the
		// * Message-ID header.
		// */
		// String[] messageIdHeader = message.getHeader("Message-ID");
		//
		// if (messageIdHeader == null || messageIdHeader.length == 0)
		// {
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG,
		// "Did not get a message-id in order to search for UID  for " +
		// getLogId());
		// return null;
		// }
		// String messageId = messageIdHeader[0];
		// if (K9.DEBUG)
		// Log.d(K9.LOG_TAG, "Looking for UID for message with message-id " +
		// messageId + " for " + getLogId());
		//
		// List<ImapResponse> responses =
		// executeSimpleCommand(
		// String.format("UID SEARCH HEADER MESSAGE-ID %s", messageId));
		// for (ImapResponse response1 : responses)
		// {
		// if (response1.mTag == null &&
		// ImapResponseParser.equalsIgnoreCase(response1.get(0), "SEARCH")
		// && response1.size() > 1)
		// {
		// return response1.getString(1);
		// }
		// }
		// return null;
		// }
		// catch (IOException ioe)
		// {
		// throw new
		// MessagingException("Could not find UID for message based on Message-ID",
		// ioe);
		// }
		// }
		//
		//
		// @Override
		// public void expunge() throws MessagingException
		// {
		// checkOpen();
		// try
		// {
		// executeSimpleCommand("EXPUNGE");
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }
		//
		// private String combineFlags(Flag[] flags)
		// {
		// ArrayList<String> flagNames = new ArrayList<String>();
		// for (Flag flag : flags)
		// {
		// if (flag == Flag.SEEN)
		// {
		// flagNames.add("\\Seen");
		// }
		// else if (flag == Flag.DELETED)
		// {
		// flagNames.add("\\Deleted");
		// }
		// else if (flag == Flag.ANSWERED)
		// {
		// flagNames.add("\\Answered");
		// }
		// else if (flag == Flag.FLAGGED)
		// {
		// flagNames.add("\\Flagged");
		// }
		//
		// }
		// return Utility.combine(flagNames.toArray(new
		// String[flagNames.size()]), ' ');
		// }

		// @Override
		// public void setFlags(Flag[] flags, boolean value)
		// throws MessagingException
		// {
		// checkOpen();
		//
		//
		// try
		// {
		// executeSimpleCommand(String.format("UID STORE 1:* %sFLAGS.SILENT (%s)",
		// value ? "+" : "-", combineFlags(flags)));
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }

		// @Override
		// public String getNewPushState(String oldPushStateS, Message message)
		// {
		// try
		// {
		// String messageUidS = message.getUid();
		// int messageUid = Integer.parseInt(messageUidS);
		// ImapPushState oldPushState = ImapPushState.parse(oldPushStateS);
		// if (messageUid >= oldPushState.uidNext)
		// {
		// int uidNext = messageUid + 1;
		// ImapPushState newPushState = new ImapPushState(uidNext);
		// return newPushState.toString();
		// }
		// else
		// {
		// return null;
		// }
		// }
		// catch (Exception e)
		// {
		// Log.e(K9.LOG_TAG, "Exception while updated push state for " +
		// getLogId(), e);
		// return null;
		// }
		// }
		//
		//
		// @Override
		// public void setFlags(Message[] messages, Flag[] flags, boolean value)
		// throws MessagingException
		// {
		// checkOpen();
		// String[] uids = new String[messages.length];
		// for (int i = 0, count = messages.length; i < count; i++)
		// {
		// uids[i] = messages[i].getUid();
		// }
		// ArrayList<String> flagNames = new ArrayList<String>();
		// for (Flag flag : flags)
		// {
		// if (flag == Flag.SEEN)
		// {
		// flagNames.add("\\Seen");
		// }
		// else if (flag == Flag.DELETED)
		// {
		// flagNames.add("\\Deleted");
		// }
		// else if (flag == Flag.ANSWERED)
		// {
		// flagNames.add("\\Answered");
		// }
		// else if (flag == Flag.FLAGGED)
		// {
		// flagNames.add("\\Flagged");
		// }
		// }
		// try
		// {
		// executeSimpleCommand(String.format("UID STORE %s %sFLAGS.SILENT (%s)",
		// Utility.combine(uids, ','),
		// value ? "+" : "-",
		// Utility.combine(flagNames.toArray(new String[flagNames.size()]),
		// ' ')));
		// }
		// catch (IOException ioe)
		// {
		// throw ioExceptionHandler(mConnection, ioe);
		// }
		// }

		private void checkOpen() throws MessagingException
		{
			if (!isOpen())
			{
				throw new MessagingException("Folder " + getPrefixedName() + " is not open.");
			}
		}

		private MessagingException ioExceptionHandler(ImapConnection connection, IOException ioe)
		{
			Log.e(K9.LOG_TAG, "IOException for " + getLogId(), ioe);
			if (connection != null)
			{
				connection.close();
			}
			close();
			return new MessagingException("IO Error", ioe);
		}

		@Override
		public boolean equals(Object o)
		{
			if (o instanceof ImapFolder)
			{
				return ((ImapFolder) o).getName().equalsIgnoreCase(getName());
			}
			return super.equals(o);
		}

		@Override
		public int hashCode()
		{
			return getName().hashCode();
		}

		protected ImapStore getStore()
		{
			return store;
		}

		protected String getLogId()
		{
			// String id = getAccount().getDescription() + ":" + getName() + "/"
			// + Thread.currentThread().getName();
			String id = getAccount().name;
			if (mConnection != null)
			{
				id += "/" + mConnection.getLogId();
			}
			return id;
		}
	}

	static class ImapException extends MessagingException
	{
		private static final long serialVersionUID = 3725007182205882394L;
		String mAlertText;

		public ImapException(String message, String alertText, Throwable throwable)
		{
			super(message, throwable);
			this.mAlertText = alertText;
		}

		public ImapException(String message, String alertText)
		{
			super(message);
			this.mAlertText = alertText;
		}

		public String getAlertText()
		{
			return mAlertText;
		}

		public void setAlertText(String alertText)
		{
			mAlertText = alertText;
		}
	}

}

package mobi.cloudymail.protocol.imap;

public class MessagingException extends Exception
{
    public static final long serialVersionUID = -1;

    boolean permanentFailure = false;

    public MessagingException(String message)
    {
        super(message);
    }

    public MessagingException(String message, boolean perm)
    {
        super(message);
        permanentFailure = perm;
    }

    public MessagingException(String message, Throwable throwable)
    {
        super(message, throwable);
    }

    public MessagingException(String message, boolean perm, Throwable throwable)
    {
        super(message, throwable);
        permanentFailure = perm;
    }

    public boolean isPermanentFailure()
    {
        return permanentFailure;
    }

    public void setPermanentFailure(boolean permanentFailure)
    {
        this.permanentFailure = permanentFailure;
    }


}

package mobi.cloudymail.protocol.imap;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that allows single byte "peeks" without consuming the byte. The
 * client of this stream can call peek() to see the next available byte in the stream
 * and a subsequent read will still return the peeked byte.
 */
public class PeekableInputStream extends InputStream
{
    private InputStream mIn;
    private boolean mPeeked;
    private int mPeekedByte;

    public PeekableInputStream(InputStream in)
    {
        this.mIn = in;
    }

    @Override
    public int read() throws IOException
    {
        if (!mPeeked)
        {
            return mIn.read();
        }
        else
        {
            mPeeked = false;
            return mPeekedByte;
        }
    }

    public int peek() throws IOException
    {
        if (!mPeeked)
        {
            mPeekedByte = read();
            mPeeked = true;
        }
        return mPeekedByte;
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException
    {
        if (!mPeeked)
        {
            return mIn.read(b, offset, length);
        }
        else
        {
            b[0] = (byte)mPeekedByte;
            mPeeked = false;
            int r = mIn.read(b, offset + 1, length - 1);
            if (r == -1)
            {
                return 1;
            }
            else
            {
                return r + 1;
            }
        }
    }

    @Override
    public int read(byte[] b) throws IOException
    {
        return read(b, 0, b.length);
    }

    @Override
    public String toString()
    {
        return String.format("PeekableInputStream(in=%s, peeked=%b, peekedByte=%d)",
                             mIn.toString(), mPeeked, mPeekedByte);
    }
}
package mobi.cloudymail.protocol.imap;

import java.util.List;


public interface Pusher
{
    public void start(List<String> folderNames);
    public void refresh();
    public void stop();
    /**
     *
     * @return milliseconds of required refresh interval
     */
    public int getRefreshInterval();
    public void setLastRefresh(long lastRefresh);
    public long getLastRefresh();
}
package mobi.cloudymail.protocol.imap;

import mobi.cloudymail.protocol.imap.TracingPowerManager.TracingWakeLock;
import android.content.Context;

public interface PushReceiver
{
    public Context getContext();
    public void syncFolder(Folder folder);
//    public void messagesArrived(Folder folder, List<Message> mess);
//    public void messagesFlagsChanged(Folder folder, List<Message> mess);
//    public void messagesRemoved(Folder folder, List<Message> mess);
    public String getPushState(String folderName);
    public void pushError(String errorMessage, Exception e);
    public void setPushActive(String folderName, boolean enabled);
    public void sleep(TracingWakeLock wakeLock, long millis);
}

package mobi.cloudymail.protocol.imap;

import java.util.HashMap;

import mobi.cloudymail.mailclient.net.Account;

/**
 * Store is the access point for an email message store. It's location can be
 * local or remote and no specific protocol is defined. Store is intended to
 * loosely model in combination the JavaMail classes javax.mail.Store and
 * javax.mail.Folder along with some additional functionality to improve
 * performance on mobile devices. Implementations of this class should focus on
 * making as few network connections as possible.
 */
public abstract class Store
{
    protected static final int SOCKET_CONNECT_TIMEOUT = 30000;
    protected static final int SOCKET_READ_TIMEOUT = 60000;

    /**
     * Remote stores indexed by Uri.
     */
    private static HashMap<String, Store> mStores = new HashMap<String, Store>();
    /**
     * Local stores indexed by UUid because the Uri may change due to migration to/from SD-card.
     */
    private static HashMap<String, Store> mLocalStores = new HashMap<String, Store>();

    protected final Account mAccount;

    protected Store(Account account)
    {
        mAccount = account;
    }

    /**
     * Get an instance of a remote mail store.
     */
    public synchronized static Store getRemoteInstance(Account account) throws MessagingException
    {
//        String uri = account.getStoreUri();
    	String uri = account.name;

        if (uri.startsWith("local"))
        {
            throw new RuntimeException("Asked to get non-local Store object but given LocalStore URI");
        }

        Store store = mStores.get(uri);
        if (store == null)
        {
            if (uri.startsWith("imap"))
            {
                store = new ImapStore(account);
            }

            if (store != null)
            {
                mStores.put(uri, store);
            }
        }

        if (store == null)
        {
            throw new MessagingException("Unable to locate an applicable Store for " + uri);
        }

        return store;
    }

//    /**
//     * Get an instance of a local mail store.
//     * @throws UnavailableStorageException if not {@link StorageProvider#isReady(Context)}
//     */
//    public synchronized static LocalStore getLocalInstance(Account account, Application application) throws MessagingException
//    {
//        Store store = mLocalStores.get(account.getUuid());
//        if (store == null)
//        {
//            store = new LocalStore(account, application);
//            mLocalStores.put(account.getUuid(), store);
//        }
//
//        return (LocalStore) store;
//    }

//    public abstract Folder getFolder(String name);

//    public abstract List<? extends Folder> getPersonalNamespaces(boolean forceListAll) throws MessagingException;

    public abstract void checkSettings() throws MessagingException;

    public boolean isCopyCapable()
    {
        return false;
    }
    public boolean isMoveCapable()
    {
        return false;
    }
    public boolean isPushCapable()
    {
        return false;
    }
    public boolean isSendCapable()
    {
        return false;
    }
    public boolean isExpungeCapable()
    {
        return false;
    }


//    public void sendMessages(Message[] messages) throws MessagingException
//    {
//    }

    public Pusher getPusher(PushReceiver receiver)
    {
        return null;
    }

    public Account getAccount()
    {
        return mAccount;
    }
}
package mobi.cloudymail.protocol.imap;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.atomic.AtomicInteger;

import android.content.Context;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

public class TracingPowerManager
{
    private final static boolean TRACE = false;
    public static AtomicInteger wakeLockId = new AtomicInteger(0);
    PowerManager pm = null;
    private static TracingPowerManager tracingPowerManager;
    private Timer timer = null;

    public static synchronized TracingPowerManager getPowerManager(Context context)
    {
        if (tracingPowerManager == null)
        {
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, "Creating TracingPowerManager");
            }
            tracingPowerManager = new TracingPowerManager(context);
        }
        return tracingPowerManager;
    }


    private TracingPowerManager(Context context)
    {
        pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        if (TRACE)
        {
            timer = new Timer();
        }
    }

    public TracingWakeLock newWakeLock(int flags, String tag)
    {
        return new TracingWakeLock(flags, tag);
    }
    public class TracingWakeLock
    {
        final WakeLock wakeLock;
        final int id;
        final String tag;
        volatile TimerTask timerTask;
        volatile Long startTime = null;
        volatile Long timeout = null;
        public TracingWakeLock(int flags, String ntag)
        {
            tag = ntag;
            wakeLock = pm.newWakeLock(flags, tag);
            id = wakeLockId.getAndIncrement();
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id+ ": Create");
            }
        }
        public void acquire(long timeout)
        {
            synchronized (wakeLock)
            {
                wakeLock.acquire(timeout);
            }
            if (K9.DEBUG)
            {
                Log.v(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id + " for " + timeout + " ms: acquired");
            }
            raiseNotification();
            if (startTime == null)
            {
                startTime = System.currentTimeMillis();
            }
            this.timeout = timeout;
        }
        public void acquire()
        {
            synchronized (wakeLock)
            {
                wakeLock.acquire();
            }
            raiseNotification();
            if (K9.DEBUG)
            {
                Log.w(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id + ": acquired with no timeout.  K-9 Mail should not do this");
            }
            if (startTime == null)
            {
                startTime = System.currentTimeMillis();
            }
            timeout = null;
        }
        public void setReferenceCounted(boolean counted)
        {
            synchronized (wakeLock)
            {
                wakeLock.setReferenceCounted(counted);
            }
        }
        public void release()
        {
            if (startTime != null)
            {
                Long endTime = System.currentTimeMillis();
                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id + ": releasing after " + (endTime - startTime) + " ms, timeout = " + timeout + " ms");
                }
            }
            else
            {
                if (K9.DEBUG)
                {
                    Log.v(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id + ", timeout = " + timeout + " ms: releasing");
                }
            }
            cancelNotification();
            synchronized (wakeLock)
            {
                wakeLock.release();
            }
            startTime = null;
        }
        private void cancelNotification()
        {
            if (timer != null)
            {
                synchronized (timer)
                {
                    if (timerTask != null)
                    {
                        timerTask.cancel();
                    }
                }
            }
        }
        private void raiseNotification()
        {
            if (timer != null)
            {
                synchronized (timer)
                {
                    if (timerTask != null)
                    {
                        timerTask.cancel();
                        timerTask = null;
                    }
                    timerTask = new TimerTask()
                    {
                        @Override
                        public void run()
                        {
                            if (startTime != null)
                            {
                                Long endTime = System.currentTimeMillis();
                                Log.i(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id + ": has been active for "
                                      + (endTime - startTime) + " ms, timeout = " + timeout + " ms");

                            }
                            else
                            {
                                Log.i(K9.LOG_TAG, "TracingWakeLock for tag " + tag + " / id " + id + ": still active, timeout = " + timeout + " ms");
                            }
                        }

                    };
                    timer.schedule(timerTask, 1000, 1000);
                }
            }
        }

    }
}

package mobi.cloudymail.protocol.imap;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;

import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import mobi.cloudymail.util.MyApp;
import android.app.Application;
import android.content.Context;
import android.util.Log;

public final class TrustManagerFactory
{
    private static final String LOG_TAG = "TrustManagerFactory";

    private static X509TrustManager defaultTrustManager;
    private static X509TrustManager unsecureTrustManager;
    private static X509TrustManager localTrustManager;

    private static X509Certificate[] lastCertChain = null;

    private static File keyStoreFile;
    private static KeyStore keyStore;


    private static class SimpleX509TrustManager implements X509TrustManager
    {
        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
        }

        public X509Certificate[] getAcceptedIssuers()
        {
            return null;
        }
    }

    private static class SecureX509TrustManager implements X509TrustManager
    {
        private static final Map<String, SecureX509TrustManager> mTrustManager =
            new HashMap<String, SecureX509TrustManager>();

        private final String mHost;

        private SecureX509TrustManager(String host)
        {
            mHost = host;
        }

        public synchronized static X509TrustManager getInstance(String host)
        {
            SecureX509TrustManager trustManager;
            if (mTrustManager.containsKey(host))
            {
                trustManager = mTrustManager.get(host);
            }
            else
            {
                trustManager = new SecureX509TrustManager(host);
                mTrustManager.put(host, trustManager);
            }

            return trustManager;
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
            defaultTrustManager.checkClientTrusted(chain, authType);
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException
        {
            TrustManagerFactory.setLastCertChain(chain);
            try
            {
                defaultTrustManager.checkServerTrusted(chain, authType);
            }
            catch (CertificateException e)
            {
                localTrustManager.checkServerTrusted(new X509Certificate[] {chain[0]}, authType);
            }
//            if (!DomainNameChecker.match(chain[0], mHost))
//            {
//                try
//                {
//                    String dn = chain[0].getSubjectDN().toString();
//                    if ((dn != null) && (dn.equalsIgnoreCase(keyStore.getCertificateAlias(chain[0]))))
//                    {
//                        return;
//                    }
//                }
//                catch (KeyStoreException e)
//                {
//                    throw new CertificateException("Certificate cannot be verified; KeyStore Exception: " + e);
//                }
//                throw new CertificateException("Certificate domain name does not match "
//                                               + mHost);
//            }
        }

        public X509Certificate[] getAcceptedIssuers()
        {
            return defaultTrustManager.getAcceptedIssuers();
        }

    }

    static
    {
        try
        {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance("X509");
            Application app = MyApp.instance();
            keyStoreFile = new File(app.getDir("KeyStore", Context.MODE_PRIVATE) + File.separator + "KeyStore.bks");
            keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            java.io.FileInputStream fis;
            try
            {
                fis = new java.io.FileInputStream(keyStoreFile);
            }
            catch (FileNotFoundException e1)
            {
                fis = null;
            }
            try
            {
                keyStore.load(fis, "".toCharArray());
                //if (fis != null) {
                // fis.close();
                //}
            }
            catch (IOException e)
            {
                Log.e(LOG_TAG, "KeyStore IOException while initializing TrustManagerFactory ", e);
                keyStore = null;
            }
            catch (CertificateException e)
            {
                Log.e(LOG_TAG, "KeyStore CertificateException while initializing TrustManagerFactory ", e);
                keyStore = null;
            }
            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        localTrustManager = (X509TrustManager)tm;
                        break;
                    }
                }
            }
            tmf = javax.net.ssl.TrustManagerFactory.getInstance("X509");
            tmf.init((KeyStore)null);
            tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        defaultTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }

        }
        catch (NoSuchAlgorithmException e)
        {
            Log.e(LOG_TAG, "Unable to get X509 Trust Manager ", e);
        }
        catch (KeyStoreException e)
        {
            Log.e(LOG_TAG, "Key Store exception while initializing TrustManagerFactory ", e);
        }
        unsecureTrustManager = new SimpleX509TrustManager();
    }

    private TrustManagerFactory()
    {
    }

    public static X509TrustManager get(String host, boolean secure)
    {
        return secure ? SecureX509TrustManager.getInstance(host) :
               unsecureTrustManager;
    }

    public static KeyStore getKeyStore()
    {
        return keyStore;
    }

    public static void setLastCertChain(X509Certificate[] chain)
    {
        lastCertChain = chain;
    }
    public static X509Certificate[] getLastCertChain()
    {
        return lastCertChain;
    }

    public static void addCertificateChain(String alias, X509Certificate[] chain) throws CertificateException
    {
        try
        {
            javax.net.ssl.TrustManagerFactory tmf = javax.net.ssl.TrustManagerFactory.getInstance("X509");
            for (X509Certificate element : chain)
            {
                keyStore.setCertificateEntry
                (element.getSubjectDN().toString(), element);
            }

            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null)
            {
                for (TrustManager tm : tms)
                {
                    if (tm instanceof X509TrustManager)
                    {
                        localTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }
            java.io.FileOutputStream keyStoreStream;
            try
            {
                keyStoreStream = new java.io.FileOutputStream(keyStoreFile);
                keyStore.store(keyStoreStream, "".toCharArray());
                keyStoreStream.close();
            }
            catch (FileNotFoundException e)
            {
                throw new CertificateException("Unable to write KeyStore: " + e.getMessage());
            }
            catch (CertificateException e)
            {
                throw new CertificateException("Unable to write KeyStore: " + e.getMessage());
            }
            catch (IOException e)
            {
                throw new CertificateException("Unable to write KeyStore: " + e.getMessage());
            }

        }
        catch (NoSuchAlgorithmException e)
        {
            Log.e(LOG_TAG, "Unable to get X509 Trust Manager ", e);
        }
        catch (KeyStoreException e)
        {
            Log.e(LOG_TAG, "Key Store exception while initializing TrustManagerFactory ", e);
        }
    }
}
package mobi.cloudymail.util;

import java.util.Stack;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;

public class BreakbleMessageLoop
{
	public static Stack<BreakbleMessageLoop> loopStack = new Stack<BreakbleMessageLoop>();
	static class LoopBreakException extends RuntimeException
	{
		public Message message;

		public LoopBreakException(Message msg)
		{
			this.message = msg;
		}
	}
	Handler mHandler = null;
	Runnable postRun = null;
	public void loop()
	{
		mHandler = new Handler(Looper.myLooper()) {
			@Override
			public void handleMessage(Message mesg)
			{
				// process incoming messages here
				// super.handleMessage(msg);
				throw new LoopBreakException(mesg);
			}
		};
		loopStack.push(this);
		boolean rerun=false;
		do
		{
			rerun=false;
			try
			{
				Looper.loop();
			}
			catch (RuntimeException e2)
			{
//				e2.printStackTrace();
//				if(e2.message.getTarget() != mHandler)
//				{
//					//this is not a message for me, pass this message continue
//					rerun = true;
//					Message copy = Message.obtain(e2.message);
//					copy.sendToTarget();
//					
//				}
//				Log.d(Utils.LOGTAG, "Loop break");
				
			}
		}while(rerun);
		loopStack.remove(this);
	}
	
	public void breakLoop()
	{
		Message msg = Message.obtain();
		
		msg.setTarget(mHandler);
//		int index = loopStack.indexOf(this);
//		if(index != loopStack.size()-1)
//		{
//			BreakbleMessageLoop innerLoop = loopStack.get(index+1);
//			innerLoop.postRun = new Runnable() {
//				
//				@Override
//				public void run()
//				{
//					
//					
//				}
//			};
//		}
		mHandler.sendMessage(msg);
	}
	
	
}
package mobi.cloudymail.util;

import static android.content.DialogInterface.BUTTON_NEGATIVE;
import static android.content.DialogInterface.BUTTON_POSITIVE;

public interface DialogResult
{
	public static final int OK = BUTTON_POSITIVE;
	public static final int CANCEL = BUTTON_NEGATIVE;
	public static final int YES = BUTTON_POSITIVE;
	public static final int NO = BUTTON_NEGATIVE;

}
package mobi.cloudymail.util;

import java.util.EnumSet;

import mobi.cloudymail.mailclient.R;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.view.KeyEvent;

public class DialogUtils
{
	public static enum ButtonFlags
	{
		OK, Cancel, Yes, No, Ignore
	};

	private static int result = 0;

	// show message box in blocking modal dialog
	public static int showModalMsgBox(final Context ctx, final String msg,
			final String title, final EnumSet<ButtonFlags> buttons)
			
	{
		final BreakbleMessageLoop myloop=new BreakbleMessageLoop(); ;

		Resources res = ctx.getResources();
		AlertDialog.Builder builder = new AlertDialog.Builder(ctx);
		builder.setMessage(msg).setCancelable(true).setTitle(title);
		if (buttons.contains(ButtonFlags.OK))
			builder.setPositiveButton(	res.getString(R.string.ok),
										new DialogInterface.OnClickListener() {
											public void onClick(DialogInterface dialog, int id)
											{
												DialogUtils.result = DialogResult.OK;
												myloop.breakLoop();
												dialog.dismiss();
											}
										});
		if (buttons.contains(ButtonFlags.Cancel))
			builder.setNegativeButton(	res.getString(R.string.cancel),
										new DialogInterface.OnClickListener() {
											public void onClick(DialogInterface dialog, int id)
											{
												DialogUtils.result = DialogResult.CANCEL;
												myloop.breakLoop();
												dialog.dismiss();
											}
										});
		if (buttons.contains(ButtonFlags.Yes))
			builder.setPositiveButton(	res.getString(R.string.yes),
										new DialogInterface.OnClickListener() {
											public void onClick(DialogInterface dialog, int id)
											{
												DialogUtils.result = DialogResult.OK;
												myloop.breakLoop(); 
												//dialog.dismiss();
											}
										});
		if (buttons.contains(ButtonFlags.No))
			builder.setNegativeButton(	res.getString(R.string.no),
										new DialogInterface.OnClickListener() {
											public void onClick(DialogInterface dialog, int id)
											{
												DialogUtils.result = DialogResult.CANCEL;
												myloop.breakLoop();
												dialog.dismiss();
											}
										});
		builder.setOnKeyListener(new DialogInterface.OnKeyListener() {
			
			@Override
			public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event)
			{
				if(keyCode == KeyEvent.KEYCODE_BACK)
				{
					dialog.dismiss();
					DialogUtils.result = DialogResult.CANCEL;
					myloop.breakLoop();
					return true;
				}
				return false;
			}
		});
		AlertDialog alert = builder.create();
		alert.show();

		myloop.loop();
		return result;
	}

	// show message box in non-blocking modal dialog

	/**
	 * DialogUtils.showMsgBox( this,
	 *  "Failed to change account: "+exp.getMessage(),
	 * getResources().getString(R.string.error)); }
	 */

	public static void showMsgBox(final Context ctx, String msg, String title)
	{
		AlertDialog.Builder builder = new AlertDialog.Builder(
																ctx != null	? ctx
																			: MyApp.instance());
		builder.setMessage(msg)
				.setCancelable(true)
				.setTitle(title)
				.setPositiveButton(ctx.getResources().getString(R.string.ok),
									new DialogInterface.OnClickListener() {
										public void onClick(
												DialogInterface dialog, int id)
										{
											// returnStatus = LOGIN_FAIL;
										}
									});
		AlertDialog alert = builder.create();
		alert.show();
	}

	// show sort message box

}
package mobi.cloudymail.util;

import java.util.EnumSet;

import mobi.cloudymail.util.DialogUtils.ButtonFlags;
import android.content.Context;

public class MessageBox
{
	public static void show(Context ctx,String msg, String title)
	{
		try
		{
			DialogUtils.showModalMsgBox(ctx, msg, title, EnumSet.of(ButtonFlags.OK));
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	
}
package mobi.cloudymail.util;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.UserSetting;
import mobi.cloudymail.mailclient.AccountManager;
import mobi.cloudymail.mailclient.PushManager;
import mobi.cloudymail.mailclient.ReceiveMailService;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.ServerAgent;

import org.apache.commons.lang.time.DateUtils;

import android.app.Activity;
import android.app.Application;
import android.os.Environment;
import android.util.Log;


public class MyApp extends Application {
	//debug flags
	public static boolean enablePush = true;
	public static boolean enableService = true;
	
	private static MyApp _instance;
	
	// use global variable for mail viewer.
	public static MailInfo curMailInfo = null;
	
	public static String SHARED_SETTING="setting";
	public static UserSetting userSetting = new UserSetting();
	public static Account currentAccount=null;
	// private static ServerAgent agent = null;
	private static Map<String, ServerAgent> _agents = new HashMap<String, ServerAgent>();
	
	private static List<Activity> _activities = new LinkedList<Activity>();
	
	private static Activity curActivity = null;

	private Timer pollTimer;
	private int pollInterval = 30; //in minutes
	private Date lastPollTime = new Date();
	public static MyApp instance() 
	{
		return _instance;
	}
	public static void setCurrentMailInfo(MailInfo info)
	{
		curMailInfo = info;
		if(info != null)
			currentAccount = AccountManager.getAccount(info.getAccountId());
	}
	@Override
	public void onCreate()
	{
		// TODO Auto-generated method stub
		super.onCreate();
		_instance = this;
	}
	
	public static void addActivity(Activity a)
	{
		_activities.add(a);
	}
	
	public static void setCurrentActivity(Activity act)
	{
		curActivity = act;
	}
	
	public static Activity getCurrentActivity()
	{
		return curActivity;
	}
	
	public static void finishAllActivities()
	{
		for(Activity a:_activities)
		{
			a.finish();
		}
		_activities.clear();
	}
	
	public String getAppSdcardPath()
	{
		File sdCardDir = Environment.getExternalStorageDirectory();
		File appDir = new File(sdCardDir.toString()+"/CloudyMail");
		if(!appDir.exists())
		{
			if(!appDir.mkdir())
				Log.d(LOGTAG,"Create directory failed!"+ appDir.toString());
		}
		return appDir.toString();
	}
	
	public static ServerAgent getAgent()
	{
		if(currentAccount==null)
			return null;
		return getAgent(currentAccount);
		/*
		 * if(agent == null || agent.account != currentAccount) { agent = new
		 * ServerAgent(currentAccount); } return agent;
		 */
	}
	public static ServerAgent getAgent(Account a)
	{
		if (!_agents.containsKey(a.name))
			_agents.put(a.name, new ServerAgent(a));
		return _agents.get(a.name);
	}

	public static void removeAgent(Account a){
		if(_agents.containsKey(a.name))
			_agents.remove(a.name);
	}
	
	//set interval of poll mail. If poll service is not started, start it.
	public void setPollInterval(int minutes)
	{
		pollInterval = minutes;
		if(pollTimer == null)
		{
			pollTimer = new Timer();
			pollTimer.schedule(new TimerTask() {
				
				@Override
				public void run()
				{
					Calendar calendar = Calendar.getInstance();
					Date currentTime = calendar.getTime();
					UserSetting setting = MyApp.userSetting;

					// 2011-12-14
					SimpleDateFormat mateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
					String tempTime = mateFormat.format(currentTime);

					String[] split2 = tempTime.split(" ");
					String[] split3 = split2[0].split("-");
					int year = Integer.parseInt(split3[0]);
					int month = Integer.parseInt(split3[1]);
					int day = Integer.parseInt(split3[2]);

					String muteTimeValue = MyApp.userSetting.getMuteTimeValue();
					String[] split = muteTimeValue.split("-");
					String[] splitStartTime = muteTimeValue.split("-");
					String[] startTime = splitStartTime[0].split(":");
					int startHour = Integer.parseInt(startTime[0]);
					int startMinute = Integer.parseInt(startTime[1]);
					int seconds = calendar.get(Calendar.SECOND);
					Date startMateTime = new Date(year - 1901, month + 11, day, startHour,
													startMinute, seconds);

					String[] endTime = splitStartTime[1].split(":");
					int endHour = Integer.parseInt(endTime[0]);
					int endMinute = Integer.parseInt(endTime[1]);
					Date endMuteTime = null;
					if (endHour < startHour)
					{
						endMuteTime = new Date(year - 1901, month + 11, day + 1, endHour,
												endMinute, seconds);
					}

					else
					{
						endMuteTime = new Date(year - 1901, month + 11, day, endHour,
												endMinute, seconds);
					}

					Log.d(LOGTAG, "currentTime:" + mateFormat.format(currentTime));
					Log.d(LOGTAG, "startMuteTime:" + mateFormat.format(startMateTime));
					Log.d(LOGTAG, "endMuteTime:" + mateFormat.format(endMuteTime));

					if (MyApp.userSetting.muteEnabled && currentTime.before(endMuteTime)
						&& currentTime.after(startMateTime))
						return; //it's in a silient time

					if (MyApp.userSetting.getPushFrequency() <= 0)
					{
						return;
					}
					
					
					if(DateUtils.addMinutes(lastPollTime, pollInterval).before(currentTime))
					{
						ReceiveMailService.SyncRequest r = new ReceiveMailService.SyncRequest();
						r.setAccountsToSync(AccountManager.getAccounts());
						ReceiveMailService.addToSyncQueue(r);
						lastPollTime = currentTime;
					}
					
				}
			}, 60*1000, 60*1000);
		}
	}
}
package mobi.cloudymail.util;

import static mobi.cloudymail.util.Utils.LOGTAG;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.List;
import java.util.Vector;

import mobi.cloudymail.data.FolderInfo;
import mobi.cloudymail.data.InMailInfo;
import mobi.cloudymail.data.MailInfo;
import mobi.cloudymail.data.MailStatus;
import mobi.cloudymail.data.OutMailInfo;
import mobi.cloudymail.mailclient.AddressBook;
import mobi.cloudymail.mailclient.EmailAddress;
import mobi.cloudymail.mailclient.FolderNames;
import mobi.cloudymail.mailclient.R;
import mobi.cloudymail.mailclient.net.Account;
import mobi.cloudymail.mailclient.net.AttachmentInfo;

import org.apache.commons.io.IOUtils;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import android.content.ContentValues;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;



public class NewDbHelper extends SQLiteOpenHelper
{
	
	private final static int DATABASE_VERSION_V12 = 4; //version of CloudyMail 1.2
	private final static int DATABASE_VERSION_V13 = 5; //version of CloudyMail 1.3
	private final static int DATABASE_VERSION_CURRENT = DATABASE_VERSION_V13;
	private final static String DATABASE_NAME = "client.db";
	private static String _dbFile;
	private static NewDbHelper _instance = null;
	public static final int ORDER_BY_DATE = 1;
	public static final int ORDER_BY_SUBJECT = 2;
	public static final int ORDER_BY_FROM = 3;
	public static final int ORDER_BY_UNREAD = 4;
	public static final int ORDER_BY_READED = 5;
	public static final int ORDER_BY_READEDSTATE = 6;
	public static final int ORDER_BY_ASTERISK = 7;
    
    
	/* finish */
	public static NewDbHelper getInstance()
	{
		
		if (_instance == null)
		{
			ApplicationInfo info = MyApp.instance()
					.getApplicationInfo();
			_dbFile = info.dataDir + "/databases/" + DATABASE_NAME;
			File dbF = new File(_dbFile);
			if (!dbF.exists())
			{
				try
				{
					{
						File dir = new File(info.dataDir + "/databases");
						boolean rst;
						if (!dir.exists())
						{
							rst = dir.mkdirs();
						}
						InputStream s = MyApp.instance().getAssets()
								.open(DATABASE_NAME);
						FileOutputStream fo = new FileOutputStream(_dbFile);
						IOUtils.copy(s, fo);
						s.close();
						fo.close();
					}
				}
				catch (Exception e)
				{
					e.printStackTrace();
				}
			}
			_instance = new NewDbHelper(MyApp.instance());
			
			int version = _instance.executScalar("select value from sysconfig where name='clientVersion'", null);
			if(version < DATABASE_VERSION_V13)
			{
				_instance.upgradeToV13(version);
			}
		}
		return _instance;
	}
	@Override
	public void onCreate(SQLiteDatabase db)
	{
		// if database not existed, this function will be invoked.
		Log.d(LOGTAG,"onCreate"+ "database file not exists");
	}

	private NewDbHelper(Context context)
	{
		super(context, DATABASE_NAME, null, DATABASE_VERSION_CURRENT);
	}

	@Override
	public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)
	{
		// if version is higher, this function will be called.

		/*
		 * String sql = "drop table if exists [t_contacts]"; db.execSQL(sql); //
		 * 濠殿界缚㈡恒跨告婚风芥瀚归跨告婚风芥缁插荤叉风芥绲ql = "CREATE TABLE [t_contacts] (" + "[id] AUTOINC," +
		 * "[name] VARCHAR(20) NOT NULL ON CONFLICT FAIL," +
		 * "[telephone] VARCHAR(20) NOT NULL ON CONFLICT FAIL," +
		 * "[email] VARCHAR(20)," + "[photo] BINARY, " +
		 * "CONSTRAINT [sqlite_autoindex_t_contacts_1] PRIMARY KEY ([id]))";
		 * db.execSQL(sql);
		 */

//		upgradeToV12(db);
	}

	
	
	// execute insert,update,delete statement
	public void execSQL(String sql, Object[] args)
	{
		SQLiteDatabase db = this.getWritableDatabase();
		db.execSQL(sql, args);
	}

	// execute batch of sql statement
	/*
	 * public void execSQLBatch(String []sql, Object[] args) { SQLiteDatabase db
	 * = this.getWritableDatabase(); db.beginTransaction(); for(int i = 0; i <
	 * 100; i++) db.execSQL(sql, args); db.setTransactionSuccessful();
	 * db.endTransaction(); }
	 */

	// select statement.
	public Cursor query(String sql, String[] args)
	{
		SQLiteDatabase db = this.getReadableDatabase();
		Cursor cursor = db.rawQuery(sql, args);
		return cursor;
	}

	public int executScalar(String sql, String[] args)
	{
		SQLiteDatabase db = this.getReadableDatabase();
		Cursor cursor = db.rawQuery(sql, args);
		int result = 0;
		if (cursor.moveToFirst())
			result = cursor.getInt(0);
		cursor.close();
		return result;
	}

	// convenience method for loading accounts.


	// return error string if failed.
	public String addAccount(Account a)
	{
		SQLiteDatabase db = this.getReadableDatabase();
		String queryTxt = "select count(id) from account where name='" + a.name
							+ "'";
		Cursor cursor = db.rawQuery(queryTxt, null);
		if (cursor == null)
			return "Cursor is null";
		String errStr = "";
		cursor.moveToFirst();
		if (cursor.getInt(0) > 0)
		{
			errStr = MyApp.instance().getResources()
					.getString(R.string.err_accountExist);
			cursor.close();
			return errStr;
		}
//		String[] argsStrings = { a.name, a.loginName, a.mailServer,
//								a.getMailPort() + "", a.smtpServer,
//								a.smtpPort + "", a.serverType,
//								(a.useSSL ? 1 : 0) + "" };
//		String CommandText = "insert into account (name, loginName, mailServer, "
//								+ "mailPort, smtpServer, smtpPort, serverType, useSSL) "
//								+ "values(?,?,?,?,?,?,?,?)";
		//encryption
		String encryptPassword = null;
		try
		{
			 encryptPassword = SimpleCrypto.encrypt("&cloudyServices@cloudymail.mobi&",a.password);
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		String[] argsStrings = { a.name, a.loginName, a.mailServer,
								a.getMailPort() + "", a.smtpServer,
								a.smtpPort + "", a.serverType,
								(a.useSSL ? 1 : 0) + "", encryptPassword};
//		(a.useSSL ? 1 : 0) + "", a.password };
		
		
		String CommandText = "insert into account (name, loginName, mailServer, "
								+ "mailPort, smtpServer, smtpPort, serverType, useSSL, password) "
								+ "values(?,?,?,?,?,?,?,?,?)";
		this.getWritableDatabase().execSQL(CommandText, argsStrings);

		CommandText = "select id from account where rowid=last_insert_rowid()";
		cursor.close();
		cursor = db.rawQuery(CommandText, null);
		if (cursor == null)
			return "Cursor is null";
		cursor.moveToFirst();
		a.id = cursor.getInt(0);
		cursor.close();
		return errStr;
	}

	public String deleteAccount(Account a)
	{
		String errStr = "";
		SQLiteDatabase db = getWritableDatabase();
		// try {
		String cmdTxt = "delete from account where name=?";
		String[] args = { a.name };
		db.beginTransaction();
		db.execSQL(cmdTxt, args);

		// the mails belonged to this account will also be deleted.
		cmdTxt = "delete from mail where accountId=" + a.id;
		db.execSQL(cmdTxt);

		cmdTxt= "delete from folders where accountid="+a.id;
		db.execSQL(cmdTxt);
		
		cmdTxt= "delete from attachmentInfo where accountid="+a.id;
		db.execSQL(cmdTxt);
		cmdTxt= "delete from mailGroup where accountid="+a.id;
		db.execSQL(cmdTxt);
		
		db.setTransactionSuccessful();
		db.endTransaction();
		// } catch (SQLException e) {
		// errStr = e.getMessage();
		// }
		return errStr;
	}
	
	public void deleteAccountMails(int accountId)
	{
		SQLiteDatabase db = getWritableDatabase();
		String cmdTxt = "delete from mail where accountId=" + accountId;
		db.execSQL(cmdTxt);
	}

	public String updateAccount(Account a, String oldAccountName)
	{
		String errStr = "";
		try
		{
			// check whether the old account name existed.
			String queryTxt = "select count(id) from account where name=?";
			String[] args = { oldAccountName };
			SQLiteDatabase db = this.getReadableDatabase();
			Cursor cursor = db.rawQuery(queryTxt, args);
			if (cursor == null)
				return "Cursor is null";
			cursor.moveToFirst();
			if (cursor.getInt(0) < 1)
			{
				errStr = String
						.format(MyApp
										.instance()
										.getResources()
										.getString(	R.string.err_oldAccountNotExist),
								oldAccountName);
				cursor.close();
				return errStr;
			}
			// check the new account name has been existed.
			if (!a.name.equals(oldAccountName))
			{
				queryTxt = "select count(id) from account where name='"
							+ a.name + "'";
				cursor.close();
				cursor = db.rawQuery(queryTxt, null);
				cursor.moveToFirst();
				if (cursor.getInt(0) > 0)
				{
					errStr = MyApp.instance().getResources()
							.getString(R.string.err_accountExist);
					cursor.close();
					return errStr;
				}
			}
			String encryptPassword = SimpleCrypto.encrypt("&cloudyServices@cloudymail.mobi&", a.password);
			String CommandText = "update account set name='" + a.name
									+ "',loginName='" + a.loginName
									+ "',password='" + encryptPassword
									+ "',mailServer='" + a.mailServer
									+ "',mailPort=" + a.getMailPort()
									+ ",smtpServer='" + a.smtpServer
									+ "',smtpPort=" + a.smtpPort
									+ ",serverType='" + a.serverType
									+ "',useSSL=" + (a.useSSL ? 1 : 0)
									+ " where name='" + oldAccountName + "'";
			getWritableDatabase().execSQL(CommandText);
			cursor.close();
			return errStr;
		}
		catch (Exception e)
		{
			e.printStackTrace();
			errStr = e.getMessage();
			return errStr;
		}
	}

	public String updateAccountPassword(String passwd, int id)
	{
		String encryptPassword = null;
	    try
		{
			encryptPassword = SimpleCrypto.encrypt("&cloudyServices@cloudymail.mobi&",passwd);
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		String sql = "update account set password='" + encryptPassword + "' where id='"
						+ id + "'";
		getWritableDatabase().execSQL(sql);
		return "";
	}

	// //////////////////////////////////////
	public String loadAddressBook()
	{
		Cursor cursor = query("select * from addressbook", null);
		AddressBook.addressArry.clear();
		if (cursor == null)
			return "Cursor is null";
		int nameIdx = cursor.getColumnIndex("name");
		int emailIdx = cursor.getColumnIndex("email");
		if (cursor.moveToFirst())
		{
			do
			{
				String name = cursor.getString(nameIdx);
				String address = cursor.getString(emailIdx);
				AddressBook.addressArry.add(new EmailAddress(name, address));
			} while (cursor.moveToNext());
		}
		cursor.close();
		return "";
	}

	public String addEmailAddress(EmailAddress ea)
	{
		String errStr = "";
		String queryTxt = "select count(name) from addressbook where email=?";
		String[] args = { ea.getAddress() };
		int count = executScalar(queryTxt, args);
		if (count > 0)
		{
			errStr = MyApp.instance().getResources()
					.getString(R.string.err_accountExist);
			return errStr;
		}

		String CommandText = "insert into addressbook (name, email) values(?,?)";
		String[] argsString = { ea.getName(), ea.getAddress() };
		execSQL(CommandText, argsString);
		return errStr;
	}

	public String deleteEmailAddress(EmailAddress ea)
	{
		String cmdTxt = "delete from addressbook where email='"
						+ ea.getAddress() + "'";
		execSQL(cmdTxt, new Object[] {});
		return "";
	}

	public String updateEmailAddress(EmailAddress ea, String oldAddress)
	{
		String errStr = "";
		// check whether the old address.
		String queryTxt = "select count(name) from addressbook where email=?";
		String[] args = { oldAddress };
		int count = executScalar(queryTxt, args);
		if (count < 1)
		{
			errStr = String.format(MyApp.instance().getResources()
					.getString(R.string.err_oldAccountNotExist), oldAddress);
			return errStr;
		}
		// check the new address has been existed.
		if (!ea.getAddress().equals(oldAddress))
		{
			queryTxt = "select count(name) from addressbook where email=?";
			String[] tmpArgs = { ea.getAddress() };
			count = executScalar(queryTxt, tmpArgs);
			if (count > 0)
			{
				errStr = MyApp.instance().getResources()
						.getString(R.string.err_accountExist);
				return errStr;
			}
		}
		String CommandText = "update addressbook set name=? ,email=? where email=?";
		String[] args1 = { ea.getName(), ea.getAddress(), oldAddress };
		execSQL(CommandText, args1);
		return errStr;
	}
	
	public void saveOutMail(OutMailInfo mailInfo)
	{
		ContentValues cv = new ContentValues();
		cv.put("accountId", mailInfo.getAccountId());
		cv.put("`to`", mailInfo.getTo());
		cv.put("cc", mailInfo.getCc());
		cv.put("bc", mailInfo.getBc());
		cv.put("body", mailInfo.getBody());
		cv.put("refUid", mailInfo.getUid());
		cv.put("subject", mailInfo.getSubject());
		cv.put("refBody", mailInfo.getRefBodyFlag());
		cv.put("mailType", mailInfo.getMailType());
		
		StringBuffer attacheStr = new StringBuffer();
		List<AttachmentInfo> attaches = mailInfo.getAttachments();
		for (AttachmentInfo info : attaches)
		{
			if(attacheStr.length() > 0)
				attacheStr.append(";");
			if(info.index < 0)//local attachment
				attacheStr.append(info.index+":"+info.fullFilePath);
			else
				attacheStr.append(info.index + ":" + info.fileName+":"+info.size);
		}
		
		cv.put("attachments",attacheStr.toString());
		cv.put("folder", mailInfo.getFolder());
		
		SQLiteDatabase db = getWritableDatabase();
		int mailId = mailInfo.getUidx();
		if (mailId >= 0)//if it's an existing mail.
		{
			String[] args = { mailId+"" };
			db.update("outBox", cv, "ID=?", args);
		}
		else
		{
			mailInfo.setUidx((int)db.insert("outBox", null, cv));
		}
		}
/*	
	public int saveOutMail(int mailId, int accountId, DataPacket dp,String folderName)
	{
		ContentValues cv = new ContentValues();
		cv.put("accountId", accountId);
		cv.put("`to`", dp.toList);
		cv.put("cc", dp.ccList);
		cv.put("body", dp.bodyText);
		cv.put("refUid", dp.refMailId);
		cv.put("subject", dp.subject);
		
		StringBuffer attaches = new StringBuffer();
		for (AttachmentInfo info : dp.attachments)
		{
			if(attaches.length() > 0)
				attaches.append(";");
			if(info.index < 0)//local attachment
				attaches.append(info.index+":"+info.fullFilePath);
			else
				attaches.append(info.index + ":" + info.fileName+":"+info.size);
		}
		
		cv.put("attachments",attaches.toString());
		cv.put("folder", folderName);
		
		SQLiteDatabase db = getWritableDatabase();
		if (mailId >= 0)//if it's an existing mail.
		{
			String[] args = { mailId+"" };
			int updateCount = db.update("outBox", cv, "ID=?", args);
			if(updateCount > 0)
				return mailId;
		}
		return (int)db.insert("outBox", null, cv);
	}*/

	// ////////////////////////////////////////////////
	//if mailId is not valid, then update the mail in outBox
/*	public String saveOutMail(int accountId, DataPacket dp,String folderName)
	{
		// 婵锝娴风芥瀚归跨诲Г椤浠澶抽跨烘叉瀚??
		// <attaches> = <attach> [; <attaches> ]
		// <attach> = <RemoteAttach> | <LocalAttach>
		// <RemoteAttach> = <index>:<Positive number>:<size>
		// <LocalAttach> = <index>:<full_file_path>
		String comTxt;
		comTxt = "insert into outBox (accountId,`to`,cc,"
					+ "body,refUid,subject,attachments,folder) "
					+ "values(?,?,?,?,?,?,?,?)";
		StringBuffer attaches = new StringBuffer();
		for (AttachmentInfo info : dp.attachments)
		{
			if(attaches.length() > 0)
				attaches.append(";");
			if(info.index < 0)//local attachment
				attaches.append(info.index+":"+info.fullFilePath);
			else
				attaches.append(info.index + ":" + info.fileName+":"+info.size);
		}

		String[] args = { accountId + "", dp.toList, dp.ccList, dp.bodyText,
							dp.refMailId, dp.subject, attaches.toString(),
							folderName};

		execSQL(comTxt, args);
		return "";
	}*/

	// ////////////////////////////////////////
	public int getCurrentAccountId()
	{
		SQLiteDatabase db = getReadableDatabase();
		Cursor cursor = db.rawQuery("select accountId from outBox", null);
		int curId = -1;
		if (cursor.moveToFirst())
			curId = cursor.getInt(0);
		cursor.close();
		return curId;
	}

	/***************************************/
/*	public Cursor fetchData(String folderName)
	{
		String str_sql = "select count(folder) from mail where folder=";
		if (folderName.equals(FolderManager.FOLDER_INBOX))
		{
			str_sql += "`FolderManager.FOLDER_INBOX`";
		}
		else if (folderName.equals(FolderManager.FOLDER_DRAFT))
		{
			str_sql += "`FolderManager.FOLDER_DRAFT`";
		}
		else if (folderName.equals(FolderManager.FOLDER_SEND))
		{
			str_sql += "`FolderManager.FOLDER_SENT`";
		}
        
		Cursor folder_Cursor = query(str_sql, null);

		return folder_Cursor;

	}*/

	public Cursor getOutMails(int accountId, int length, int offset,
			int orderType, String folderName)
	{
		return getOutMails(accountId,length,offset,orderType,folderName,null);
	}
	
	public Cursor getOutMails(int accountId, int length, int offset,
			int orderType, String folderName,String searchWord)
	{
		String sql = "select * from outBox"+
					getMailWhereSql(accountId, folderName, 
					                new int[]{MailStatus.MAIL_NEW, MailStatus.MAIL_READED},
					                false, searchWord);
		sql += getOrderSql(orderType);
		sql += " limit " + length + " offset " + offset;
		return query(sql, null);
	}
	
	public Cursor getDelOutMails(int accountId, int length, int offset,String searchWord)
	{
		String sql = "select * from outBox"+
					getMailWhereSql(accountId, "", 
					                new int[]{MailStatus.MAIL_LOCAL_DELETED},
					                false, searchWord);
		sql += " limit " + length + " offset " + offset;
		return query(sql, null);
	}

	public Cursor getInMails(int accountId, int length, int offset,
			int orderType, String folderName,
			boolean excludeHasMore,String searchWord)
	{
		String sql = "select * from mail"+
					getMailWhereSql(accountId, folderName, 
					                new int[]{MailStatus.MAIL_NEW, MailStatus.MAIL_READED},
					                excludeHasMore, searchWord);
		sql += getOrderSql(orderType);
		sql += " limit " + length + " offset " + offset;
		Log.d(LOGTAG,"getInMails"+ sql);
		return query(sql, null);
	}
	
	public Cursor getDelInMails(int accountId, int length, int offset,String searchWord)
	{
		String sql = "select * from mail"+
					getMailWhereSql(accountId, "", 
					                new int[]{MailStatus.MAIL_LOCAL_DELETED},
					                true, searchWord);
		sql += " limit " + length + " offset " + offset;
		return query(sql, null);
	}
	
	private String getOrderSql(int orderType)
	{
		String sqlOrder = " order by ";
		if (orderType == ORDER_BY_DATE)
		{
			sqlOrder += "date desc";
		}
		else if (orderType == ORDER_BY_SUBJECT)
		{
			sqlOrder += "subject asc, date desc";
		}
		else if (orderType == ORDER_BY_FROM)
		{
			sqlOrder += "`from` asc, date desc";
		}
		else if (orderType == ORDER_BY_READEDSTATE)
		{
			sqlOrder += "state asc, date desc";
		}
		else if (orderType == ORDER_BY_ASTERISK)
		{
			sqlOrder += "asterisk desc, date desc";
		}
		
		return sqlOrder;
	}
	private String getGroupOrderSql(int orderType)
	{
		String sqlOrder = " order by ";
		if (orderType == ORDER_BY_DATE)
		{
			sqlOrder += "date desc";
		}
		else if (orderType == ORDER_BY_SUBJECT)
		{
			sqlOrder += "suffix asc, date desc";
		}
		else if (orderType == ORDER_BY_FROM)
		{
			sqlOrder += "`from` asc, date desc";
		}
		else if (orderType == ORDER_BY_READEDSTATE)
		{
			sqlOrder += " date desc";
		}
		else if (orderType == ORDER_BY_ASTERISK)
		{
			sqlOrder += " date desc";
		}
		
		return sqlOrder;
	}
	public String updateOutMailStatus(Vector<Integer> accountIds, Vector<Integer> ids, int state)
	{
		SQLiteDatabase db = getWritableDatabase();
		String cmdTxt;
		if(state == MailStatus.MAIL_DELETE_FOREVER)
			cmdTxt = "delete from outBox where ID=? and accountId=?";
		else
			cmdTxt = "update outBox set state=" + state
						+ " where ID=? and accountId=?";

		db.beginTransaction();
		for (int i = 0; i < ids.size(); i++)// too slow.
		{
			int id = ids.get(i);
			if (id < 0)
				continue;
			String[] args = { id+"",accountIds.get(i)+""};
			db.execSQL(cmdTxt, args);
		}
		db.setTransactionSuccessful();
		db.endTransaction();
		return "";
	}
	

	public void updateMailBody(InMailInfo mailInfo)
	{
		SQLiteDatabase db = getWritableDatabase();
		ContentValues cv = new ContentValues();
		cv.put("body", mailInfo.getBody());
		String[] args = { mailInfo.getUid(),mailInfo.getAccountId()+"",mailInfo.getFolder()};
		db.update("mail", cv, "uid=? and accountId=? and folder=?",args);
		/*String cmdTxt = "update mail set body='"+mailInfo.getBody()
						+"' where uid=? and accountId=?";
		String[] args = { mailInfo.getUid(),mailInfo.getAccountId()+""};
		db.execSQL(cmdTxt, args);*/
	}
	public String updateInMailStatus(Vector<Integer> accountIds, Vector<Integer> uidxs, 
								int state,Vector<String> folders)
	{
		SQLiteDatabase db = getWritableDatabase();
		String cmdTxt;
//		if(state == MailStatus.MAIL_DELETE_FOREVER)
//			cmdTxt = "delete from mail where uidx=? and accountId=?";
//		else
//			cmdTxt = "update mail set state=" + state
//						+ " where uidx=? and accountId=?";
		cmdTxt = "update mail set state=" + state + " where uidx=? and accountId=? and folder=?";
		db.beginTransaction();
		for (int i = 0; i < uidxs.size(); i++)// too slow.
		{
			int uidx = uidxs.get(i);
			if (uidx < 0)
				continue;
			String[] args = { uidxs.get(i)+"", accountIds.get(i)+"",folders.get(i)};
			db.execSQL(cmdTxt, args);
		}
		db.setTransactionSuccessful();
		db.endTransaction();
		return "";
	}
	
	private String getMailWhereSql(int accountId, 
			String folderName, 
			int[] states,
			boolean excludeHasMore, 
			String searchWord)
	{
		StringBuffer sqlBuf = new StringBuffer();//("select count(*) from mail");
		if(!folderName.equals(""))
			sqlBuf.append(" folder='"+folderName+"'");
//		if(!folderName.equals(FolderNames.FOLDER_DELETE)&&state != MailStatus.MAIL_INVALID_STATE)
//		{
//				if(sqlBuf.length() > 0)
//					sqlBuf.append(" and");
//				sqlBuf.append(" state").append(stateExcludeFlag?"!=":"=");
//				sqlBuf.append(state+"");
//		}
		
		if(states != null && states.length > 0)
		{
			if(sqlBuf.length() > 0)
				sqlBuf.append(" and");
			sqlBuf.append(" state in (");
			for(int i=0;i<states.length;i++)
			{
				if(i>0)
					sqlBuf.append(",");
				sqlBuf.append(states[i]);
			}
			if(!excludeHasMore)
			{
				for(int i=0;i<states.length;i++)
				{
					sqlBuf.append(",");
					sqlBuf.append(states[i] | MailStatus.FLAG_HAS_MORE_PLACEHOLD);
				}
			}
			sqlBuf.append(") ");
			
		}
		
		if(accountId > 0)
		{
			if(sqlBuf.length() > 0)
				sqlBuf.append(" and");
			sqlBuf.append(" accountId="+accountId);
		}

		if(searchWord!=null && !searchWord.equals(""))
        {
			if (sqlBuf.length() > 0)
				sqlBuf.append(" and");
//        	sqlBuf.append(" subject like '%"+ searchWord +"%'");	dd
//			(subject like '%"+ floatingSearch +"%' or `from` like '%"+floatingSearch+"%')
        	sqlBuf.append(" (subject like '%"+ searchWord +"%' or `from` like '%"+searchWord+"%')");
        }
		if(sqlBuf.length() > 0)
			return " where "+sqlBuf.toString();
		else
			return "";
	}
	
	public int getInMailCount(int accountId, String folderName, int[] states,
			 boolean excludeHasMore)
	{
		return getInMailCount(accountId,folderName,states,
		                       excludeHasMore,null);
	}
	
	public int getInMailCount(int accountId, String folderName, int[] states,
			boolean excludeHasMore, String searchWord)
	{
		String sql = "select count(*) from mail" 
			+ getMailWhereSql(accountId,folderName,states,
			                  excludeHasMore,searchWord);
		return executScalar(sql, null);
	}
	
	public int getOutMailCount(int accountId, String folderName, int[] states)
	{
		return getOutMailCount(accountId,folderName,states,null);
	}
	
	public int getOutMailCount(int accountId, String folderName, int[] states,
			String searchWord)
	{
		String sql = "select count(*) from outBox"
			+ getMailWhereSql(accountId,folderName,states,
			                  false,searchWord);
		return executScalar(sql, null);
	}

	public void setMailAttachment(String uid,String folderName, int attachFlag)
	{
		String cmdTxt = "update mail set hasAttach="+attachFlag+" where uid=? and folder='"+folderName+"'";
		String[] args = { uid };
		execSQL(cmdTxt, args);
	}
//	public String updateAccountPassword(String passwd, int id)
//	{
//		String sql = "update account set password='" + passwd + "' where id='"
//						+ id + "'";
//		getWritableDatabase().execSQL(sql);
//		return "";
//	}
//	public String updateInMailStatus(int[] accountIds, int[] uidxs, 
//			int state)
//{
//SQLiteDatabase db = getWritableDatabase();
//String cmdTxt;
//if(state == MailStatus.MAIL_DELETE_FOREVER)
//cmdTxt = "delete from mail where uidx=? and accountId=?";
//else
//cmdTxt = "update mail set state=" + state
//	+ " where uid=? and accountId=?";
//
//db.beginTransaction();
//for (int i = 0; i < uidxs.length; i++)// too slow.
//{
//int uidx = uidxs[i];
//if (uidx < 0)
//continue;
//String[] args = { uidxs[i]+"", accountIds[i]+""};
//db.execSQL(cmdTxt, args);
//}
//db.setTransactionSuccessful();
//db.endTransaction();
//return "";
//}
	// "update mail set  subject=?, date=?, 'from'=?, 'to'=?, cc=?, uidx=?, state=? folder="+MailInfo.FOLDER_INBOX+"where uid=? and accountId="
	// + accountId;
    public void updateInAsteriskstatu(int accountId,int asteriskValue,Integer uidx, String folderName)
    {
    	SQLiteDatabase db=getWritableDatabase();
    
    	String comTxt="update mail set asterisk='"+asteriskValue+"' where uidx='"+uidx+"' and folder='"+folderName +"' and accountId='"+accountId+"'" ;
//    	String comTxt="update mail set asterisk=1 where uidx=85 and folder=inbox and accountId=3 ;
//    	String comTxt="update mail set asterisk=?,"
    	db.execSQL(comTxt);
    	
    }
    public void updateOutAsteriskstatu(int accountId,int asteriskValue,Integer uidx)
    {
    	SQLiteDatabase db=getWritableDatabase();
    	String comTxt="update outBox set asterisk='"+asteriskValue+"' where ID='"+uidx+"' and accountId='"+accountId+"'" ;
//    	Integer [] args={asteriskValue};
    	db.execSQL(comTxt);
    }
//    public int getCurrentAccountId()
//	{
//		SQLiteDatabase db = getReadableDatabase();
//		Cursor cursor = db.rawQuery("select accountId from outBox", null);
//		int curId = -1;
//		if (cursor.moveToFirst())
//			curId = cursor.getInt(0);
//		cursor.close();
//		return curId;
//	}
    public int getAsterisk()
    {
       SQLiteDatabase db=getReadableDatabase();
       Cursor cursor=db.rawQuery("select asterisk from mail", null);
       int curId=-1;
       if(cursor.moveToFirst())
    	   curId=cursor.getInt(0);
    	return curId;

    }
	public void  insertMailsToDb(MailInfo info, int accountId)
	{
		try
		{
			String folderName=info.getFolder();
			String cmd2 = "insert into mail (uid, subject, date, 'from', 'to', cc, uidx, state, hasAttach,accountId,folder,groupId) values(?,?,?,?,?,?,?,?,?, "
							+ accountId
							+ ","
							+ "'"
							+ folderName + "',?)";
			
			String uid =info.getUid();
			int ct = executScalar(	"select count(*) from mail where uid=? and accountId=? and folder='"+folderName+"'",
									new String[] { uid, accountId + "" });

			int state = info.getState();
			int attachementFlag =info.getAttachmentFlag();
			long groupId = updateMailGroup(info);
			
			if (ct == 0)
			{
				String[] args = { 
									uid,
									info.getSubject(),
									Utils.netDateFormater.format(info.getDate()),
									
									info.getFrom(),
									info.getTo(),
									info.getCc(),
									info.getUidx()+"", 
									state + "",
									attachementFlag+"",
				                    String.valueOf(groupId)};
				execSQL(cmd2, args);
			}
			else
			{
				String cmd3="select state from mail where uid=? and accountId= " + accountId+" and folder='"+ folderName + "'";
				Cursor cursor=query(cmd3, new String[]{uid});
				try
				{
					if(cursor.moveToFirst())
					{
						int currentStateInDB=cursor.getInt(0);
						if(state==MailStatus.MAIL_DELETED&&(currentStateInDB & MailStatus.FLAG_HAS_MORE_PLACEHOLD)!=0)
							return;
					}
				}
				finally
				{
					cursor.close();
				}
				cmd3 = "update mail set  subject=?, date=?, 'from'=?, 'to'=?, cc=?, uidx=?, state=?,hasAttach=?,groupId=?,folder='"
						+ folderName
						+ "' where uid=? and accountId= " + accountId+" and folder='"+ folderName + "'";
				String[] args = { info.getSubject(),
									Utils.netDateFormater.format(info.getDate()),
									info.getFrom(),
									info.getTo(),
									info.getCc(),
									info.getUidx()+"", 
									state + "",
									attachementFlag+"",
									groupId+"",
									uid };
				execSQL(cmd3, args);
			}
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
		}
	}

	public int insertMailsToDb(Element xmlReader, int accountId)
	{
		int mailCount = 0;
		try
		{
			NodeList mailElements = xmlReader.getElementsByTagName("mail");
			for (int i = 0; i < mailElements.getLength(); i++)
			{
				Element xr = (Element) mailElements.item(i);
				if(Utils.isEmpty(xr.getAttribute("date")))
					break;
				MailInfo mailInfo=new InMailInfo(accountId, xr);
				
				insertMailsToDb(mailInfo, accountId);
				if(mailInfo.getState()==MailStatus.MAIL_NEW)
					mailCount++;
			}
			
		}
		catch (Exception ex)
		{
			ex.printStackTrace();
		}
		
		return mailCount;
	}
	/*
	 * 邮件组更新的规则：
	 * 1. 对于普通邮件，首先找到这个邮件对应的分组，如果不存在就新建分组。返回MailGroup的ID.这个ID被记录到mail表中。
	 * 2. 对于HAS_MORE_PLACEHOLD，一定要在MailGroup中新建一个分组。
	 * 3. 对于普通邮件，如果找到这个邮件相同UID, account id的HAS_MORE_PLACEHOLD，也就是说，这个邮件在上次接收时被当作占位符，
	 *    本次接收中才被更新成为普通邮件。那么，首先删除之前的占位符，然后进行步骤1.并将这个邮件对应的group id更新。
	 */
	private long updateMailGroup(MailInfo mailInfo) {
		SQLiteDatabase db = getWritableDatabase();
		if((mailInfo.getState() & MailStatus.FLAG_HAS_MORE_PLACEHOLD) != 0)
		{//rule 2
		    ContentValues initialValues = new ContentValues();
		    initialValues.put("accountId", mailInfo.getAccountId());
		    initialValues.put("suffix", mailInfo.getSubject());
		    initialValues.put("'from'", mailInfo.getFrom());
		    initialValues.put("'date'", Utils.netDateFormater.format(mailInfo.getDate()));
		    initialValues.put("'accountId'", mailInfo.getAccountId());
		    initialValues.put("'folderName'", mailInfo.getFolder());
		    return db.insert("mailGroup", null, initialValues);

		}
		
		//rule 3
		Cursor cursor = _instance.query("select groupId from mail where uid=? and accountid=? and state >=?", new String[] {mailInfo.getUid(), mailInfo.getAccountId()+"", MailStatus.FLAG_HAS_MORE_PLACEHOLD+""});
		if(cursor.moveToFirst())
		{
			long groupid = cursor.getInt(0);
			_instance.execSQL("delete from mailGroup where id=?", new Object[] {groupid});
		}
		cursor.close();
		
		String suffixStr = findSuffix(mailInfo.getSubject());
		
		String cmd="select id from mailGroup where suffix=? and accountId=? and folderName=?";
		String [] arg={suffixStr, mailInfo.getAccountId()+"", mailInfo.getFolder()};
		long groupId = _instance.executScalar(cmd, arg);
		
		if(groupId==0)
		{
		    ContentValues initialValues = new ContentValues();
		    initialValues.put("accountId", mailInfo.getAccountId());
		    initialValues.put("suffix", suffixStr);
		    initialValues.put("'from'", mailInfo.getFrom());
		    initialValues.put("'date'", Utils.netDateFormater.format(mailInfo.getDate()));
		    initialValues.put("'accountId'", mailInfo.getAccountId());
		    initialValues.put("'folderName'", mailInfo.getFolder());
		    groupId = db.insert("mailGroup", null, initialValues);
		}
		 else
		 {
			
			String updateGroupCmd="update mailGroup set 'from'=?,date=? where date<? and id=?"; 
			String dateStr = Utils.netDateFormater.format(mailInfo.getDate());
		    String []args={ 
		            		mailInfo.getFrom(),
		            		dateStr,
		            		dateStr,
							groupId+""
		                  };
		    db.execSQL(updateGroupCmd, args);
		 }
		return groupId;
	}

	private  String findSuffix(String subject) 
	{
		String[] prefixes = new String[] {"Re:","Fwd:","回复:","转发:","答复:",
		                                  "Re：","Fwd：","回复：","转发：","答复："};
		if(subject!=null)
		{
			subject = subject.trim();
			for(String prefix:prefixes)
			{
				if(subject.startsWith(prefix))
					return findSuffix(subject.substring(prefix.length()));
			}
		}
		return subject;
	}
	public ArrayList<FolderInfo> getFolders(int accountId)
	{
		String sqlString="select foldername,displayname from folders where accountid="+accountId;
		Cursor cursor=query(sqlString, null);
		ArrayList<FolderInfo> folders=new ArrayList<FolderInfo>();
		while(cursor.moveToNext())
		{	
			FolderInfo info=new FolderInfo(accountId,cursor.getString(0), cursor.getString(1));
			folders.add(info);
		}
		cursor.close();
		return folders;
	}
	/**
	 * @param xmlReader
	 * @param id
	 * 
	 */

	public void insertFoldersToDb(Element xmlReader, int accountId)
	{
		execSQL("delete from folders where accountid=?",new String[]{accountId+""});
		String insert="insert into folders values("+accountId+",?,?)";
		NodeList folderElements=xmlReader.getElementsByTagName("folder");
		for (int i = 0; i < folderElements.getLength(); i++)
		{
			Element folder=(Element) folderElements.item(i);
			String folderName=folder.getAttribute("foldername");
			System.out.println("accountid=="+accountId+"foldername=="+folderName);
			int c=executScalar("select count(*) from folders where accountid=? and foldername=?", new String[]{accountId+"",folderName});
			if(c==0)
			{
				String displayName=folder.getAttribute("displayname");
				execSQL(insert, new String[]{folderName,displayName});		
			}
		}
		
	}
	static SimpleDateFormat dateFormat = new SimpleDateFormat("yy-MM-dd HH:mm:ss");

//	public static String date2str(java.util.Date d)
//	{
//		return dateFormat.format(d);
//	}

//	public static Date str2date(String s) throws ParseException
//	{
//		return dateFormat.parse(s);
//	}
//	public int getMailCount()throws SQLException{
//		if(currentAccount!=null){
//			
//		}
//	}
	private int upgradeToV12(int fromVersion)
	{
		if(fromVersion >= DATABASE_VERSION_V12)
			return fromVersion;
		SQLiteDatabase db = this.getWritableDatabase();
		try
		{
			db.execSQL("drop table attachmentInfo");
		}
		catch (Exception e)
		{
			// TODO: handle exception
		}
		try {
			
			db.execSQL("CREATE TABLE [attachmentInfo] (" + 
				"  [mailUid] VARCHAR NOT NULL, " + 
				"  [mailFolder] VARCHAR NOT NULL, " +
				"  [attachIdx] INTEGER NOT NULL, " + 
				"  [fileName] VARCHAR, " + 
				"  [size] VARCHAR, " + 
				"  [fileType] VARCHAR, " + 
				"  [accountId] INTEGER NOT NULL," +
				"  [canPreview] tinyint(1) DEFAULT '0'," +
				"  [filePath] VARCHAR DEFAULT NULL," +
				"  PRIMARY KEY ([mailUid], [mailFolder], [attachIdx], [accountId]))",new Object[0] );
		//		"  CONSTRAINT [sqlite_autoindex_attachmentInfo_1] PRIMARY KEY ([uidx], [attachIdx]))", new Object[0] );
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		try {
			db.execSQL("CREATE TABLE \"folders\"" + 
				"(accountid integer not null,\n" + 
				"foldername varchar(50) not null,\n" + 
				" displayname varchar(50) not null,\n" + 
				"primary key(accountid,foldername)\n" + 
				")", new Object[0]);
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		try
		{
			db.execSQL("CREATE TABLE \"mail2\"(" +
					"uid varchar(70) NOT NULL,\n"+
					"subject varchar(512),\n"+
					"date DATETIME DEFAULT (CURRENT_TIMESTAMP),\n"+
					"\"from\" varchar(100),\n"+
					"state INTEGER DEFAULT (0),\n"+
					"hasAttach INTEGER DEFAULT (0),\n"+
					"accountId INTEGER DEFAULT (0),\n"+
					"uidx INTEGER NOT NULL,\n"+
					"\"to\" varchar(1024),\n"+
					"cc varchar(1024),\n"+
					"folder VARCHAR(20) NOT NULL DEFAULT ('INBOX'),\n"+
					"body TEXT,\n"+
					"asterisk INTEGER DEFAULT (0),\n"+
					"CONSTRAINT sqlite_autoindex_mail_1 PRIMARY KEY (uid,accountId,folder)\n" +
					");");
					db.execSQL("insert into mail2 select * from mail");
					db.execSQL("drop table mail");
					db.execSQL("alter table mail2 rename to mail");
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		db.execSQL("update mail set uidx=0 where state="+MailStatus.MAIL_DELETED);
		db.execSQL("update outBox set state="+MailStatus.MAIL_LOCAL_DELETED+" where state="+MailStatus.MAIL_DELETED);
		db.execSQL("insert or replace into sysconfig (name, value) values('clientVersion', " + DATABASE_VERSION_V12+")", new Object[0]); //select value from sysconfig where name='clientVersion'
		return DATABASE_VERSION_V12;
		//		int currentVersion = db.getVersion();
//		if(currentVersion>=12)
//			return; //its already higher than 12;
//		Utils.ASSERT(currentVersion == 3);//DB for cloudymail 1.1.0 and 1.1.1 is 3

	}

	private int upgradeToV13(int fromVersion)
	{
		if(fromVersion >= DATABASE_VERSION_V13)
			return fromVersion;
		//1. call upgradeToV12 first, if db is too earlier
		//2. upgrade data tables
		//3. clear user mail cache. since MailRender.jsp is changed for calendar support
		fromVersion = upgradeToV12(fromVersion);
		SQLiteDatabase db = this.getWritableDatabase();
		try
		{
			db.execSQL("CREATE TABLE [mailGroup] (\n" + 
					"  [id] INTEGER PRIMARY KEY AUTOINCREMENT,\n" + 
					"  [accountId] INTEGER NOT NULL,\n" + 
					"  [suffix] VARCHAR NOT NULL,\n" + 
					"  [from] varchar(100),\n" + 
					"  [date] DATETIME DEFAULT (CURRENT_TIMESTAMP),\n" + 
					"  [folderName] VARCHAR(20) NOT NULL DEFAULT ('INBOX'),\n" + 
					"  [count] INTEGER DEFAULT (0));");
					
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}	
		db.execSQL("alter table mail add column [groupId] INTEGER");
		
		String sql = "select * from mail";
	
		Cursor cursor = query(sql, null);
		if (cursor.moveToFirst())
		{
			do
			{

				MailInfo info = new InMailInfo(cursor);
				long groupId=updateMailGroup(info);
				db.execSQL("update mail set groupId='"+groupId+"' where accountId="+info.getAccountId()+" and uid="+info.getUid()+" and folder='"+info.getFolder()+"'");
			} while (cursor.moveToNext());
		}
		else
			Log.d(LOGTAG,"There's no mail to upgrade");
		cursor.close();
		updateMailGroupState();
		db.execSQL("insert or replace into sysconfig (name, value) values('clientVersion', " + DATABASE_VERSION_V13+")", new Object[0]); //select value from sysconfig where name='clientVersion'
		return DATABASE_VERSION_V13;
	}

	
	/**
	 * String[] argsStrings = { a.name, a.loginName, a.mailServer,
								a.getMailPort() + "", a.smtpServer,
								a.smtpPort + "", a.serverType,
								(a.useSSL ? 1 : 0) + "", encryptPassword};
//		(a.useSSL ? 1 : 0) + "", a.password };
		
		
		String CommandText = "insert into account (name, loginName, mailServer, "
								+ "mailPort, smtpServer, smtpPort, serverType, useSSL, password) "
								+ "values(?,?,?,?,?,?,?,?,?)";
		this.getWritableDatabase().execSQL(CommandText, argsStrings);
		
		String cmd2 = "insert into mail (uid, subject, date, 'from', 'to', cc, uidx, state, hasAttach,accountId,folder) values(?,?,?,?,?,?,?,?,?, "
							+ accountId
							+ ","
							+ "\""
							+ FolderNames.FOLDER_INBOX + "\")";
	    String cmd3 = "update mail set  subject=?, date=?, 'from'=?, 'to'=?, cc=?, uidx=?, state=?,hasAttach=?,folder='"
							+ FolderNames.FOLDER_INBOX
							+ "' where uid=? and accountId= " + accountId;
	 */
	/**
	 *  insert attachment into attachmentInfo table
	 */
	public void insertAttachInfo(AttachmentInfo attaInfo, int accountId) 
	{
		String insertCommand="replace into attachmentInfo (mailUid,mailFolder,attachIdx,fileName,size,fileType, accountId,canPreview) values(?,?,?,?,?,?,?,?)"; 		
      	this.getWritableDatabase().execSQL(insertCommand, 
      	                                   new Object[]{attaInfo.getMailUid(),attaInfo.getMailInfo().getFolder(), attaInfo.index,
      	                                              attaInfo.fileName,attaInfo.size, attaInfo.fileType,
      	                                            accountId,attaInfo.canPreview?1:0});
	}
	
	//update file path on sd card after download attachment finished.
	public boolean updateAttachFilePath(int accountId,String mailUid,String mailFolder, int attachIdx,String filePath)
	{
		String upCmd = "update attachmentInfo set filePath='"+filePath+
						"' where accountId='"+accountId+"' and mailUid='"+mailUid+
						"' and attachIdx='"+attachIdx+"'"+" and mailFolder='"+mailFolder+"'";
		try
		{
			getWritableDatabase().execSQL(upCmd);
			return true;
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
			//do nothing.
		}
		return false;
	}
	
	public File getAttachFilePath(int accountId, String mailUid, String mailFolder, int attachIdx)
	{
		String findSql= "select filePath from attachmentInfo" + 
						" where attachmentInfo.mailUid='" + mailUid + 
						"' and attachmentInfo.accountId='" + accountId +
						"' and attachmentInfo.attachIdx='" + attachIdx + "'";
		
		Cursor rawQuery = null;
		try
		{
			rawQuery = this.getReadableDatabase().rawQuery(findSql, null);
			if(rawQuery!=null)
			{
				int filePathIndex = rawQuery.getColumnIndex("filePath");
			    if(rawQuery.moveToFirst()) 
			    {
			    	String filePath = rawQuery.getString(filePathIndex);
			    	if(filePath == null)
			    	{
			    		return null;
			    	}
			    	return new File(filePath);
			    	
			    }
		     }
		}
		catch(SQLException ex)
		{
			ex.printStackTrace();
		}
		return null;
	}

	public List<AttachmentInfo> getAttachmentInfo(String fileType) 
	{
		Hashtable<String, MailInfo> cache = new Hashtable<String, MailInfo> (137);
		
		List<AttachmentInfo> attachments=new ArrayList<AttachmentInfo>();

       String queryCmd="select mail.date, mail.folder, attachmentInfo.mailUid, "+
    	   "attachmentInfo.attachIdx, attachmentInfo.size,attachmentInfo.fileName, "+
    	   "attachmentInfo.fileType, attachmentInfo.accountId,attachmentInfo.canPreview,"+
    	   "attachmentInfo.filePath from attachmentInfo,mail "+
    	   "where attachmentInfo.mailUid=mail.uid and mail.accountId=attachmentInfo.accountId and mail.folder=attachmentInfo.mailFolder and mail.state in ("+MailStatus.MAIL_READED +"," + MailStatus.MAIL_NEW+")";
       if(!Utils.isEmpty(fileType))
    	   queryCmd += " and fileType='"+fileType+"'";
       queryCmd += " order by mail.date DESC";
//    	   		"attachName like '%."+fileType +"'";
       
       
       Cursor rawQuery = null;
       try
       {
    	   rawQuery = this.getReadableDatabase().rawQuery(queryCmd, null);
	       if(rawQuery!=null)
	       {
				int uidIndex = rawQuery.getColumnIndex("mailUid");
				int folderIndex=rawQuery.getColumnIndex("folder");
				int attachidx = rawQuery.getColumnIndex("attachIdx");
				int attSizeIndex = rawQuery.getColumnIndex("size");
				int attNameIndex = rawQuery.getColumnIndex("fileName");
				int attFileType=rawQuery.getColumnIndex("fileType");
				int accountIdIndex = rawQuery.getColumnIndex("accountId");
				int previewIndex = rawQuery.getColumnIndex("canPreview");
				int filePathIndex = rawQuery.getColumnIndex("filePath");
	            if(rawQuery.moveToFirst())
		        {
		    	   do
		    	   {
		    		   
		    		   int accountId=rawQuery.getInt(accountIdIndex);
		    		   String folderName=rawQuery.getString(folderIndex);
		    		   String uid = rawQuery.getString(uidIndex);
		    		   String key = uid+accountId;
		    		   MailInfo info = cache.get(key);
		    		   if(info == null)
		    		   {
		    			   Cursor query = null;
		    			   try
		    			   {
		    				   query = this.getReadableDatabase().rawQuery("select * from mail where accountid=? and uid=? and folder=?", new String[]{accountId+"", uid,folderName});
			    			   query.moveToFirst();
			    			   info = new InMailInfo(query);
			    			   cache.put(key, info);
		    			   }
		    			   finally
		    			   {
		    				   query.close();
		    			   }
		    		   }
		    		   AttachmentInfo attach=new AttachmentInfo(info);
		    		   info.addAttachInfo(attach);
		    		   attach.index=rawQuery.getInt(attachidx);
		    		   attach.fileName=rawQuery.getString(attNameIndex);
		    		   attach.fileType=rawQuery.getString(attFileType);
		    		   attach.size = rawQuery.getString(attSizeIndex);
		    		   attach.canPreview = (rawQuery.getInt(previewIndex)!=0);
		    		   attach.fullFilePath = rawQuery.getString(filePathIndex);
		    		   
		    		   attachments.add(attach);
		    	   }while(rawQuery.moveToNext());
		         }
	           
	     	}
       }
       finally
       {
    	   rawQuery.close();
       }
     
	   return attachments;
	}
	public int getAttachmentCount() {
        String cmd="select count(*) as num from attachmentInfo";
        int attCount = this.executScalar(cmd, null);
        return attCount; 
        
	}
	public int getAttachCountAsType(String fileType)
	{
		String cmd="select count(*) as num from attachmentInfo where fileType='"+fileType+"'";
		int attCount=this.executScalar(cmd, null);
		return attCount;
	}
	public String deleteAccountInfo(Account a)
	{

		String errStr = "";
		SQLiteDatabase db = getWritableDatabase();
		// try {
		String cmdTxt = "";
		// the mails belonged to this account will also be deleted.
		cmdTxt = "delete from mail where accountId=" + a.id;
		db.execSQL(cmdTxt);

		cmdTxt= "delete from folders where accountid="+a.id;
		db.execSQL(cmdTxt);
		
		cmdTxt= "delete from attachmentInfo where accountid="+a.id;
		db.execSQL(cmdTxt);
		cmdTxt= "delete from mailGroup where accountid="+a.id;
		db.execSQL(cmdTxt);
		
		// } catch (SQLException e) {
		// errStr = e.getMessage();
		// }
		return errStr;
	}
	public int getGroupCount(int accountId, String folderName, boolean excludeHasMore){
		String cmd=null;
		if(excludeHasMore)
			cmd = "select count(*) from mailGroup where mailGroup.count>0 and mailGroup.folderName=? and not exists (select state from mail where mail.groupId=mailGroup.id and mail.state >="+MailStatus.FLAG_HAS_MORE_PLACEHOLD + ") ";
		else
			cmd = "select count(*) from mailGroup where count>0 and folderName=? ";
		Vector<String> args = new Vector<String>(2);
		args.add(folderName);
		if(accountId > 0)
		{
			cmd += " and mailGroup.accountId=?";
			args.add(accountId+"");
		}
		int executScalar = executScalar(cmd,args.toArray(new String[1]));
		return executScalar;
	}
	
	public  Cursor getInGroups(int accountId, int length, int offset, String folderName, int orderType, boolean excludeHasMore) 
	{
		String cmd = null;
		
		if(excludeHasMore)
		{
			cmd = "select * from mailGroup where mailGroup.count>0 and mailGroup.folderName=? and not exists (select state from mail where mail.groupId=mailGroup.id and mail.state >="+MailStatus.FLAG_HAS_MORE_PLACEHOLD + ") "; 
		}
		else
			cmd="select * from mailGroup where  mailGroup.count>0 and  mailGroup.folderName=? "; 
		Vector<String> args = new Vector<String>(2);
		args.add(folderName);
		if(accountId > 0)
		{
			cmd += " and  mailGroup.accountId=? ";
			args.add(accountId+"");
		}
		cmd += getGroupOrderSql(orderType);
		cmd+=" limit " + length +" offset " +offset;
		return query(cmd,args.toArray(new String[1]));
	}


	public Vector<MailInfo> queryMailByGroup(int groupId) {
		//state 3,4,5 equals to MailStatus.MAIL_DELETED MAIL_DELETE_FOREVER MAIL_LOCAL_DELETED
		String cmd="select * from mail where groupId=? and state not in (3,4,5) order by date desc";	
		String [] args={String.valueOf(groupId)};
		Cursor cursor=null;
		Vector<MailInfo> vector=new Vector<MailInfo>(); 
		cursor=query(cmd,args);
		try {
			if(cursor!=null)
			{
			   if(cursor.moveToFirst())
			   {
				   do{
					 MailInfo mailInfo =new InMailInfo(cursor);
					 vector.add(mailInfo);
				   }while(cursor.moveToNext());
			   }
			}
		  }
          finally
          {
        	  cursor.close();
          }
		return vector ;
		
	}
	
	public void updateMailGroupState()
	{
		String sql = "update mailGroup set count=(select count(*) from mail where mail.groupId=mailGroup.id and (mail.state !="+MailStatus.MAIL_DELETED +" and mail.state!="+MailStatus.MAIL_DELETE_FOREVER+" and mail.state!="+MailStatus.MAIL_LOCAL_DELETED+"))";
		execSQL(sql, new Object[] {});
	}
}
package mobi.cloudymail.util;

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * Usage:
 * 
 * <pre>
 * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)
 * ...
 * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)
 * </pre>
 * 
 * @author ferenc.hechler
 */
public class SimpleCrypto
{

	public static String encrypt(String seed, String cleartext) throws Exception
	{
		byte[] rawKey = getRawKey(seed.getBytes());
		byte[] result = encrypt(rawKey, cleartext.getBytes());
		return toHex(result);
	}

	public static String decrypt(String seed, String encrypted) throws Exception
	{
		byte[] rawKey = getRawKey(seed.getBytes());
		byte[] enc = toByte(encrypted);
		byte[] result = decrypt(rawKey, enc);
		return new String(result);
	}

	private static byte[] getRawKey(byte[] seed) throws Exception
	{
		KeyGenerator kgen = KeyGenerator.getInstance("AES");
		SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
		sr.setSeed(seed);
		kgen.init(128, sr); // 192 and 256 bits may not be available
		SecretKey skey = kgen.generateKey();
		byte[] raw = skey.getEncoded();
		return raw;
	}

	private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception
	{
		SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
		Cipher cipher = Cipher.getInstance("AES");
		cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
		byte[] encrypted = cipher.doFinal(clear);
		return encrypted;
	}

	private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception
	{
		SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
		Cipher cipher = Cipher.getInstance("AES");
		cipher.init(Cipher.DECRYPT_MODE, skeySpec);
		byte[] decrypted = cipher.doFinal(encrypted);
		return decrypted;
	}

	public static String toHex(String txt)
	{
		return toHex(txt.getBytes());
	}

	public static String fromHex(String hex)
	{
		return new String(toByte(hex));
	}

	public static byte[] toByte(String hexString)
	{
		int len = hexString.length() / 2;
		byte[] result = new byte[len];
		for (int i = 0; i < len; i++)
			result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
		return result;
	}

	public static String toHex(byte[] buf)
	{
		if (buf == null)
			return "";
		StringBuffer result = new StringBuffer(2 * buf.length);
		for (int i = 0; i < buf.length; i++)
		{
			appendHex(result, buf[i]);
		}
		return result.toString();
	}

	private final static String HEX = "0123456789ABCDEF";

	private static void appendHex(StringBuffer sb, byte b)
	{
		sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
	}

}package mobi.cloudymail.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.EnumSet;

import mobi.cloudymail.mailclient.R;
import mobi.cloudymail.mailclient.net.ServerAgent;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpGet;
import org.json.JSONArray;
import org.json.JSONObject;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Intent;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Handler;
import android.util.Log;

public class SoftwareUpdate
{
	String _oldVersion = null;
	int _oldVersionCode = -1;
	String _newVersion = null;
	int _newVersionCode = -1;
	String _newFeature = "";
	
	final static String APK_NAME = "CloudyMail.apk";
	final static String VERSION_JSON = "version.json";
	private Handler handler = new Handler();
	private ProgressDialog pBar=null;
//	private Context ctx;
	private boolean _doSilent = false;
	
	private static SoftwareUpdate _inst=null;
	
	public static SoftwareUpdate getInstance()
	{
		if(_inst == null)
			_inst = new SoftwareUpdate();
		return _inst;
	}
	
	private SoftwareUpdate()
	{
		_oldVersion = getVerName();
		_oldVersionCode = getVerCode();
		_newVersion = _oldVersion;
		_newVersionCode = _oldVersionCode;
	}
	
	public static int getVerCode() {  
        int verCode = -1;  
        try {  
            verCode = MyApp.instance().getPackageManager().getPackageInfo(  
                    "mobi.cloudymail.mailclient", 0).versionCode;  
        } catch (NameNotFoundException e) {  
            e.printStackTrace();
        }  
        return verCode;  
    } 
	
	public static String getVerName() {  
        return MyApp.instance().getResources().getString(R.string.about_version);   
        }
	
	private boolean getServerVer() { 
		try {
			String versionFilePath = downloadVersionFile(ServerAgent.getUrlBase()
					+ "/" + VERSION_JSON, VERSION_JSON);
			if (versionFilePath.equals(""))
				return false;
			// read json file;
			BufferedReader reader = null;
			reader = new BufferedReader(new InputStreamReader(new FileInputStream(versionFilePath),"gb2312"));//new FileReader(versionFilePath));
			StringBuffer buffer = new StringBuffer();
			String line = reader.readLine(); // 读取第一行
			while (line != null) { // 如果 line 为空说明读完了
				buffer.append(line); // 将读到的内容添加到 buffer 中
				line = reader.readLine(); // 读取下一行
			}
			JSONArray jary = new JSONArray(buffer.toString()); 
			JSONObject obj = jary.getJSONObject(0);
			_newVersionCode = Integer.parseInt(obj.getString("verCode"));
			_newVersion = obj.getString("verName");
			if(obj.has("newFeature"))
				_newFeature = obj.getString("newFeature");
			return true;
		} catch (Exception e) {
			e.printStackTrace();
			_newVersionCode = -1;
			_newVersion = "";
			return false;
		}  	
  //the version file looks like
  //[{"appName":"CloudyMail","apkname":"CloudyMail.apk","verName":1.0.0,"verCode":2}]
    }
	
	//return downloaded json file path.
	private String downloadVersionFile(String url, String fileName)
	{
		 HttpGet get = new HttpGet(url);  
         HttpResponse response;  
         try {  
             response = ServerAgent.execute(get);  
             HttpEntity entity = response.getEntity();  
             long length = entity.getContentLength();  
             InputStream is = entity.getContent();  
             FileOutputStream fileOutputStream = null;  
             String filePath="";
             if (is != null) {  
            	 filePath = MyApp.instance().getAppSdcardPath()+"/"+fileName;
                 File file = new File(MyApp.instance().getAppSdcardPath(),fileName); 
                 fileOutputStream = new FileOutputStream(file);  
                 byte[] buf = new byte[1024];  
                 int ch = -1;  
                 int count = 0;  
                 while ((ch = is.read(buf)) != -1) {  
                     fileOutputStream.write(buf, 0, ch);  
                     count += ch;  
                 }  
             }    
             if (fileOutputStream != null) 
             {
            	 fileOutputStream.flush();
                 fileOutputStream.close();  
             }  
             return filePath;
         } catch (ClientProtocolException e) {  
             e.printStackTrace(); 
             return "";
         } catch (IOException e) {  
             e.printStackTrace(); 
             return "";
         }  
	}
	
	private void onGetServerVerFinished(final boolean value)
	{
		handler.post(new Runnable() {
			public void run()
			{
				if (value)
				{
					if (_newVersionCode > _oldVersionCode)
					{
						doNewVersionUpdate(); // 更新新版本
					}
					else if(!_doSilent)
					{
						notNewVersionShow(); // 提示当前为最新版本
					}
				}
				else if(!_doSilent)
				{
					Activity curAct = MyApp.getCurrentActivity();
					DialogUtils.showMsgBox(curAct,
					                       curAct.getResources().getString(R.string.err_get_latest_version),
					                       curAct.getResources()
												.getString(R.string.error));
				}
			}
		});
	}
	
	public void checkUpdate(boolean silence)
	{
//		this.ctx = ctx;
		_doSilent = silence;
		Activity curAct = MyApp.getCurrentActivity();
		if(!ServerAgent.hasNetworkConnection())
		{
			if(!silence)
			{
				Resources res = curAct.getResources();
				MessageBox.show(curAct, res.getString(R.string.err_notConnected),
								res.getString(R.string.error));
			}
			return;
		}
		
		Log.d(Utils.LOGTAG, "check version update");
		new Thread() {  
	        public void run() {
/*	        	try
	        	{
	        	this.sleep(1000);
	        	}catch(Exception excp)
	        	{
	        		
	        	}*/
	        	
	        	boolean value = getServerVer();
	        	onGetServerVerFinished(value);
	        }  
	    }.start();
	    
	    
/*		if (getServerVer()) {  
	         if (_newVersionCode > _oldVersionCode) {  
	             doNewVersionUpdate(); // 更新新版本  
	         } else {  
	             notNewVersionShow(); // 提示当前为最新版本  
	         }  
	     } 
		else {
			DialogUtils.showMsgBox(ctx, "Failed to get latest version number!",
					ctx.getResources().getString(R.string.error));
		}*/
	}
	
	private void notNewVersionShow() {    
		Activity curAct = MyApp.getCurrentActivity();
	    Resources res = curAct.getResources();
	    String contentStr = String.format(res.getString(R.string.no_need_update_str),_oldVersion);
	    DialogUtils.showMsgBox(curAct, contentStr, res.getString(R.string.update_software)); 
	}  
	
	private void doNewVersionUpdate() {  
		Activity curAct = MyApp.getCurrentActivity();
	    Resources res = curAct.getResources();
	    String contentStr = String.format(res.getString(R.string.whether_update_str),_oldVersion,_newVersion,_newFeature);  
		try {
			if (DialogUtils.showModalMsgBox(curAct, contentStr, res.getString(R.string.update_software),
					EnumSet.of(DialogUtils.ButtonFlags.Yes,
							DialogUtils.ButtonFlags.No)) == DialogResult.OK) {
				pBar = new ProgressDialog(curAct);
				pBar.setTitle(res.getString(R.string.update_downloading));
				pBar.setMessage(res.getString(R.string.update_wait));
				pBar.setProgressStyle(ProgressDialog.STYLE_SPINNER);
				pBar.show();
				downFile(ServerAgent.getUrlBase() + "/"+APK_NAME,APK_NAME);
			}
		} catch (Exception e) {
			// TODO: handle exception
			e.printStackTrace();
		}
	}
	
	private void downFile(final String url, final String fileName) {  
	    new Thread() {  
	        public void run() {  
	            HttpGet get = new HttpGet(url);  
	            HttpResponse response;  
	            try {  
	                response = ServerAgent.execute(get);  
	                HttpEntity entity = response.getEntity();  
	                long length = entity.getContentLength();  
	                InputStream is = entity.getContent();  
	                FileOutputStream fileOutputStream = null;  
	                if (is != null) {  
	                    File file = new File(MyApp.instance().getAppSdcardPath(),APK_NAME); 
	 	                    fileOutputStream = new FileOutputStream(file);  
	                    byte[] buf = new byte[1024];  
	                    int ch = -1;  
	                    int count = 0;  
	                    while ((ch = is.read(buf)) != -1) {  
	                        fileOutputStream.write(buf, 0, ch);  
	                        count += ch;  
	                    }  
	                }  
	                fileOutputStream.flush();  
	                if (fileOutputStream != null) {  
	                    fileOutputStream.close();  
	                }  
	                down("");  
	            } catch (ClientProtocolException e) {  
	                e.printStackTrace(); 
	                down(e.getMessage());
	            } catch (IOException e) {  
	                e.printStackTrace(); 
	                down(e.getMessage());
	            }  
	        }  
	    }.start();  
	} 
	
	private void down(final String msg) {  
        handler.post(new Runnable() {  
            public void run() {  
                pBar.cancel(); 
                if(msg.equals(""))
                	update(); 
                else {
                	Activity curAct = MyApp.getCurrentActivity();
                	Resources res = curAct.getResources();
					DialogUtils.showMsgBox(curAct, res.getString(R.string.err_update_failed)+msg,
							res.getString(R.string.error));
				}
            }  
        });  
	}
	
	private void update() {  
	    Intent intent = new Intent(Intent.ACTION_VIEW);  
	    intent.setDataAndType(Uri.fromFile(new File(MyApp.instance().getAppSdcardPath(), 
	    		APK_NAME)),  
	            "application/vnd.android.package-archive");  
	    MyApp.getCurrentActivity().startActivity(intent);  
	} 	
}package mobi.cloudymail.util;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.math.BigDecimal;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.concurrent.Semaphore;

import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;


public class Utils {
	public static final String LOGTAG = "CloudyMail";
	public static void logException(Exception ex) 
	{
		ex.printStackTrace();
	}
	
	
	private static SimpleDateFormat dateFmt = new SimpleDateFormat("yyyy-MM-dd");
	public static final SimpleDateFormat earlierFormat = new SimpleDateFormat("yy年M月d日 H:mm");
	public static final SimpleDateFormat nearFormat = new SimpleDateFormat("M月d日 H:mm");
	public static SimpleDateFormat netDateFormater = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	private static SimpleDateFormat accurateDateFormater = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSSZ");


	/**
	 * Convert a date to string.
	 * @param value The date value
	 * @param d The default value if the date is null
	 */
	public static String getDateDisplay(Date value, String d) {
		if (value == null) {
			return d;
		} else {
			return dateFmt.format(value);
		}
	}


	/**
	 * Format a decimal value.
	 * @param value The decimal value
	 * @param fraction The digital count of fraction part
	 */
	public static String formatDecimal(BigDecimal value, int fraction) {
		if(value == null)
		{
			return "";
		}
		String str = value.toString();

		// Split the digital string into two parts.

		String leftPart, rightPart;
		StringBuffer buf = new StringBuffer();
		int dotPos = str.indexOf('.');
		if (dotPos >= 0) {
			leftPart = str.substring(0, dotPos);
			rightPart = str.substring(dotPos + 1);
		} else {
			leftPart = str;
			rightPart = "";
		}

		// Process the part before ".".

		int len = leftPart.length();
		buf.append(leftPart);
		int secPos = len - 3;
		while (secPos > 0) {
			buf.insert(secPos, ',');
			secPos -= 3;
		}

		// Process the fraction part.

		buf.append('.');
		len = rightPart.length();
		if (len > fraction) {
			buf.append(rightPart.substring(0, fraction));
		} else {
			buf.append(rightPart);
			while (len < fraction) {
				buf.append('0');
				len++;
			}
		}

		return buf.toString();
	}

	// Escape a string in JavaScript string syntax. 
	//
	// NOTE: Can't used to escape URL string. To escape URL, please use java.net.URLEncoder.encode(url)
	public static String escapeStr(String str) {
		if (str == null) {
			return "";
		}
		int len = str.length();
		StringBuilder buf = new StringBuilder(len + 10);
		for (int i = 0; i < len; i++) {
			char ch = str.charAt(i);
//			if (ch == '\\') {
//				buf.append("\\\\");
//			} else if (ch == '\'') {
//				buf.append("\\'");
//			} else if (ch == '\n') {
//				buf.append("\\n");
//			} else if (ch == '\r') {
//				buf.append("\\r");
//			} else if (ch == '\t') {
//				buf.append("\\t");
//			} else {
//				buf.append(ch);
//			}
			switch (ch)
			{
			case '&':
				buf.append("&amp;");
				break;
			case '<':
				buf.append("&lt;");
				break;
			case '>':
				buf.append("&gt;");
				break;
			case '\'':
				buf.append("&apos;");
				break;
			case '\"':
				buf.append("&quot;");
				break;
			default:
				buf.append(ch);
			}
		}
		return buf.toString();
	}


 
    /*
     * if input str is null,return a empty string.this prevent the string "null"
     * presents on the screen
     */
    public static String formatString(String str)
    {
    	return (str==null)?"":str;
    }

	public static boolean isEmpty(String str)
	{
		return str == null || str.length() == 0;
	}
    
	public static void ASSERT(boolean b)
	{
		assert b;
	}
	
//	public static byte[] readPostData(javax.servlet.http.HttpServletRequest request) throws IOException
//	{
//		ServletInputStream is = request.getInputStream();
//		int len = request.getContentLength();
//		if(len < 0)
//			len = 1024;
//		byte[] buf = new byte[len];
//		int totalReaded = 0;
//		int readLen = 0;
//		while(readLen != -1 && totalReaded < len)
//		{
//			totalReaded += readLen;
//			readLen = is.read(buf, totalReaded, len - totalReaded);
//		}
//		if(totalReaded == buf.length)
//			return buf;
//		return Arrays.copyOf(buf, totalReaded);
//	}
	
//  use org.apache.commons.io.FileUtils.deleteQuietly(File f) instead
//	public static boolean rmdirRecursively(String path)
//	{
//		File file = new File(path);
//		String[] children = file.list();
//		for(String child : children)
//		{
//			if(!rmdirRecursively(child)) 
//			{
//				return false;
//			}
//		}
//		return file.delete();
//	}
	
	public static String ensureStringValidate(String str)
	{
		return str.replace("\0", "");
	}
	
	public static boolean inUiThread()
	{
		return Looper.myLooper() != null;
	}
	
	public static void runOnUiThreadAndBlock(final Runnable r)
	{
		final Semaphore waitingSem = new Semaphore(0);
		Runnable r2 = new Runnable() {
			
			@Override
			public void run()
			{
				r.run();
				waitingSem.release();
			}
		};
		MyApp.getCurrentActivity().runOnUiThread(r2);
		try
		{
			waitingSem.acquire();
//			System.out.println("GOT it");
			return;
		}
		catch (InterruptedException e)
		{
			
			e.printStackTrace();
		}
	}
	static public String getReadableSize(long value)
	{
		double sizeF = value;
		String unit = "B";
		if (value > (1 << 30))
		{
			sizeF = sizeF / (1 << 30);
			unit = "GB";
		}
		else if (sizeF > (1 << 20))
		{
			sizeF = sizeF / (1 << 20);
			unit = "MB";
		}
		else if (sizeF > 1024)
		{
			sizeF = sizeF / (1024.0);
			unit = "KB";
		}
		NumberFormat nFormat = NumberFormat.getInstance();
		nFormat.setMaximumFractionDigits(1);
		return (nFormat.format(sizeF) + unit);
	}
	static public void log(String str)
	{
		Log.d(Utils.LOGTAG, str);
		Date now = new Date();
		try
		{
			FileWriter fo = new FileWriter(Environment.getExternalStorageDirectory() + "/cloudmail.log.txt",true);
			
			fo.write(accurateDateFormater.format(now)+str+"\n");
			fo.close();
		}
		catch (Exception e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
582


